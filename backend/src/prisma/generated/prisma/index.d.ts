
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Landlord
 * 
 */
export type Landlord = $Result.DefaultSelection<Prisma.$LandlordPayload>
/**
 * Model PropertyCategory
 * 
 */
export type PropertyCategory = $Result.DefaultSelection<Prisma.$PropertyCategoryPayload>
/**
 * Model PropertyType
 * 
 */
export type PropertyType = $Result.DefaultSelection<Prisma.$PropertyTypePayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model UnitType
 * 
 */
export type UnitType = $Result.DefaultSelection<Prisma.$UnitTypePayload>
/**
 * Model UnitServiceCharge
 * 
 */
export type UnitServiceCharge = $Result.DefaultSelection<Prisma.$UnitServiceChargePayload>
/**
 * Model UnitMeterNumber
 * 
 */
export type UnitMeterNumber = $Result.DefaultSelection<Prisma.$UnitMeterNumberPayload>
/**
 * Model UnitFeature
 * 
 */
export type UnitFeature = $Result.DefaultSelection<Prisma.$UnitFeaturePayload>
/**
 * Model PropertyStandingCharge
 * 
 */
export type PropertyStandingCharge = $Result.DefaultSelection<Prisma.$PropertyStandingChargePayload>
/**
 * Model PropertySecurityDeposit
 * 
 */
export type PropertySecurityDeposit = $Result.DefaultSelection<Prisma.$PropertySecurityDepositPayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantEmergencyContact
 * 
 */
export type TenantEmergencyContact = $Result.DefaultSelection<Prisma.$TenantEmergencyContactPayload>
/**
 * Model Lease
 * 
 */
export type Lease = $Result.DefaultSelection<Prisma.$LeasePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UnitStatus: {
  VACANT: 'VACANT',
  OCCUPIED: 'OCCUPIED',
  MAINTENANCE: 'MAINTENANCE',
  RESERVED: 'RESERVED'
};

export type UnitStatus = (typeof UnitStatus)[keyof typeof UnitStatus]


export const LeaseStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  TERMINATED: 'TERMINATED',
  RENEWED: 'RENEWED'
};

export type LeaseStatus = (typeof LeaseStatus)[keyof typeof LeaseStatus]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHEQUE: 'CHEQUE',
  MPESA: 'MPESA',
  CARD: 'CARD',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  PROPERTY_MANAGER: 'PROPERTY_MANAGER',
  ACCOUNTANT: 'ACCOUNTANT',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UnitStatus = $Enums.UnitStatus

export const UnitStatus: typeof $Enums.UnitStatus

export type LeaseStatus = $Enums.LeaseStatus

export const LeaseStatus: typeof $Enums.LeaseStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Properties
 * const properties = await prisma.property.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Properties
   * const properties = await prisma.property.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landlord`: Exposes CRUD operations for the **Landlord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Landlords
    * const landlords = await prisma.landlord.findMany()
    * ```
    */
  get landlord(): Prisma.LandlordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyCategory`: Exposes CRUD operations for the **PropertyCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyCategories
    * const propertyCategories = await prisma.propertyCategory.findMany()
    * ```
    */
  get propertyCategory(): Prisma.PropertyCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyType`: Exposes CRUD operations for the **PropertyType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyTypes
    * const propertyTypes = await prisma.propertyType.findMany()
    * ```
    */
  get propertyType(): Prisma.PropertyTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitType`: Exposes CRUD operations for the **UnitType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitTypes
    * const unitTypes = await prisma.unitType.findMany()
    * ```
    */
  get unitType(): Prisma.UnitTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitServiceCharge`: Exposes CRUD operations for the **UnitServiceCharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitServiceCharges
    * const unitServiceCharges = await prisma.unitServiceCharge.findMany()
    * ```
    */
  get unitServiceCharge(): Prisma.UnitServiceChargeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitMeterNumber`: Exposes CRUD operations for the **UnitMeterNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitMeterNumbers
    * const unitMeterNumbers = await prisma.unitMeterNumber.findMany()
    * ```
    */
  get unitMeterNumber(): Prisma.UnitMeterNumberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitFeature`: Exposes CRUD operations for the **UnitFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitFeatures
    * const unitFeatures = await prisma.unitFeature.findMany()
    * ```
    */
  get unitFeature(): Prisma.UnitFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyStandingCharge`: Exposes CRUD operations for the **PropertyStandingCharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyStandingCharges
    * const propertyStandingCharges = await prisma.propertyStandingCharge.findMany()
    * ```
    */
  get propertyStandingCharge(): Prisma.PropertyStandingChargeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertySecurityDeposit`: Exposes CRUD operations for the **PropertySecurityDeposit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertySecurityDeposits
    * const propertySecurityDeposits = await prisma.propertySecurityDeposit.findMany()
    * ```
    */
  get propertySecurityDeposit(): Prisma.PropertySecurityDepositDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantEmergencyContact`: Exposes CRUD operations for the **TenantEmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantEmergencyContacts
    * const tenantEmergencyContacts = await prisma.tenantEmergencyContact.findMany()
    * ```
    */
  get tenantEmergencyContact(): Prisma.TenantEmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lease`: Exposes CRUD operations for the **Lease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leases
    * const leases = await prisma.lease.findMany()
    * ```
    */
  get lease(): Prisma.LeaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.0
   * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Property: 'Property',
    Landlord: 'Landlord',
    PropertyCategory: 'PropertyCategory',
    PropertyType: 'PropertyType',
    Unit: 'Unit',
    UnitType: 'UnitType',
    UnitServiceCharge: 'UnitServiceCharge',
    UnitMeterNumber: 'UnitMeterNumber',
    UnitFeature: 'UnitFeature',
    PropertyStandingCharge: 'PropertyStandingCharge',
    PropertySecurityDeposit: 'PropertySecurityDeposit',
    Tenant: 'Tenant',
    TenantEmergencyContact: 'TenantEmergencyContact',
    Lease: 'Lease',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    User: 'User',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "property" | "landlord" | "propertyCategory" | "propertyType" | "unit" | "unitType" | "unitServiceCharge" | "unitMeterNumber" | "unitFeature" | "propertyStandingCharge" | "propertySecurityDeposit" | "tenant" | "tenantEmergencyContact" | "lease" | "invoice" | "invoiceItem" | "payment" | "user" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Landlord: {
        payload: Prisma.$LandlordPayload<ExtArgs>
        fields: Prisma.LandlordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandlordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandlordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          findFirst: {
            args: Prisma.LandlordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandlordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          findMany: {
            args: Prisma.LandlordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>[]
          }
          create: {
            args: Prisma.LandlordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          createMany: {
            args: Prisma.LandlordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LandlordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>[]
          }
          delete: {
            args: Prisma.LandlordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          update: {
            args: Prisma.LandlordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          deleteMany: {
            args: Prisma.LandlordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandlordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LandlordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>[]
          }
          upsert: {
            args: Prisma.LandlordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          aggregate: {
            args: Prisma.LandlordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandlord>
          }
          groupBy: {
            args: Prisma.LandlordGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandlordGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandlordCountArgs<ExtArgs>
            result: $Utils.Optional<LandlordCountAggregateOutputType> | number
          }
        }
      }
      PropertyCategory: {
        payload: Prisma.$PropertyCategoryPayload<ExtArgs>
        fields: Prisma.PropertyCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          findFirst: {
            args: Prisma.PropertyCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          findMany: {
            args: Prisma.PropertyCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>[]
          }
          create: {
            args: Prisma.PropertyCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          createMany: {
            args: Prisma.PropertyCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>[]
          }
          delete: {
            args: Prisma.PropertyCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          update: {
            args: Prisma.PropertyCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          deleteMany: {
            args: Prisma.PropertyCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>[]
          }
          upsert: {
            args: Prisma.PropertyCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryPayload>
          }
          aggregate: {
            args: Prisma.PropertyCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyCategory>
          }
          groupBy: {
            args: Prisma.PropertyCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCategoryCountAggregateOutputType> | number
          }
        }
      }
      PropertyType: {
        payload: Prisma.$PropertyTypePayload<ExtArgs>
        fields: Prisma.PropertyTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          findFirst: {
            args: Prisma.PropertyTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          findMany: {
            args: Prisma.PropertyTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>[]
          }
          create: {
            args: Prisma.PropertyTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          createMany: {
            args: Prisma.PropertyTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>[]
          }
          delete: {
            args: Prisma.PropertyTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          update: {
            args: Prisma.PropertyTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          deleteMany: {
            args: Prisma.PropertyTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>[]
          }
          upsert: {
            args: Prisma.PropertyTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          aggregate: {
            args: Prisma.PropertyTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyType>
          }
          groupBy: {
            args: Prisma.PropertyTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyTypeCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      UnitType: {
        payload: Prisma.$UnitTypePayload<ExtArgs>
        fields: Prisma.UnitTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>
          }
          findFirst: {
            args: Prisma.UnitTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>
          }
          findMany: {
            args: Prisma.UnitTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>[]
          }
          create: {
            args: Prisma.UnitTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>
          }
          createMany: {
            args: Prisma.UnitTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>[]
          }
          delete: {
            args: Prisma.UnitTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>
          }
          update: {
            args: Prisma.UnitTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>
          }
          deleteMany: {
            args: Prisma.UnitTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>[]
          }
          upsert: {
            args: Prisma.UnitTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypePayload>
          }
          aggregate: {
            args: Prisma.UnitTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitType>
          }
          groupBy: {
            args: Prisma.UnitTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitTypeCountArgs<ExtArgs>
            result: $Utils.Optional<UnitTypeCountAggregateOutputType> | number
          }
        }
      }
      UnitServiceCharge: {
        payload: Prisma.$UnitServiceChargePayload<ExtArgs>
        fields: Prisma.UnitServiceChargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitServiceChargeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitServiceChargeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>
          }
          findFirst: {
            args: Prisma.UnitServiceChargeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitServiceChargeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>
          }
          findMany: {
            args: Prisma.UnitServiceChargeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>[]
          }
          create: {
            args: Prisma.UnitServiceChargeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>
          }
          createMany: {
            args: Prisma.UnitServiceChargeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitServiceChargeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>[]
          }
          delete: {
            args: Prisma.UnitServiceChargeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>
          }
          update: {
            args: Prisma.UnitServiceChargeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>
          }
          deleteMany: {
            args: Prisma.UnitServiceChargeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitServiceChargeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitServiceChargeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>[]
          }
          upsert: {
            args: Prisma.UnitServiceChargeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServiceChargePayload>
          }
          aggregate: {
            args: Prisma.UnitServiceChargeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitServiceCharge>
          }
          groupBy: {
            args: Prisma.UnitServiceChargeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitServiceChargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitServiceChargeCountArgs<ExtArgs>
            result: $Utils.Optional<UnitServiceChargeCountAggregateOutputType> | number
          }
        }
      }
      UnitMeterNumber: {
        payload: Prisma.$UnitMeterNumberPayload<ExtArgs>
        fields: Prisma.UnitMeterNumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitMeterNumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitMeterNumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>
          }
          findFirst: {
            args: Prisma.UnitMeterNumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitMeterNumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>
          }
          findMany: {
            args: Prisma.UnitMeterNumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>[]
          }
          create: {
            args: Prisma.UnitMeterNumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>
          }
          createMany: {
            args: Prisma.UnitMeterNumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitMeterNumberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>[]
          }
          delete: {
            args: Prisma.UnitMeterNumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>
          }
          update: {
            args: Prisma.UnitMeterNumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>
          }
          deleteMany: {
            args: Prisma.UnitMeterNumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitMeterNumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitMeterNumberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>[]
          }
          upsert: {
            args: Prisma.UnitMeterNumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMeterNumberPayload>
          }
          aggregate: {
            args: Prisma.UnitMeterNumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitMeterNumber>
          }
          groupBy: {
            args: Prisma.UnitMeterNumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitMeterNumberGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitMeterNumberCountArgs<ExtArgs>
            result: $Utils.Optional<UnitMeterNumberCountAggregateOutputType> | number
          }
        }
      }
      UnitFeature: {
        payload: Prisma.$UnitFeaturePayload<ExtArgs>
        fields: Prisma.UnitFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>
          }
          findFirst: {
            args: Prisma.UnitFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>
          }
          findMany: {
            args: Prisma.UnitFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>[]
          }
          create: {
            args: Prisma.UnitFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>
          }
          createMany: {
            args: Prisma.UnitFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>[]
          }
          delete: {
            args: Prisma.UnitFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>
          }
          update: {
            args: Prisma.UnitFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>
          }
          deleteMany: {
            args: Prisma.UnitFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>[]
          }
          upsert: {
            args: Prisma.UnitFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitFeaturePayload>
          }
          aggregate: {
            args: Prisma.UnitFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitFeature>
          }
          groupBy: {
            args: Prisma.UnitFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<UnitFeatureCountAggregateOutputType> | number
          }
        }
      }
      PropertyStandingCharge: {
        payload: Prisma.$PropertyStandingChargePayload<ExtArgs>
        fields: Prisma.PropertyStandingChargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyStandingChargeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyStandingChargeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>
          }
          findFirst: {
            args: Prisma.PropertyStandingChargeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyStandingChargeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>
          }
          findMany: {
            args: Prisma.PropertyStandingChargeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>[]
          }
          create: {
            args: Prisma.PropertyStandingChargeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>
          }
          createMany: {
            args: Prisma.PropertyStandingChargeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyStandingChargeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>[]
          }
          delete: {
            args: Prisma.PropertyStandingChargeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>
          }
          update: {
            args: Prisma.PropertyStandingChargeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>
          }
          deleteMany: {
            args: Prisma.PropertyStandingChargeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyStandingChargeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyStandingChargeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>[]
          }
          upsert: {
            args: Prisma.PropertyStandingChargeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStandingChargePayload>
          }
          aggregate: {
            args: Prisma.PropertyStandingChargeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyStandingCharge>
          }
          groupBy: {
            args: Prisma.PropertyStandingChargeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyStandingChargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyStandingChargeCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyStandingChargeCountAggregateOutputType> | number
          }
        }
      }
      PropertySecurityDeposit: {
        payload: Prisma.$PropertySecurityDepositPayload<ExtArgs>
        fields: Prisma.PropertySecurityDepositFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertySecurityDepositFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertySecurityDepositFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>
          }
          findFirst: {
            args: Prisma.PropertySecurityDepositFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertySecurityDepositFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>
          }
          findMany: {
            args: Prisma.PropertySecurityDepositFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>[]
          }
          create: {
            args: Prisma.PropertySecurityDepositCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>
          }
          createMany: {
            args: Prisma.PropertySecurityDepositCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertySecurityDepositCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>[]
          }
          delete: {
            args: Prisma.PropertySecurityDepositDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>
          }
          update: {
            args: Prisma.PropertySecurityDepositUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>
          }
          deleteMany: {
            args: Prisma.PropertySecurityDepositDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertySecurityDepositUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertySecurityDepositUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>[]
          }
          upsert: {
            args: Prisma.PropertySecurityDepositUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySecurityDepositPayload>
          }
          aggregate: {
            args: Prisma.PropertySecurityDepositAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertySecurityDeposit>
          }
          groupBy: {
            args: Prisma.PropertySecurityDepositGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertySecurityDepositGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertySecurityDepositCountArgs<ExtArgs>
            result: $Utils.Optional<PropertySecurityDepositCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantEmergencyContact: {
        payload: Prisma.$TenantEmergencyContactPayload<ExtArgs>
        fields: Prisma.TenantEmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantEmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantEmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.TenantEmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantEmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          findMany: {
            args: Prisma.TenantEmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>[]
          }
          create: {
            args: Prisma.TenantEmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          createMany: {
            args: Prisma.TenantEmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantEmergencyContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>[]
          }
          delete: {
            args: Prisma.TenantEmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          update: {
            args: Prisma.TenantEmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.TenantEmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantEmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantEmergencyContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>[]
          }
          upsert: {
            args: Prisma.TenantEmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.TenantEmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantEmergencyContact>
          }
          groupBy: {
            args: Prisma.TenantEmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantEmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantEmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<TenantEmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      Lease: {
        payload: Prisma.$LeasePayload<ExtArgs>
        fields: Prisma.LeaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findFirst: {
            args: Prisma.LeaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findMany: {
            args: Prisma.LeaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          create: {
            args: Prisma.LeaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          createMany: {
            args: Prisma.LeaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          delete: {
            args: Prisma.LeaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          update: {
            args: Prisma.LeaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          deleteMany: {
            args: Prisma.LeaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          upsert: {
            args: Prisma.LeaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          aggregate: {
            args: Prisma.LeaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLease>
          }
          groupBy: {
            args: Prisma.LeaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaseCountArgs<ExtArgs>
            result: $Utils.Optional<LeaseCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    property?: PropertyOmit
    landlord?: LandlordOmit
    propertyCategory?: PropertyCategoryOmit
    propertyType?: PropertyTypeOmit
    unit?: UnitOmit
    unitType?: UnitTypeOmit
    unitServiceCharge?: UnitServiceChargeOmit
    unitMeterNumber?: UnitMeterNumberOmit
    unitFeature?: UnitFeatureOmit
    propertyStandingCharge?: PropertyStandingChargeOmit
    propertySecurityDeposit?: PropertySecurityDepositOmit
    tenant?: TenantOmit
    tenantEmergencyContact?: TenantEmergencyContactOmit
    lease?: LeaseOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    payment?: PaymentOmit
    user?: UserOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    units: number
    standingCharges: number
    securityDeposits: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | PropertyCountOutputTypeCountUnitsArgs
    standingCharges?: boolean | PropertyCountOutputTypeCountStandingChargesArgs
    securityDeposits?: boolean | PropertyCountOutputTypeCountSecurityDepositsArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountStandingChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStandingChargeWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountSecurityDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySecurityDepositWhereInput
  }


  /**
   * Count Type LandlordCountOutputType
   */

  export type LandlordCountOutputType = {
    properties: number
  }

  export type LandlordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | LandlordCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * LandlordCountOutputType without action
   */
  export type LandlordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandlordCountOutputType
     */
    select?: LandlordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LandlordCountOutputType without action
   */
  export type LandlordCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type PropertyCategoryCountOutputType
   */

  export type PropertyCategoryCountOutputType = {
    properties: number
  }

  export type PropertyCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyCategoryCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * PropertyCategoryCountOutputType without action
   */
  export type PropertyCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryCountOutputType
     */
    select?: PropertyCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCategoryCountOutputType without action
   */
  export type PropertyCategoryCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type PropertyTypeCountOutputType
   */

  export type PropertyTypeCountOutputType = {
    properties: number
  }

  export type PropertyTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyTypeCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * PropertyTypeCountOutputType without action
   */
  export type PropertyTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeCountOutputType
     */
    select?: PropertyTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyTypeCountOutputType without action
   */
  export type PropertyTypeCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    leases: number
    serviceCharges: number
    meterNumbers: number
    features: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leases?: boolean | UnitCountOutputTypeCountLeasesArgs
    serviceCharges?: boolean | UnitCountOutputTypeCountServiceChargesArgs
    meterNumbers?: boolean | UnitCountOutputTypeCountMeterNumbersArgs
    features?: boolean | UnitCountOutputTypeCountFeaturesArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountLeasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountServiceChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitServiceChargeWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountMeterNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitMeterNumberWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitFeatureWhereInput
  }


  /**
   * Count Type UnitTypeCountOutputType
   */

  export type UnitTypeCountOutputType = {
    units: number
  }

  export type UnitTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | UnitTypeCountOutputTypeCountUnitsArgs
  }

  // Custom InputTypes
  /**
   * UnitTypeCountOutputType without action
   */
  export type UnitTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCountOutputType
     */
    select?: UnitTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitTypeCountOutputType without action
   */
  export type UnitTypeCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    leases: number
    emergencyContacts: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leases?: boolean | TenantCountOutputTypeCountLeasesArgs
    emergencyContacts?: boolean | TenantCountOutputTypeCountEmergencyContactsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantEmergencyContactWhereInput
  }


  /**
   * Count Type LeaseCountOutputType
   */

  export type LeaseCountOutputType = {
    invoices: number
    payments: number
  }

  export type LeaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | LeaseCountOutputTypeCountInvoicesArgs
    payments?: boolean | LeaseCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseCountOutputType
     */
    select?: LeaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    invoiceItems: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | InvoiceCountOutputTypeCountInvoiceItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    numberOfFloors: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    tenantReceiptAccountCodeCounter: number | null
    penaltyDay: number | null
  }

  export type PropertySumAggregateOutputType = {
    numberOfFloors: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    tenantReceiptAccountCodeCounter: number | null
    penaltyDay: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    dateAcquired: Date | null
    lrNumber: string | null
    country: string | null
    estateArea: string | null
    areaRegion: string | null
    roadStreet: string | null
    specification: string | null
    multiStoryType: string | null
    numberOfFloors: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    notes: string | null
    specificContactInfo: string | null
    landlordId: string | null
    categoryId: string | null
    propertyTypeId: string | null
    accountLedgerType: string | null
    primaryBankAccount: string | null
    alternativeTaxPin: string | null
    propertyWorkingTaxPin: string | null
    invoicePaymentInfo: string | null
    holderPaymentTerms: string | null
    mpesaPropertyPayNumber: string | null
    disableMpesaStkPush: boolean | null
    disableMpesaStkNarration: boolean | null
    tenantReceiptAccountCodeCounter: number | null
    lpgExempted: boolean | null
    penaltyChargeMode: string | null
    penaltyDay: number | null
    landlordDrawerBank: string | null
    landlordBankBranch: string | null
    landlordAccountName: string | null
    landlordAccountNumber: string | null
    exemptAllSms: boolean | null
    exemptInvoiceSms: boolean | null
    exemptGeneralSms: boolean | null
    exemptHagueSms: boolean | null
    exemptBalanceSms: boolean | null
    exemptAllEmail: boolean | null
    exemptInvoiceEmail: boolean | null
    exemptGeneralEmail: boolean | null
    exemptReceiptEmail: boolean | null
    exemptBalanceEmail: boolean | null
    excludeInTwoSummaryReport: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    dateAcquired: Date | null
    lrNumber: string | null
    country: string | null
    estateArea: string | null
    areaRegion: string | null
    roadStreet: string | null
    specification: string | null
    multiStoryType: string | null
    numberOfFloors: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    notes: string | null
    specificContactInfo: string | null
    landlordId: string | null
    categoryId: string | null
    propertyTypeId: string | null
    accountLedgerType: string | null
    primaryBankAccount: string | null
    alternativeTaxPin: string | null
    propertyWorkingTaxPin: string | null
    invoicePaymentInfo: string | null
    holderPaymentTerms: string | null
    mpesaPropertyPayNumber: string | null
    disableMpesaStkPush: boolean | null
    disableMpesaStkNarration: boolean | null
    tenantReceiptAccountCodeCounter: number | null
    lpgExempted: boolean | null
    penaltyChargeMode: string | null
    penaltyDay: number | null
    landlordDrawerBank: string | null
    landlordBankBranch: string | null
    landlordAccountName: string | null
    landlordAccountNumber: string | null
    exemptAllSms: boolean | null
    exemptInvoiceSms: boolean | null
    exemptGeneralSms: boolean | null
    exemptHagueSms: boolean | null
    exemptBalanceSms: boolean | null
    exemptAllEmail: boolean | null
    exemptInvoiceEmail: boolean | null
    exemptGeneralEmail: boolean | null
    exemptReceiptEmail: boolean | null
    exemptBalanceEmail: boolean | null
    excludeInTwoSummaryReport: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    code: number
    name: number
    dateAcquired: number
    lrNumber: number
    country: number
    estateArea: number
    areaRegion: number
    roadStreet: number
    specification: number
    multiStoryType: number
    numberOfFloors: number
    latitude: number
    longitude: number
    notes: number
    specificContactInfo: number
    landlordId: number
    categoryId: number
    propertyTypeId: number
    accountLedgerType: number
    primaryBankAccount: number
    alternativeTaxPin: number
    propertyWorkingTaxPin: number
    invoicePaymentInfo: number
    holderPaymentTerms: number
    mpesaPropertyPayNumber: number
    disableMpesaStkPush: number
    disableMpesaStkNarration: number
    tenantReceiptAccountCodeCounter: number
    lpgExempted: number
    penaltyChargeMode: number
    penaltyDay: number
    landlordDrawerBank: number
    landlordBankBranch: number
    landlordAccountName: number
    landlordAccountNumber: number
    exemptAllSms: number
    exemptInvoiceSms: number
    exemptGeneralSms: number
    exemptHagueSms: number
    exemptBalanceSms: number
    exemptAllEmail: number
    exemptInvoiceEmail: number
    exemptGeneralEmail: number
    exemptReceiptEmail: number
    exemptBalanceEmail: number
    excludeInTwoSummaryReport: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    numberOfFloors?: true
    latitude?: true
    longitude?: true
    tenantReceiptAccountCodeCounter?: true
    penaltyDay?: true
  }

  export type PropertySumAggregateInputType = {
    numberOfFloors?: true
    latitude?: true
    longitude?: true
    tenantReceiptAccountCodeCounter?: true
    penaltyDay?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    dateAcquired?: true
    lrNumber?: true
    country?: true
    estateArea?: true
    areaRegion?: true
    roadStreet?: true
    specification?: true
    multiStoryType?: true
    numberOfFloors?: true
    latitude?: true
    longitude?: true
    notes?: true
    specificContactInfo?: true
    landlordId?: true
    categoryId?: true
    propertyTypeId?: true
    accountLedgerType?: true
    primaryBankAccount?: true
    alternativeTaxPin?: true
    propertyWorkingTaxPin?: true
    invoicePaymentInfo?: true
    holderPaymentTerms?: true
    mpesaPropertyPayNumber?: true
    disableMpesaStkPush?: true
    disableMpesaStkNarration?: true
    tenantReceiptAccountCodeCounter?: true
    lpgExempted?: true
    penaltyChargeMode?: true
    penaltyDay?: true
    landlordDrawerBank?: true
    landlordBankBranch?: true
    landlordAccountName?: true
    landlordAccountNumber?: true
    exemptAllSms?: true
    exemptInvoiceSms?: true
    exemptGeneralSms?: true
    exemptHagueSms?: true
    exemptBalanceSms?: true
    exemptAllEmail?: true
    exemptInvoiceEmail?: true
    exemptGeneralEmail?: true
    exemptReceiptEmail?: true
    exemptBalanceEmail?: true
    excludeInTwoSummaryReport?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    dateAcquired?: true
    lrNumber?: true
    country?: true
    estateArea?: true
    areaRegion?: true
    roadStreet?: true
    specification?: true
    multiStoryType?: true
    numberOfFloors?: true
    latitude?: true
    longitude?: true
    notes?: true
    specificContactInfo?: true
    landlordId?: true
    categoryId?: true
    propertyTypeId?: true
    accountLedgerType?: true
    primaryBankAccount?: true
    alternativeTaxPin?: true
    propertyWorkingTaxPin?: true
    invoicePaymentInfo?: true
    holderPaymentTerms?: true
    mpesaPropertyPayNumber?: true
    disableMpesaStkPush?: true
    disableMpesaStkNarration?: true
    tenantReceiptAccountCodeCounter?: true
    lpgExempted?: true
    penaltyChargeMode?: true
    penaltyDay?: true
    landlordDrawerBank?: true
    landlordBankBranch?: true
    landlordAccountName?: true
    landlordAccountNumber?: true
    exemptAllSms?: true
    exemptInvoiceSms?: true
    exemptGeneralSms?: true
    exemptHagueSms?: true
    exemptBalanceSms?: true
    exemptAllEmail?: true
    exemptInvoiceEmail?: true
    exemptGeneralEmail?: true
    exemptReceiptEmail?: true
    exemptBalanceEmail?: true
    excludeInTwoSummaryReport?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    dateAcquired?: true
    lrNumber?: true
    country?: true
    estateArea?: true
    areaRegion?: true
    roadStreet?: true
    specification?: true
    multiStoryType?: true
    numberOfFloors?: true
    latitude?: true
    longitude?: true
    notes?: true
    specificContactInfo?: true
    landlordId?: true
    categoryId?: true
    propertyTypeId?: true
    accountLedgerType?: true
    primaryBankAccount?: true
    alternativeTaxPin?: true
    propertyWorkingTaxPin?: true
    invoicePaymentInfo?: true
    holderPaymentTerms?: true
    mpesaPropertyPayNumber?: true
    disableMpesaStkPush?: true
    disableMpesaStkNarration?: true
    tenantReceiptAccountCodeCounter?: true
    lpgExempted?: true
    penaltyChargeMode?: true
    penaltyDay?: true
    landlordDrawerBank?: true
    landlordBankBranch?: true
    landlordAccountName?: true
    landlordAccountNumber?: true
    exemptAllSms?: true
    exemptInvoiceSms?: true
    exemptGeneralSms?: true
    exemptHagueSms?: true
    exemptBalanceSms?: true
    exemptAllEmail?: true
    exemptInvoiceEmail?: true
    exemptGeneralEmail?: true
    exemptReceiptEmail?: true
    exemptBalanceEmail?: true
    excludeInTwoSummaryReport?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    code: string
    name: string
    dateAcquired: Date | null
    lrNumber: string | null
    country: string | null
    estateArea: string | null
    areaRegion: string | null
    roadStreet: string | null
    specification: string | null
    multiStoryType: string | null
    numberOfFloors: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    notes: string | null
    specificContactInfo: string | null
    landlordId: string | null
    categoryId: string | null
    propertyTypeId: string | null
    accountLedgerType: string | null
    primaryBankAccount: string | null
    alternativeTaxPin: string | null
    propertyWorkingTaxPin: string | null
    invoicePaymentInfo: string | null
    holderPaymentTerms: string | null
    mpesaPropertyPayNumber: string | null
    disableMpesaStkPush: boolean
    disableMpesaStkNarration: boolean
    tenantReceiptAccountCodeCounter: number | null
    lpgExempted: boolean
    penaltyChargeMode: string | null
    penaltyDay: number | null
    landlordDrawerBank: string | null
    landlordBankBranch: string | null
    landlordAccountName: string | null
    landlordAccountNumber: string | null
    exemptAllSms: boolean
    exemptInvoiceSms: boolean
    exemptGeneralSms: boolean
    exemptHagueSms: boolean
    exemptBalanceSms: boolean
    exemptAllEmail: boolean
    exemptInvoiceEmail: boolean
    exemptGeneralEmail: boolean
    exemptReceiptEmail: boolean
    exemptBalanceEmail: boolean
    excludeInTwoSummaryReport: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    dateAcquired?: boolean
    lrNumber?: boolean
    country?: boolean
    estateArea?: boolean
    areaRegion?: boolean
    roadStreet?: boolean
    specification?: boolean
    multiStoryType?: boolean
    numberOfFloors?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    specificContactInfo?: boolean
    landlordId?: boolean
    categoryId?: boolean
    propertyTypeId?: boolean
    accountLedgerType?: boolean
    primaryBankAccount?: boolean
    alternativeTaxPin?: boolean
    propertyWorkingTaxPin?: boolean
    invoicePaymentInfo?: boolean
    holderPaymentTerms?: boolean
    mpesaPropertyPayNumber?: boolean
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: boolean
    lpgExempted?: boolean
    penaltyChargeMode?: boolean
    penaltyDay?: boolean
    landlordDrawerBank?: boolean
    landlordBankBranch?: boolean
    landlordAccountName?: boolean
    landlordAccountNumber?: boolean
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    landlord?: boolean | Property$landlordArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    units?: boolean | Property$unitsArgs<ExtArgs>
    standingCharges?: boolean | Property$standingChargesArgs<ExtArgs>
    securityDeposits?: boolean | Property$securityDepositsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    dateAcquired?: boolean
    lrNumber?: boolean
    country?: boolean
    estateArea?: boolean
    areaRegion?: boolean
    roadStreet?: boolean
    specification?: boolean
    multiStoryType?: boolean
    numberOfFloors?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    specificContactInfo?: boolean
    landlordId?: boolean
    categoryId?: boolean
    propertyTypeId?: boolean
    accountLedgerType?: boolean
    primaryBankAccount?: boolean
    alternativeTaxPin?: boolean
    propertyWorkingTaxPin?: boolean
    invoicePaymentInfo?: boolean
    holderPaymentTerms?: boolean
    mpesaPropertyPayNumber?: boolean
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: boolean
    lpgExempted?: boolean
    penaltyChargeMode?: boolean
    penaltyDay?: boolean
    landlordDrawerBank?: boolean
    landlordBankBranch?: boolean
    landlordAccountName?: boolean
    landlordAccountNumber?: boolean
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    landlord?: boolean | Property$landlordArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    dateAcquired?: boolean
    lrNumber?: boolean
    country?: boolean
    estateArea?: boolean
    areaRegion?: boolean
    roadStreet?: boolean
    specification?: boolean
    multiStoryType?: boolean
    numberOfFloors?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    specificContactInfo?: boolean
    landlordId?: boolean
    categoryId?: boolean
    propertyTypeId?: boolean
    accountLedgerType?: boolean
    primaryBankAccount?: boolean
    alternativeTaxPin?: boolean
    propertyWorkingTaxPin?: boolean
    invoicePaymentInfo?: boolean
    holderPaymentTerms?: boolean
    mpesaPropertyPayNumber?: boolean
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: boolean
    lpgExempted?: boolean
    penaltyChargeMode?: boolean
    penaltyDay?: boolean
    landlordDrawerBank?: boolean
    landlordBankBranch?: boolean
    landlordAccountName?: boolean
    landlordAccountNumber?: boolean
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    landlord?: boolean | Property$landlordArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    dateAcquired?: boolean
    lrNumber?: boolean
    country?: boolean
    estateArea?: boolean
    areaRegion?: boolean
    roadStreet?: boolean
    specification?: boolean
    multiStoryType?: boolean
    numberOfFloors?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    specificContactInfo?: boolean
    landlordId?: boolean
    categoryId?: boolean
    propertyTypeId?: boolean
    accountLedgerType?: boolean
    primaryBankAccount?: boolean
    alternativeTaxPin?: boolean
    propertyWorkingTaxPin?: boolean
    invoicePaymentInfo?: boolean
    holderPaymentTerms?: boolean
    mpesaPropertyPayNumber?: boolean
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: boolean
    lpgExempted?: boolean
    penaltyChargeMode?: boolean
    penaltyDay?: boolean
    landlordDrawerBank?: boolean
    landlordBankBranch?: boolean
    landlordAccountName?: boolean
    landlordAccountNumber?: boolean
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "dateAcquired" | "lrNumber" | "country" | "estateArea" | "areaRegion" | "roadStreet" | "specification" | "multiStoryType" | "numberOfFloors" | "latitude" | "longitude" | "notes" | "specificContactInfo" | "landlordId" | "categoryId" | "propertyTypeId" | "accountLedgerType" | "primaryBankAccount" | "alternativeTaxPin" | "propertyWorkingTaxPin" | "invoicePaymentInfo" | "holderPaymentTerms" | "mpesaPropertyPayNumber" | "disableMpesaStkPush" | "disableMpesaStkNarration" | "tenantReceiptAccountCodeCounter" | "lpgExempted" | "penaltyChargeMode" | "penaltyDay" | "landlordDrawerBank" | "landlordBankBranch" | "landlordAccountName" | "landlordAccountNumber" | "exemptAllSms" | "exemptInvoiceSms" | "exemptGeneralSms" | "exemptHagueSms" | "exemptBalanceSms" | "exemptAllEmail" | "exemptInvoiceEmail" | "exemptGeneralEmail" | "exemptReceiptEmail" | "exemptBalanceEmail" | "excludeInTwoSummaryReport" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | Property$landlordArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    units?: boolean | Property$unitsArgs<ExtArgs>
    standingCharges?: boolean | Property$standingChargesArgs<ExtArgs>
    securityDeposits?: boolean | Property$securityDepositsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | Property$landlordArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | Property$landlordArgs<ExtArgs>
    category?: boolean | Property$categoryArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      landlord: Prisma.$LandlordPayload<ExtArgs> | null
      category: Prisma.$PropertyCategoryPayload<ExtArgs> | null
      propertyType: Prisma.$PropertyTypePayload<ExtArgs> | null
      units: Prisma.$UnitPayload<ExtArgs>[]
      standingCharges: Prisma.$PropertyStandingChargePayload<ExtArgs>[]
      securityDeposits: Prisma.$PropertySecurityDepositPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      dateAcquired: Date | null
      lrNumber: string | null
      country: string | null
      estateArea: string | null
      areaRegion: string | null
      roadStreet: string | null
      specification: string | null
      multiStoryType: string | null
      numberOfFloors: number | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      notes: string | null
      specificContactInfo: string | null
      landlordId: string | null
      categoryId: string | null
      propertyTypeId: string | null
      accountLedgerType: string | null
      primaryBankAccount: string | null
      alternativeTaxPin: string | null
      propertyWorkingTaxPin: string | null
      invoicePaymentInfo: string | null
      holderPaymentTerms: string | null
      mpesaPropertyPayNumber: string | null
      disableMpesaStkPush: boolean
      disableMpesaStkNarration: boolean
      tenantReceiptAccountCodeCounter: number | null
      lpgExempted: boolean
      penaltyChargeMode: string | null
      penaltyDay: number | null
      landlordDrawerBank: string | null
      landlordBankBranch: string | null
      landlordAccountName: string | null
      landlordAccountNumber: string | null
      exemptAllSms: boolean
      exemptInvoiceSms: boolean
      exemptGeneralSms: boolean
      exemptHagueSms: boolean
      exemptBalanceSms: boolean
      exemptAllEmail: boolean
      exemptInvoiceEmail: boolean
      exemptGeneralEmail: boolean
      exemptReceiptEmail: boolean
      exemptBalanceEmail: boolean
      excludeInTwoSummaryReport: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landlord<T extends Property$landlordArgs<ExtArgs> = {}>(args?: Subset<T, Property$landlordArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Property$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Property$categoryArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    propertyType<T extends Property$propertyTypeArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyTypeArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    units<T extends Property$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Property$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standingCharges<T extends Property$standingChargesArgs<ExtArgs> = {}>(args?: Subset<T, Property$standingChargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityDeposits<T extends Property$securityDepositsArgs<ExtArgs> = {}>(args?: Subset<T, Property$securityDepositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly code: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'String'>
    readonly dateAcquired: FieldRef<"Property", 'DateTime'>
    readonly lrNumber: FieldRef<"Property", 'String'>
    readonly country: FieldRef<"Property", 'String'>
    readonly estateArea: FieldRef<"Property", 'String'>
    readonly areaRegion: FieldRef<"Property", 'String'>
    readonly roadStreet: FieldRef<"Property", 'String'>
    readonly specification: FieldRef<"Property", 'String'>
    readonly multiStoryType: FieldRef<"Property", 'String'>
    readonly numberOfFloors: FieldRef<"Property", 'Int'>
    readonly latitude: FieldRef<"Property", 'Decimal'>
    readonly longitude: FieldRef<"Property", 'Decimal'>
    readonly notes: FieldRef<"Property", 'String'>
    readonly specificContactInfo: FieldRef<"Property", 'String'>
    readonly landlordId: FieldRef<"Property", 'String'>
    readonly categoryId: FieldRef<"Property", 'String'>
    readonly propertyTypeId: FieldRef<"Property", 'String'>
    readonly accountLedgerType: FieldRef<"Property", 'String'>
    readonly primaryBankAccount: FieldRef<"Property", 'String'>
    readonly alternativeTaxPin: FieldRef<"Property", 'String'>
    readonly propertyWorkingTaxPin: FieldRef<"Property", 'String'>
    readonly invoicePaymentInfo: FieldRef<"Property", 'String'>
    readonly holderPaymentTerms: FieldRef<"Property", 'String'>
    readonly mpesaPropertyPayNumber: FieldRef<"Property", 'String'>
    readonly disableMpesaStkPush: FieldRef<"Property", 'Boolean'>
    readonly disableMpesaStkNarration: FieldRef<"Property", 'Boolean'>
    readonly tenantReceiptAccountCodeCounter: FieldRef<"Property", 'Int'>
    readonly lpgExempted: FieldRef<"Property", 'Boolean'>
    readonly penaltyChargeMode: FieldRef<"Property", 'String'>
    readonly penaltyDay: FieldRef<"Property", 'Int'>
    readonly landlordDrawerBank: FieldRef<"Property", 'String'>
    readonly landlordBankBranch: FieldRef<"Property", 'String'>
    readonly landlordAccountName: FieldRef<"Property", 'String'>
    readonly landlordAccountNumber: FieldRef<"Property", 'String'>
    readonly exemptAllSms: FieldRef<"Property", 'Boolean'>
    readonly exemptInvoiceSms: FieldRef<"Property", 'Boolean'>
    readonly exemptGeneralSms: FieldRef<"Property", 'Boolean'>
    readonly exemptHagueSms: FieldRef<"Property", 'Boolean'>
    readonly exemptBalanceSms: FieldRef<"Property", 'Boolean'>
    readonly exemptAllEmail: FieldRef<"Property", 'Boolean'>
    readonly exemptInvoiceEmail: FieldRef<"Property", 'Boolean'>
    readonly exemptGeneralEmail: FieldRef<"Property", 'Boolean'>
    readonly exemptReceiptEmail: FieldRef<"Property", 'Boolean'>
    readonly exemptBalanceEmail: FieldRef<"Property", 'Boolean'>
    readonly excludeInTwoSummaryReport: FieldRef<"Property", 'Boolean'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly deletedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.landlord
   */
  export type Property$landlordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    where?: LandlordWhereInput
  }

  /**
   * Property.category
   */
  export type Property$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    where?: PropertyCategoryWhereInput
  }

  /**
   * Property.propertyType
   */
  export type Property$propertyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    where?: PropertyTypeWhereInput
  }

  /**
   * Property.units
   */
  export type Property$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Property.standingCharges
   */
  export type Property$standingChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    where?: PropertyStandingChargeWhereInput
    orderBy?: PropertyStandingChargeOrderByWithRelationInput | PropertyStandingChargeOrderByWithRelationInput[]
    cursor?: PropertyStandingChargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyStandingChargeScalarFieldEnum | PropertyStandingChargeScalarFieldEnum[]
  }

  /**
   * Property.securityDeposits
   */
  export type Property$securityDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    where?: PropertySecurityDepositWhereInput
    orderBy?: PropertySecurityDepositOrderByWithRelationInput | PropertySecurityDepositOrderByWithRelationInput[]
    cursor?: PropertySecurityDepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertySecurityDepositScalarFieldEnum | PropertySecurityDepositScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Landlord
   */

  export type AggregateLandlord = {
    _count: LandlordCountAggregateOutputType | null
    _min: LandlordMinAggregateOutputType | null
    _max: LandlordMaxAggregateOutputType | null
  }

  export type LandlordMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    email: string | null
    phone: string | null
    alternativePhone: string | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    bankName: string | null
    bankBranch: string | null
    accountName: string | null
    accountNumber: string | null
    taxPin: string | null
    vatRegistered: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LandlordMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    email: string | null
    phone: string | null
    alternativePhone: string | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    bankName: string | null
    bankBranch: string | null
    accountName: string | null
    accountNumber: string | null
    taxPin: string | null
    vatRegistered: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LandlordCountAggregateOutputType = {
    id: number
    code: number
    name: number
    email: number
    phone: number
    alternativePhone: number
    address: number
    city: number
    country: number
    postalCode: number
    bankName: number
    bankBranch: number
    accountName: number
    accountNumber: number
    taxPin: number
    vatRegistered: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LandlordMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    email?: true
    phone?: true
    alternativePhone?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    bankName?: true
    bankBranch?: true
    accountName?: true
    accountNumber?: true
    taxPin?: true
    vatRegistered?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LandlordMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    email?: true
    phone?: true
    alternativePhone?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    bankName?: true
    bankBranch?: true
    accountName?: true
    accountNumber?: true
    taxPin?: true
    vatRegistered?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LandlordCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    email?: true
    phone?: true
    alternativePhone?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    bankName?: true
    bankBranch?: true
    accountName?: true
    accountNumber?: true
    taxPin?: true
    vatRegistered?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LandlordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Landlord to aggregate.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Landlords
    **/
    _count?: true | LandlordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandlordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandlordMaxAggregateInputType
  }

  export type GetLandlordAggregateType<T extends LandlordAggregateArgs> = {
        [P in keyof T & keyof AggregateLandlord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandlord[P]>
      : GetScalarType<T[P], AggregateLandlord[P]>
  }




  export type LandlordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandlordWhereInput
    orderBy?: LandlordOrderByWithAggregationInput | LandlordOrderByWithAggregationInput[]
    by: LandlordScalarFieldEnum[] | LandlordScalarFieldEnum
    having?: LandlordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandlordCountAggregateInputType | true
    _min?: LandlordMinAggregateInputType
    _max?: LandlordMaxAggregateInputType
  }

  export type LandlordGroupByOutputType = {
    id: string
    code: string
    name: string
    email: string | null
    phone: string | null
    alternativePhone: string | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    bankName: string | null
    bankBranch: string | null
    accountName: string | null
    accountNumber: string | null
    taxPin: string | null
    vatRegistered: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: LandlordCountAggregateOutputType | null
    _min: LandlordMinAggregateOutputType | null
    _max: LandlordMaxAggregateOutputType | null
  }

  type GetLandlordGroupByPayload<T extends LandlordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandlordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandlordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandlordGroupByOutputType[P]>
            : GetScalarType<T[P], LandlordGroupByOutputType[P]>
        }
      >
    >


  export type LandlordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    alternativePhone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    bankName?: boolean
    bankBranch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    taxPin?: boolean
    vatRegistered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    properties?: boolean | Landlord$propertiesArgs<ExtArgs>
    _count?: boolean | LandlordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landlord"]>

  export type LandlordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    alternativePhone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    bankName?: boolean
    bankBranch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    taxPin?: boolean
    vatRegistered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["landlord"]>

  export type LandlordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    alternativePhone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    bankName?: boolean
    bankBranch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    taxPin?: boolean
    vatRegistered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["landlord"]>

  export type LandlordSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    alternativePhone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    bankName?: boolean
    bankBranch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    taxPin?: boolean
    vatRegistered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LandlordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "email" | "phone" | "alternativePhone" | "address" | "city" | "country" | "postalCode" | "bankName" | "bankBranch" | "accountName" | "accountNumber" | "taxPin" | "vatRegistered" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["landlord"]>
  export type LandlordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | Landlord$propertiesArgs<ExtArgs>
    _count?: boolean | LandlordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LandlordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LandlordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LandlordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Landlord"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      email: string | null
      phone: string | null
      alternativePhone: string | null
      address: string | null
      city: string | null
      country: string | null
      postalCode: string | null
      bankName: string | null
      bankBranch: string | null
      accountName: string | null
      accountNumber: string | null
      taxPin: string | null
      vatRegistered: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["landlord"]>
    composites: {}
  }

  type LandlordGetPayload<S extends boolean | null | undefined | LandlordDefaultArgs> = $Result.GetResult<Prisma.$LandlordPayload, S>

  type LandlordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandlordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandlordCountAggregateInputType | true
    }

  export interface LandlordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Landlord'], meta: { name: 'Landlord' } }
    /**
     * Find zero or one Landlord that matches the filter.
     * @param {LandlordFindUniqueArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandlordFindUniqueArgs>(args: SelectSubset<T, LandlordFindUniqueArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Landlord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandlordFindUniqueOrThrowArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandlordFindUniqueOrThrowArgs>(args: SelectSubset<T, LandlordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landlord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordFindFirstArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandlordFindFirstArgs>(args?: SelectSubset<T, LandlordFindFirstArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landlord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordFindFirstOrThrowArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandlordFindFirstOrThrowArgs>(args?: SelectSubset<T, LandlordFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Landlords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Landlords
     * const landlords = await prisma.landlord.findMany()
     * 
     * // Get first 10 Landlords
     * const landlords = await prisma.landlord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landlordWithIdOnly = await prisma.landlord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LandlordFindManyArgs>(args?: SelectSubset<T, LandlordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Landlord.
     * @param {LandlordCreateArgs} args - Arguments to create a Landlord.
     * @example
     * // Create one Landlord
     * const Landlord = await prisma.landlord.create({
     *   data: {
     *     // ... data to create a Landlord
     *   }
     * })
     * 
     */
    create<T extends LandlordCreateArgs>(args: SelectSubset<T, LandlordCreateArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Landlords.
     * @param {LandlordCreateManyArgs} args - Arguments to create many Landlords.
     * @example
     * // Create many Landlords
     * const landlord = await prisma.landlord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandlordCreateManyArgs>(args?: SelectSubset<T, LandlordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Landlords and returns the data saved in the database.
     * @param {LandlordCreateManyAndReturnArgs} args - Arguments to create many Landlords.
     * @example
     * // Create many Landlords
     * const landlord = await prisma.landlord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Landlords and only return the `id`
     * const landlordWithIdOnly = await prisma.landlord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LandlordCreateManyAndReturnArgs>(args?: SelectSubset<T, LandlordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Landlord.
     * @param {LandlordDeleteArgs} args - Arguments to delete one Landlord.
     * @example
     * // Delete one Landlord
     * const Landlord = await prisma.landlord.delete({
     *   where: {
     *     // ... filter to delete one Landlord
     *   }
     * })
     * 
     */
    delete<T extends LandlordDeleteArgs>(args: SelectSubset<T, LandlordDeleteArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Landlord.
     * @param {LandlordUpdateArgs} args - Arguments to update one Landlord.
     * @example
     * // Update one Landlord
     * const landlord = await prisma.landlord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandlordUpdateArgs>(args: SelectSubset<T, LandlordUpdateArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Landlords.
     * @param {LandlordDeleteManyArgs} args - Arguments to filter Landlords to delete.
     * @example
     * // Delete a few Landlords
     * const { count } = await prisma.landlord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandlordDeleteManyArgs>(args?: SelectSubset<T, LandlordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landlords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Landlords
     * const landlord = await prisma.landlord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandlordUpdateManyArgs>(args: SelectSubset<T, LandlordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landlords and returns the data updated in the database.
     * @param {LandlordUpdateManyAndReturnArgs} args - Arguments to update many Landlords.
     * @example
     * // Update many Landlords
     * const landlord = await prisma.landlord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Landlords and only return the `id`
     * const landlordWithIdOnly = await prisma.landlord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LandlordUpdateManyAndReturnArgs>(args: SelectSubset<T, LandlordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Landlord.
     * @param {LandlordUpsertArgs} args - Arguments to update or create a Landlord.
     * @example
     * // Update or create a Landlord
     * const landlord = await prisma.landlord.upsert({
     *   create: {
     *     // ... data to create a Landlord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Landlord we want to update
     *   }
     * })
     */
    upsert<T extends LandlordUpsertArgs>(args: SelectSubset<T, LandlordUpsertArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Landlords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordCountArgs} args - Arguments to filter Landlords to count.
     * @example
     * // Count the number of Landlords
     * const count = await prisma.landlord.count({
     *   where: {
     *     // ... the filter for the Landlords we want to count
     *   }
     * })
    **/
    count<T extends LandlordCountArgs>(
      args?: Subset<T, LandlordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandlordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Landlord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandlordAggregateArgs>(args: Subset<T, LandlordAggregateArgs>): Prisma.PrismaPromise<GetLandlordAggregateType<T>>

    /**
     * Group by Landlord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandlordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandlordGroupByArgs['orderBy'] }
        : { orderBy?: LandlordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandlordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandlordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Landlord model
   */
  readonly fields: LandlordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Landlord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandlordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends Landlord$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Landlord$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Landlord model
   */
  interface LandlordFieldRefs {
    readonly id: FieldRef<"Landlord", 'String'>
    readonly code: FieldRef<"Landlord", 'String'>
    readonly name: FieldRef<"Landlord", 'String'>
    readonly email: FieldRef<"Landlord", 'String'>
    readonly phone: FieldRef<"Landlord", 'String'>
    readonly alternativePhone: FieldRef<"Landlord", 'String'>
    readonly address: FieldRef<"Landlord", 'String'>
    readonly city: FieldRef<"Landlord", 'String'>
    readonly country: FieldRef<"Landlord", 'String'>
    readonly postalCode: FieldRef<"Landlord", 'String'>
    readonly bankName: FieldRef<"Landlord", 'String'>
    readonly bankBranch: FieldRef<"Landlord", 'String'>
    readonly accountName: FieldRef<"Landlord", 'String'>
    readonly accountNumber: FieldRef<"Landlord", 'String'>
    readonly taxPin: FieldRef<"Landlord", 'String'>
    readonly vatRegistered: FieldRef<"Landlord", 'Boolean'>
    readonly createdAt: FieldRef<"Landlord", 'DateTime'>
    readonly updatedAt: FieldRef<"Landlord", 'DateTime'>
    readonly deletedAt: FieldRef<"Landlord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Landlord findUnique
   */
  export type LandlordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord findUniqueOrThrow
   */
  export type LandlordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord findFirst
   */
  export type LandlordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Landlords.
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Landlords.
     */
    distinct?: LandlordScalarFieldEnum | LandlordScalarFieldEnum[]
  }

  /**
   * Landlord findFirstOrThrow
   */
  export type LandlordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Landlords.
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Landlords.
     */
    distinct?: LandlordScalarFieldEnum | LandlordScalarFieldEnum[]
  }

  /**
   * Landlord findMany
   */
  export type LandlordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlords to fetch.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Landlords.
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    distinct?: LandlordScalarFieldEnum | LandlordScalarFieldEnum[]
  }

  /**
   * Landlord create
   */
  export type LandlordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * The data needed to create a Landlord.
     */
    data: XOR<LandlordCreateInput, LandlordUncheckedCreateInput>
  }

  /**
   * Landlord createMany
   */
  export type LandlordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Landlords.
     */
    data: LandlordCreateManyInput | LandlordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Landlord createManyAndReturn
   */
  export type LandlordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * The data used to create many Landlords.
     */
    data: LandlordCreateManyInput | LandlordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Landlord update
   */
  export type LandlordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * The data needed to update a Landlord.
     */
    data: XOR<LandlordUpdateInput, LandlordUncheckedUpdateInput>
    /**
     * Choose, which Landlord to update.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord updateMany
   */
  export type LandlordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Landlords.
     */
    data: XOR<LandlordUpdateManyMutationInput, LandlordUncheckedUpdateManyInput>
    /**
     * Filter which Landlords to update
     */
    where?: LandlordWhereInput
    /**
     * Limit how many Landlords to update.
     */
    limit?: number
  }

  /**
   * Landlord updateManyAndReturn
   */
  export type LandlordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * The data used to update Landlords.
     */
    data: XOR<LandlordUpdateManyMutationInput, LandlordUncheckedUpdateManyInput>
    /**
     * Filter which Landlords to update
     */
    where?: LandlordWhereInput
    /**
     * Limit how many Landlords to update.
     */
    limit?: number
  }

  /**
   * Landlord upsert
   */
  export type LandlordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * The filter to search for the Landlord to update in case it exists.
     */
    where: LandlordWhereUniqueInput
    /**
     * In case the Landlord found by the `where` argument doesn't exist, create a new Landlord with this data.
     */
    create: XOR<LandlordCreateInput, LandlordUncheckedCreateInput>
    /**
     * In case the Landlord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandlordUpdateInput, LandlordUncheckedUpdateInput>
  }

  /**
   * Landlord delete
   */
  export type LandlordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter which Landlord to delete.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord deleteMany
   */
  export type LandlordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Landlords to delete
     */
    where?: LandlordWhereInput
    /**
     * Limit how many Landlords to delete.
     */
    limit?: number
  }

  /**
   * Landlord.properties
   */
  export type Landlord$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Landlord without action
   */
  export type LandlordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
  }


  /**
   * Model PropertyCategory
   */

  export type AggregatePropertyCategory = {
    _count: PropertyCategoryCountAggregateOutputType | null
    _min: PropertyCategoryMinAggregateOutputType | null
    _max: PropertyCategoryMaxAggregateOutputType | null
  }

  export type PropertyCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyCategory to aggregate.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyCategories
    **/
    _count?: true | PropertyCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyCategoryMaxAggregateInputType
  }

  export type GetPropertyCategoryAggregateType<T extends PropertyCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyCategory[P]>
      : GetScalarType<T[P], AggregatePropertyCategory[P]>
  }




  export type PropertyCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyCategoryWhereInput
    orderBy?: PropertyCategoryOrderByWithAggregationInput | PropertyCategoryOrderByWithAggregationInput[]
    by: PropertyCategoryScalarFieldEnum[] | PropertyCategoryScalarFieldEnum
    having?: PropertyCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCategoryCountAggregateInputType | true
    _min?: PropertyCategoryMinAggregateInputType
    _max?: PropertyCategoryMaxAggregateInputType
  }

  export type PropertyCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    code: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyCategoryCountAggregateOutputType | null
    _min: PropertyCategoryMinAggregateOutputType | null
    _max: PropertyCategoryMaxAggregateOutputType | null
  }

  type GetPropertyCategoryGroupByPayload<T extends PropertyCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyCategoryGroupByOutputType[P]>
        }
      >
    >


  export type PropertyCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    properties?: boolean | PropertyCategory$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyCategory"]>

  export type PropertyCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyCategory"]>

  export type PropertyCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyCategory"]>

  export type PropertyCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "code" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyCategory"]>
  export type PropertyCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyCategory$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PropertyCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyCategory"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      code: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyCategory"]>
    composites: {}
  }

  type PropertyCategoryGetPayload<S extends boolean | null | undefined | PropertyCategoryDefaultArgs> = $Result.GetResult<Prisma.$PropertyCategoryPayload, S>

  type PropertyCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCategoryCountAggregateInputType | true
    }

  export interface PropertyCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyCategory'], meta: { name: 'PropertyCategory' } }
    /**
     * Find zero or one PropertyCategory that matches the filter.
     * @param {PropertyCategoryFindUniqueArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyCategoryFindUniqueArgs>(args: SelectSubset<T, PropertyCategoryFindUniqueArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyCategoryFindUniqueOrThrowArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryFindFirstArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyCategoryFindFirstArgs>(args?: SelectSubset<T, PropertyCategoryFindFirstArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryFindFirstOrThrowArgs} args - Arguments to find a PropertyCategory
     * @example
     * // Get one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyCategories
     * const propertyCategories = await prisma.propertyCategory.findMany()
     * 
     * // Get first 10 PropertyCategories
     * const propertyCategories = await prisma.propertyCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyCategoryWithIdOnly = await prisma.propertyCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyCategoryFindManyArgs>(args?: SelectSubset<T, PropertyCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyCategory.
     * @param {PropertyCategoryCreateArgs} args - Arguments to create a PropertyCategory.
     * @example
     * // Create one PropertyCategory
     * const PropertyCategory = await prisma.propertyCategory.create({
     *   data: {
     *     // ... data to create a PropertyCategory
     *   }
     * })
     * 
     */
    create<T extends PropertyCategoryCreateArgs>(args: SelectSubset<T, PropertyCategoryCreateArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyCategories.
     * @param {PropertyCategoryCreateManyArgs} args - Arguments to create many PropertyCategories.
     * @example
     * // Create many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCategoryCreateManyArgs>(args?: SelectSubset<T, PropertyCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyCategories and returns the data saved in the database.
     * @param {PropertyCategoryCreateManyAndReturnArgs} args - Arguments to create many PropertyCategories.
     * @example
     * // Create many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyCategories and only return the `id`
     * const propertyCategoryWithIdOnly = await prisma.propertyCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyCategory.
     * @param {PropertyCategoryDeleteArgs} args - Arguments to delete one PropertyCategory.
     * @example
     * // Delete one PropertyCategory
     * const PropertyCategory = await prisma.propertyCategory.delete({
     *   where: {
     *     // ... filter to delete one PropertyCategory
     *   }
     * })
     * 
     */
    delete<T extends PropertyCategoryDeleteArgs>(args: SelectSubset<T, PropertyCategoryDeleteArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyCategory.
     * @param {PropertyCategoryUpdateArgs} args - Arguments to update one PropertyCategory.
     * @example
     * // Update one PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyCategoryUpdateArgs>(args: SelectSubset<T, PropertyCategoryUpdateArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyCategories.
     * @param {PropertyCategoryDeleteManyArgs} args - Arguments to filter PropertyCategories to delete.
     * @example
     * // Delete a few PropertyCategories
     * const { count } = await prisma.propertyCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyCategoryDeleteManyArgs>(args?: SelectSubset<T, PropertyCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyCategoryUpdateManyArgs>(args: SelectSubset<T, PropertyCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyCategories and returns the data updated in the database.
     * @param {PropertyCategoryUpdateManyAndReturnArgs} args - Arguments to update many PropertyCategories.
     * @example
     * // Update many PropertyCategories
     * const propertyCategory = await prisma.propertyCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyCategories and only return the `id`
     * const propertyCategoryWithIdOnly = await prisma.propertyCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyCategory.
     * @param {PropertyCategoryUpsertArgs} args - Arguments to update or create a PropertyCategory.
     * @example
     * // Update or create a PropertyCategory
     * const propertyCategory = await prisma.propertyCategory.upsert({
     *   create: {
     *     // ... data to create a PropertyCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyCategory we want to update
     *   }
     * })
     */
    upsert<T extends PropertyCategoryUpsertArgs>(args: SelectSubset<T, PropertyCategoryUpsertArgs<ExtArgs>>): Prisma__PropertyCategoryClient<$Result.GetResult<Prisma.$PropertyCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryCountArgs} args - Arguments to filter PropertyCategories to count.
     * @example
     * // Count the number of PropertyCategories
     * const count = await prisma.propertyCategory.count({
     *   where: {
     *     // ... the filter for the PropertyCategories we want to count
     *   }
     * })
    **/
    count<T extends PropertyCategoryCountArgs>(
      args?: Subset<T, PropertyCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyCategoryAggregateArgs>(args: Subset<T, PropertyCategoryAggregateArgs>): Prisma.PrismaPromise<GetPropertyCategoryAggregateType<T>>

    /**
     * Group by PropertyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyCategoryGroupByArgs['orderBy'] }
        : { orderBy?: PropertyCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyCategory model
   */
  readonly fields: PropertyCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends PropertyCategory$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyCategory$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyCategory model
   */
  interface PropertyCategoryFieldRefs {
    readonly id: FieldRef<"PropertyCategory", 'String'>
    readonly name: FieldRef<"PropertyCategory", 'String'>
    readonly description: FieldRef<"PropertyCategory", 'String'>
    readonly code: FieldRef<"PropertyCategory", 'String'>
    readonly createdAt: FieldRef<"PropertyCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyCategory findUnique
   */
  export type PropertyCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where: PropertyCategoryWhereUniqueInput
  }

  /**
   * PropertyCategory findUniqueOrThrow
   */
  export type PropertyCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where: PropertyCategoryWhereUniqueInput
  }

  /**
   * PropertyCategory findFirst
   */
  export type PropertyCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyCategories.
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyCategories.
     */
    distinct?: PropertyCategoryScalarFieldEnum | PropertyCategoryScalarFieldEnum[]
  }

  /**
   * PropertyCategory findFirstOrThrow
   */
  export type PropertyCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategory to fetch.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyCategories.
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyCategories.
     */
    distinct?: PropertyCategoryScalarFieldEnum | PropertyCategoryScalarFieldEnum[]
  }

  /**
   * PropertyCategory findMany
   */
  export type PropertyCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategories to fetch.
     */
    where?: PropertyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategories to fetch.
     */
    orderBy?: PropertyCategoryOrderByWithRelationInput | PropertyCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyCategories.
     */
    cursor?: PropertyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategories.
     */
    skip?: number
    distinct?: PropertyCategoryScalarFieldEnum | PropertyCategoryScalarFieldEnum[]
  }

  /**
   * PropertyCategory create
   */
  export type PropertyCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyCategory.
     */
    data: XOR<PropertyCategoryCreateInput, PropertyCategoryUncheckedCreateInput>
  }

  /**
   * PropertyCategory createMany
   */
  export type PropertyCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyCategories.
     */
    data: PropertyCategoryCreateManyInput | PropertyCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyCategory createManyAndReturn
   */
  export type PropertyCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyCategories.
     */
    data: PropertyCategoryCreateManyInput | PropertyCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyCategory update
   */
  export type PropertyCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyCategory.
     */
    data: XOR<PropertyCategoryUpdateInput, PropertyCategoryUncheckedUpdateInput>
    /**
     * Choose, which PropertyCategory to update.
     */
    where: PropertyCategoryWhereUniqueInput
  }

  /**
   * PropertyCategory updateMany
   */
  export type PropertyCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyCategories.
     */
    data: XOR<PropertyCategoryUpdateManyMutationInput, PropertyCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyCategories to update
     */
    where?: PropertyCategoryWhereInput
    /**
     * Limit how many PropertyCategories to update.
     */
    limit?: number
  }

  /**
   * PropertyCategory updateManyAndReturn
   */
  export type PropertyCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * The data used to update PropertyCategories.
     */
    data: XOR<PropertyCategoryUpdateManyMutationInput, PropertyCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyCategories to update
     */
    where?: PropertyCategoryWhereInput
    /**
     * Limit how many PropertyCategories to update.
     */
    limit?: number
  }

  /**
   * PropertyCategory upsert
   */
  export type PropertyCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyCategory to update in case it exists.
     */
    where: PropertyCategoryWhereUniqueInput
    /**
     * In case the PropertyCategory found by the `where` argument doesn't exist, create a new PropertyCategory with this data.
     */
    create: XOR<PropertyCategoryCreateInput, PropertyCategoryUncheckedCreateInput>
    /**
     * In case the PropertyCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyCategoryUpdateInput, PropertyCategoryUncheckedUpdateInput>
  }

  /**
   * PropertyCategory delete
   */
  export type PropertyCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
    /**
     * Filter which PropertyCategory to delete.
     */
    where: PropertyCategoryWhereUniqueInput
  }

  /**
   * PropertyCategory deleteMany
   */
  export type PropertyCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyCategories to delete
     */
    where?: PropertyCategoryWhereInput
    /**
     * Limit how many PropertyCategories to delete.
     */
    limit?: number
  }

  /**
   * PropertyCategory.properties
   */
  export type PropertyCategory$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyCategory without action
   */
  export type PropertyCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategory
     */
    select?: PropertyCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategory
     */
    omit?: PropertyCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryInclude<ExtArgs> | null
  }


  /**
   * Model PropertyType
   */

  export type AggregatePropertyType = {
    _count: PropertyTypeCountAggregateOutputType | null
    _min: PropertyTypeMinAggregateOutputType | null
    _max: PropertyTypeMaxAggregateOutputType | null
  }

  export type PropertyTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyType to aggregate.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyTypes
    **/
    _count?: true | PropertyTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyTypeMaxAggregateInputType
  }

  export type GetPropertyTypeAggregateType<T extends PropertyTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyType[P]>
      : GetScalarType<T[P], AggregatePropertyType[P]>
  }




  export type PropertyTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTypeWhereInput
    orderBy?: PropertyTypeOrderByWithAggregationInput | PropertyTypeOrderByWithAggregationInput[]
    by: PropertyTypeScalarFieldEnum[] | PropertyTypeScalarFieldEnum
    having?: PropertyTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyTypeCountAggregateInputType | true
    _min?: PropertyTypeMinAggregateInputType
    _max?: PropertyTypeMaxAggregateInputType
  }

  export type PropertyTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    code: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyTypeCountAggregateOutputType | null
    _min: PropertyTypeMinAggregateOutputType | null
    _max: PropertyTypeMaxAggregateOutputType | null
  }

  type GetPropertyTypeGroupByPayload<T extends PropertyTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyTypeGroupByOutputType[P]>
        }
      >
    >


  export type PropertyTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    properties?: boolean | PropertyType$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyType"]>

  export type PropertyTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyType"]>

  export type PropertyTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyType"]>

  export type PropertyTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "code" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyType"]>
  export type PropertyTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyType$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PropertyTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyType"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      code: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyType"]>
    composites: {}
  }

  type PropertyTypeGetPayload<S extends boolean | null | undefined | PropertyTypeDefaultArgs> = $Result.GetResult<Prisma.$PropertyTypePayload, S>

  type PropertyTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyTypeCountAggregateInputType | true
    }

  export interface PropertyTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyType'], meta: { name: 'PropertyType' } }
    /**
     * Find zero or one PropertyType that matches the filter.
     * @param {PropertyTypeFindUniqueArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyTypeFindUniqueArgs>(args: SelectSubset<T, PropertyTypeFindUniqueArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyTypeFindUniqueOrThrowArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeFindFirstArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyTypeFindFirstArgs>(args?: SelectSubset<T, PropertyTypeFindFirstArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeFindFirstOrThrowArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyTypes
     * const propertyTypes = await prisma.propertyType.findMany()
     * 
     * // Get first 10 PropertyTypes
     * const propertyTypes = await prisma.propertyType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyTypeWithIdOnly = await prisma.propertyType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyTypeFindManyArgs>(args?: SelectSubset<T, PropertyTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyType.
     * @param {PropertyTypeCreateArgs} args - Arguments to create a PropertyType.
     * @example
     * // Create one PropertyType
     * const PropertyType = await prisma.propertyType.create({
     *   data: {
     *     // ... data to create a PropertyType
     *   }
     * })
     * 
     */
    create<T extends PropertyTypeCreateArgs>(args: SelectSubset<T, PropertyTypeCreateArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyTypes.
     * @param {PropertyTypeCreateManyArgs} args - Arguments to create many PropertyTypes.
     * @example
     * // Create many PropertyTypes
     * const propertyType = await prisma.propertyType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyTypeCreateManyArgs>(args?: SelectSubset<T, PropertyTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyTypes and returns the data saved in the database.
     * @param {PropertyTypeCreateManyAndReturnArgs} args - Arguments to create many PropertyTypes.
     * @example
     * // Create many PropertyTypes
     * const propertyType = await prisma.propertyType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyTypes and only return the `id`
     * const propertyTypeWithIdOnly = await prisma.propertyType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyType.
     * @param {PropertyTypeDeleteArgs} args - Arguments to delete one PropertyType.
     * @example
     * // Delete one PropertyType
     * const PropertyType = await prisma.propertyType.delete({
     *   where: {
     *     // ... filter to delete one PropertyType
     *   }
     * })
     * 
     */
    delete<T extends PropertyTypeDeleteArgs>(args: SelectSubset<T, PropertyTypeDeleteArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyType.
     * @param {PropertyTypeUpdateArgs} args - Arguments to update one PropertyType.
     * @example
     * // Update one PropertyType
     * const propertyType = await prisma.propertyType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyTypeUpdateArgs>(args: SelectSubset<T, PropertyTypeUpdateArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyTypes.
     * @param {PropertyTypeDeleteManyArgs} args - Arguments to filter PropertyTypes to delete.
     * @example
     * // Delete a few PropertyTypes
     * const { count } = await prisma.propertyType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyTypeDeleteManyArgs>(args?: SelectSubset<T, PropertyTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyTypes
     * const propertyType = await prisma.propertyType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyTypeUpdateManyArgs>(args: SelectSubset<T, PropertyTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTypes and returns the data updated in the database.
     * @param {PropertyTypeUpdateManyAndReturnArgs} args - Arguments to update many PropertyTypes.
     * @example
     * // Update many PropertyTypes
     * const propertyType = await prisma.propertyType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyTypes and only return the `id`
     * const propertyTypeWithIdOnly = await prisma.propertyType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyType.
     * @param {PropertyTypeUpsertArgs} args - Arguments to update or create a PropertyType.
     * @example
     * // Update or create a PropertyType
     * const propertyType = await prisma.propertyType.upsert({
     *   create: {
     *     // ... data to create a PropertyType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyType we want to update
     *   }
     * })
     */
    upsert<T extends PropertyTypeUpsertArgs>(args: SelectSubset<T, PropertyTypeUpsertArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeCountArgs} args - Arguments to filter PropertyTypes to count.
     * @example
     * // Count the number of PropertyTypes
     * const count = await prisma.propertyType.count({
     *   where: {
     *     // ... the filter for the PropertyTypes we want to count
     *   }
     * })
    **/
    count<T extends PropertyTypeCountArgs>(
      args?: Subset<T, PropertyTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyTypeAggregateArgs>(args: Subset<T, PropertyTypeAggregateArgs>): Prisma.PrismaPromise<GetPropertyTypeAggregateType<T>>

    /**
     * Group by PropertyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyTypeGroupByArgs['orderBy'] }
        : { orderBy?: PropertyTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyType model
   */
  readonly fields: PropertyTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends PropertyType$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyType$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyType model
   */
  interface PropertyTypeFieldRefs {
    readonly id: FieldRef<"PropertyType", 'String'>
    readonly name: FieldRef<"PropertyType", 'String'>
    readonly description: FieldRef<"PropertyType", 'String'>
    readonly code: FieldRef<"PropertyType", 'String'>
    readonly createdAt: FieldRef<"PropertyType", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyType findUnique
   */
  export type PropertyTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where: PropertyTypeWhereUniqueInput
  }

  /**
   * PropertyType findUniqueOrThrow
   */
  export type PropertyTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where: PropertyTypeWhereUniqueInput
  }

  /**
   * PropertyType findFirst
   */
  export type PropertyTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypes.
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypes.
     */
    distinct?: PropertyTypeScalarFieldEnum | PropertyTypeScalarFieldEnum[]
  }

  /**
   * PropertyType findFirstOrThrow
   */
  export type PropertyTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypes.
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypes.
     */
    distinct?: PropertyTypeScalarFieldEnum | PropertyTypeScalarFieldEnum[]
  }

  /**
   * PropertyType findMany
   */
  export type PropertyTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypes to fetch.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyTypes.
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    distinct?: PropertyTypeScalarFieldEnum | PropertyTypeScalarFieldEnum[]
  }

  /**
   * PropertyType create
   */
  export type PropertyTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyType.
     */
    data: XOR<PropertyTypeCreateInput, PropertyTypeUncheckedCreateInput>
  }

  /**
   * PropertyType createMany
   */
  export type PropertyTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyTypes.
     */
    data: PropertyTypeCreateManyInput | PropertyTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyType createManyAndReturn
   */
  export type PropertyTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyTypes.
     */
    data: PropertyTypeCreateManyInput | PropertyTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyType update
   */
  export type PropertyTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyType.
     */
    data: XOR<PropertyTypeUpdateInput, PropertyTypeUncheckedUpdateInput>
    /**
     * Choose, which PropertyType to update.
     */
    where: PropertyTypeWhereUniqueInput
  }

  /**
   * PropertyType updateMany
   */
  export type PropertyTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyTypes.
     */
    data: XOR<PropertyTypeUpdateManyMutationInput, PropertyTypeUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTypes to update
     */
    where?: PropertyTypeWhereInput
    /**
     * Limit how many PropertyTypes to update.
     */
    limit?: number
  }

  /**
   * PropertyType updateManyAndReturn
   */
  export type PropertyTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * The data used to update PropertyTypes.
     */
    data: XOR<PropertyTypeUpdateManyMutationInput, PropertyTypeUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTypes to update
     */
    where?: PropertyTypeWhereInput
    /**
     * Limit how many PropertyTypes to update.
     */
    limit?: number
  }

  /**
   * PropertyType upsert
   */
  export type PropertyTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyType to update in case it exists.
     */
    where: PropertyTypeWhereUniqueInput
    /**
     * In case the PropertyType found by the `where` argument doesn't exist, create a new PropertyType with this data.
     */
    create: XOR<PropertyTypeCreateInput, PropertyTypeUncheckedCreateInput>
    /**
     * In case the PropertyType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyTypeUpdateInput, PropertyTypeUncheckedUpdateInput>
  }

  /**
   * PropertyType delete
   */
  export type PropertyTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter which PropertyType to delete.
     */
    where: PropertyTypeWhereUniqueInput
  }

  /**
   * PropertyType deleteMany
   */
  export type PropertyTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTypes to delete
     */
    where?: PropertyTypeWhereInput
    /**
     * Limit how many PropertyTypes to delete.
     */
    limit?: number
  }

  /**
   * PropertyType.properties
   */
  export type PropertyType$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyType without action
   */
  export type PropertyTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyType
     */
    omit?: PropertyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    sequence: number | null
    quotedPrice: Decimal | null
    baseRent: Decimal | null
    basePerUnitArea: Decimal | null
    areaSqFt: Decimal | null
    floor: number | null
    bedrooms: number | null
    bathrooms: number | null
    tenantResidentCodeCounter: number | null
  }

  export type UnitSumAggregateOutputType = {
    sequence: number | null
    quotedPrice: Decimal | null
    baseRent: Decimal | null
    basePerUnitArea: Decimal | null
    areaSqFt: Decimal | null
    floor: number | null
    bedrooms: number | null
    bathrooms: number | null
    tenantResidentCodeCounter: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    sequence: number | null
    propertyId: string | null
    quotedPrice: Decimal | null
    baseRent: Decimal | null
    basePerUnitArea: Decimal | null
    currency: string | null
    areaSqFt: Decimal | null
    chargePlan: string | null
    floor: number | null
    bedrooms: number | null
    bathrooms: number | null
    furnished: boolean | null
    outSourceParking: string | null
    unitTypeId: string | null
    ownerOccupied: boolean | null
    electricityAcno: string | null
    waterAcno: string | null
    electricityMeethno: string | null
    waterMeethno: string | null
    takeOnLettingDate: Date | null
    tenantResidentCodeCounter: number | null
    apartmentNotes: string | null
    status: $Enums.UnitStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    sequence: number | null
    propertyId: string | null
    quotedPrice: Decimal | null
    baseRent: Decimal | null
    basePerUnitArea: Decimal | null
    currency: string | null
    areaSqFt: Decimal | null
    chargePlan: string | null
    floor: number | null
    bedrooms: number | null
    bathrooms: number | null
    furnished: boolean | null
    outSourceParking: string | null
    unitTypeId: string | null
    ownerOccupied: boolean | null
    electricityAcno: string | null
    waterAcno: string | null
    electricityMeethno: string | null
    waterMeethno: string | null
    takeOnLettingDate: Date | null
    tenantResidentCodeCounter: number | null
    apartmentNotes: string | null
    status: $Enums.UnitStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    code: number
    name: number
    sequence: number
    propertyId: number
    quotedPrice: number
    baseRent: number
    basePerUnitArea: number
    currency: number
    areaSqFt: number
    chargePlan: number
    floor: number
    bedrooms: number
    bathrooms: number
    furnished: number
    outSourceParking: number
    unitTypeId: number
    ownerOccupied: number
    electricityAcno: number
    waterAcno: number
    electricityMeethno: number
    waterMeethno: number
    takeOnLettingDate: number
    tenantResidentCodeCounter: number
    apartmentNotes: number
    status: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    sequence?: true
    quotedPrice?: true
    baseRent?: true
    basePerUnitArea?: true
    areaSqFt?: true
    floor?: true
    bedrooms?: true
    bathrooms?: true
    tenantResidentCodeCounter?: true
  }

  export type UnitSumAggregateInputType = {
    sequence?: true
    quotedPrice?: true
    baseRent?: true
    basePerUnitArea?: true
    areaSqFt?: true
    floor?: true
    bedrooms?: true
    bathrooms?: true
    tenantResidentCodeCounter?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    sequence?: true
    propertyId?: true
    quotedPrice?: true
    baseRent?: true
    basePerUnitArea?: true
    currency?: true
    areaSqFt?: true
    chargePlan?: true
    floor?: true
    bedrooms?: true
    bathrooms?: true
    furnished?: true
    outSourceParking?: true
    unitTypeId?: true
    ownerOccupied?: true
    electricityAcno?: true
    waterAcno?: true
    electricityMeethno?: true
    waterMeethno?: true
    takeOnLettingDate?: true
    tenantResidentCodeCounter?: true
    apartmentNotes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    sequence?: true
    propertyId?: true
    quotedPrice?: true
    baseRent?: true
    basePerUnitArea?: true
    currency?: true
    areaSqFt?: true
    chargePlan?: true
    floor?: true
    bedrooms?: true
    bathrooms?: true
    furnished?: true
    outSourceParking?: true
    unitTypeId?: true
    ownerOccupied?: true
    electricityAcno?: true
    waterAcno?: true
    electricityMeethno?: true
    waterMeethno?: true
    takeOnLettingDate?: true
    tenantResidentCodeCounter?: true
    apartmentNotes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    sequence?: true
    propertyId?: true
    quotedPrice?: true
    baseRent?: true
    basePerUnitArea?: true
    currency?: true
    areaSqFt?: true
    chargePlan?: true
    floor?: true
    bedrooms?: true
    bathrooms?: true
    furnished?: true
    outSourceParking?: true
    unitTypeId?: true
    ownerOccupied?: true
    electricityAcno?: true
    waterAcno?: true
    electricityMeethno?: true
    waterMeethno?: true
    takeOnLettingDate?: true
    tenantResidentCodeCounter?: true
    apartmentNotes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    code: string
    name: string
    sequence: number | null
    propertyId: string
    quotedPrice: Decimal | null
    baseRent: Decimal | null
    basePerUnitArea: Decimal | null
    currency: string
    areaSqFt: Decimal | null
    chargePlan: string | null
    floor: number | null
    bedrooms: number | null
    bathrooms: number | null
    furnished: boolean
    outSourceParking: string | null
    unitTypeId: string | null
    ownerOccupied: boolean
    electricityAcno: string | null
    waterAcno: string | null
    electricityMeethno: string | null
    waterMeethno: string | null
    takeOnLettingDate: Date | null
    tenantResidentCodeCounter: number | null
    apartmentNotes: string | null
    status: $Enums.UnitStatus
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    sequence?: boolean
    propertyId?: boolean
    quotedPrice?: boolean
    baseRent?: boolean
    basePerUnitArea?: boolean
    currency?: boolean
    areaSqFt?: boolean
    chargePlan?: boolean
    floor?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    furnished?: boolean
    outSourceParking?: boolean
    unitTypeId?: boolean
    ownerOccupied?: boolean
    electricityAcno?: boolean
    waterAcno?: boolean
    electricityMeethno?: boolean
    waterMeethno?: boolean
    takeOnLettingDate?: boolean
    tenantResidentCodeCounter?: boolean
    apartmentNotes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    unitType?: boolean | Unit$unitTypeArgs<ExtArgs>
    leases?: boolean | Unit$leasesArgs<ExtArgs>
    serviceCharges?: boolean | Unit$serviceChargesArgs<ExtArgs>
    meterNumbers?: boolean | Unit$meterNumbersArgs<ExtArgs>
    features?: boolean | Unit$featuresArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    sequence?: boolean
    propertyId?: boolean
    quotedPrice?: boolean
    baseRent?: boolean
    basePerUnitArea?: boolean
    currency?: boolean
    areaSqFt?: boolean
    chargePlan?: boolean
    floor?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    furnished?: boolean
    outSourceParking?: boolean
    unitTypeId?: boolean
    ownerOccupied?: boolean
    electricityAcno?: boolean
    waterAcno?: boolean
    electricityMeethno?: boolean
    waterMeethno?: boolean
    takeOnLettingDate?: boolean
    tenantResidentCodeCounter?: boolean
    apartmentNotes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    unitType?: boolean | Unit$unitTypeArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    sequence?: boolean
    propertyId?: boolean
    quotedPrice?: boolean
    baseRent?: boolean
    basePerUnitArea?: boolean
    currency?: boolean
    areaSqFt?: boolean
    chargePlan?: boolean
    floor?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    furnished?: boolean
    outSourceParking?: boolean
    unitTypeId?: boolean
    ownerOccupied?: boolean
    electricityAcno?: boolean
    waterAcno?: boolean
    electricityMeethno?: boolean
    waterMeethno?: boolean
    takeOnLettingDate?: boolean
    tenantResidentCodeCounter?: boolean
    apartmentNotes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    unitType?: boolean | Unit$unitTypeArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    sequence?: boolean
    propertyId?: boolean
    quotedPrice?: boolean
    baseRent?: boolean
    basePerUnitArea?: boolean
    currency?: boolean
    areaSqFt?: boolean
    chargePlan?: boolean
    floor?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    furnished?: boolean
    outSourceParking?: boolean
    unitTypeId?: boolean
    ownerOccupied?: boolean
    electricityAcno?: boolean
    waterAcno?: boolean
    electricityMeethno?: boolean
    waterMeethno?: boolean
    takeOnLettingDate?: boolean
    tenantResidentCodeCounter?: boolean
    apartmentNotes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "sequence" | "propertyId" | "quotedPrice" | "baseRent" | "basePerUnitArea" | "currency" | "areaSqFt" | "chargePlan" | "floor" | "bedrooms" | "bathrooms" | "furnished" | "outSourceParking" | "unitTypeId" | "ownerOccupied" | "electricityAcno" | "waterAcno" | "electricityMeethno" | "waterMeethno" | "takeOnLettingDate" | "tenantResidentCodeCounter" | "apartmentNotes" | "status" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    unitType?: boolean | Unit$unitTypeArgs<ExtArgs>
    leases?: boolean | Unit$leasesArgs<ExtArgs>
    serviceCharges?: boolean | Unit$serviceChargesArgs<ExtArgs>
    meterNumbers?: boolean | Unit$meterNumbersArgs<ExtArgs>
    features?: boolean | Unit$featuresArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    unitType?: boolean | Unit$unitTypeArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    unitType?: boolean | Unit$unitTypeArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      unitType: Prisma.$UnitTypePayload<ExtArgs> | null
      leases: Prisma.$LeasePayload<ExtArgs>[]
      serviceCharges: Prisma.$UnitServiceChargePayload<ExtArgs>[]
      meterNumbers: Prisma.$UnitMeterNumberPayload<ExtArgs>[]
      features: Prisma.$UnitFeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      sequence: number | null
      propertyId: string
      quotedPrice: Prisma.Decimal | null
      baseRent: Prisma.Decimal | null
      basePerUnitArea: Prisma.Decimal | null
      currency: string
      areaSqFt: Prisma.Decimal | null
      chargePlan: string | null
      floor: number | null
      bedrooms: number | null
      bathrooms: number | null
      furnished: boolean
      outSourceParking: string | null
      unitTypeId: string | null
      ownerOccupied: boolean
      electricityAcno: string | null
      waterAcno: string | null
      electricityMeethno: string | null
      waterMeethno: string | null
      takeOnLettingDate: Date | null
      tenantResidentCodeCounter: number | null
      apartmentNotes: string | null
      status: $Enums.UnitStatus
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitType<T extends Unit$unitTypeArgs<ExtArgs> = {}>(args?: Subset<T, Unit$unitTypeArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    leases<T extends Unit$leasesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$leasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceCharges<T extends Unit$serviceChargesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$serviceChargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meterNumbers<T extends Unit$meterNumbersArgs<ExtArgs> = {}>(args?: Subset<T, Unit$meterNumbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    features<T extends Unit$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Unit$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly code: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly sequence: FieldRef<"Unit", 'Int'>
    readonly propertyId: FieldRef<"Unit", 'String'>
    readonly quotedPrice: FieldRef<"Unit", 'Decimal'>
    readonly baseRent: FieldRef<"Unit", 'Decimal'>
    readonly basePerUnitArea: FieldRef<"Unit", 'Decimal'>
    readonly currency: FieldRef<"Unit", 'String'>
    readonly areaSqFt: FieldRef<"Unit", 'Decimal'>
    readonly chargePlan: FieldRef<"Unit", 'String'>
    readonly floor: FieldRef<"Unit", 'Int'>
    readonly bedrooms: FieldRef<"Unit", 'Int'>
    readonly bathrooms: FieldRef<"Unit", 'Int'>
    readonly furnished: FieldRef<"Unit", 'Boolean'>
    readonly outSourceParking: FieldRef<"Unit", 'String'>
    readonly unitTypeId: FieldRef<"Unit", 'String'>
    readonly ownerOccupied: FieldRef<"Unit", 'Boolean'>
    readonly electricityAcno: FieldRef<"Unit", 'String'>
    readonly waterAcno: FieldRef<"Unit", 'String'>
    readonly electricityMeethno: FieldRef<"Unit", 'String'>
    readonly waterMeethno: FieldRef<"Unit", 'String'>
    readonly takeOnLettingDate: FieldRef<"Unit", 'DateTime'>
    readonly tenantResidentCodeCounter: FieldRef<"Unit", 'Int'>
    readonly apartmentNotes: FieldRef<"Unit", 'String'>
    readonly status: FieldRef<"Unit", 'UnitStatus'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
    readonly deletedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.unitType
   */
  export type Unit$unitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    where?: UnitTypeWhereInput
  }

  /**
   * Unit.leases
   */
  export type Unit$leasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Unit.serviceCharges
   */
  export type Unit$serviceChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    where?: UnitServiceChargeWhereInput
    orderBy?: UnitServiceChargeOrderByWithRelationInput | UnitServiceChargeOrderByWithRelationInput[]
    cursor?: UnitServiceChargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitServiceChargeScalarFieldEnum | UnitServiceChargeScalarFieldEnum[]
  }

  /**
   * Unit.meterNumbers
   */
  export type Unit$meterNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    where?: UnitMeterNumberWhereInput
    orderBy?: UnitMeterNumberOrderByWithRelationInput | UnitMeterNumberOrderByWithRelationInput[]
    cursor?: UnitMeterNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitMeterNumberScalarFieldEnum | UnitMeterNumberScalarFieldEnum[]
  }

  /**
   * Unit.features
   */
  export type Unit$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    where?: UnitFeatureWhereInput
    orderBy?: UnitFeatureOrderByWithRelationInput | UnitFeatureOrderByWithRelationInput[]
    cursor?: UnitFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitFeatureScalarFieldEnum | UnitFeatureScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model UnitType
   */

  export type AggregateUnitType = {
    _count: UnitTypeCountAggregateOutputType | null
    _min: UnitTypeMinAggregateOutputType | null
    _max: UnitTypeMaxAggregateOutputType | null
  }

  export type UnitTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitType to aggregate.
     */
    where?: UnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypes to fetch.
     */
    orderBy?: UnitTypeOrderByWithRelationInput | UnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitTypes
    **/
    _count?: true | UnitTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitTypeMaxAggregateInputType
  }

  export type GetUnitTypeAggregateType<T extends UnitTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitType[P]>
      : GetScalarType<T[P], AggregateUnitType[P]>
  }




  export type UnitTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitTypeWhereInput
    orderBy?: UnitTypeOrderByWithAggregationInput | UnitTypeOrderByWithAggregationInput[]
    by: UnitTypeScalarFieldEnum[] | UnitTypeScalarFieldEnum
    having?: UnitTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitTypeCountAggregateInputType | true
    _min?: UnitTypeMinAggregateInputType
    _max?: UnitTypeMaxAggregateInputType
  }

  export type UnitTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitTypeCountAggregateOutputType | null
    _min: UnitTypeMinAggregateOutputType | null
    _max: UnitTypeMaxAggregateOutputType | null
  }

  type GetUnitTypeGroupByPayload<T extends UnitTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitTypeGroupByOutputType[P]>
            : GetScalarType<T[P], UnitTypeGroupByOutputType[P]>
        }
      >
    >


  export type UnitTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    units?: boolean | UnitType$unitsArgs<ExtArgs>
    _count?: boolean | UnitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitType"]>

  export type UnitTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitType"]>

  export type UnitTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitType"]>

  export type UnitTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["unitType"]>
  export type UnitTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | UnitType$unitsArgs<ExtArgs>
    _count?: boolean | UnitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitType"
    objects: {
      units: Prisma.$UnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitType"]>
    composites: {}
  }

  type UnitTypeGetPayload<S extends boolean | null | undefined | UnitTypeDefaultArgs> = $Result.GetResult<Prisma.$UnitTypePayload, S>

  type UnitTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitTypeCountAggregateInputType | true
    }

  export interface UnitTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitType'], meta: { name: 'UnitType' } }
    /**
     * Find zero or one UnitType that matches the filter.
     * @param {UnitTypeFindUniqueArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitTypeFindUniqueArgs>(args: SelectSubset<T, UnitTypeFindUniqueArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitTypeFindUniqueOrThrowArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeFindFirstArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitTypeFindFirstArgs>(args?: SelectSubset<T, UnitTypeFindFirstArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeFindFirstOrThrowArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitTypes
     * const unitTypes = await prisma.unitType.findMany()
     * 
     * // Get first 10 UnitTypes
     * const unitTypes = await prisma.unitType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitTypeWithIdOnly = await prisma.unitType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitTypeFindManyArgs>(args?: SelectSubset<T, UnitTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitType.
     * @param {UnitTypeCreateArgs} args - Arguments to create a UnitType.
     * @example
     * // Create one UnitType
     * const UnitType = await prisma.unitType.create({
     *   data: {
     *     // ... data to create a UnitType
     *   }
     * })
     * 
     */
    create<T extends UnitTypeCreateArgs>(args: SelectSubset<T, UnitTypeCreateArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitTypes.
     * @param {UnitTypeCreateManyArgs} args - Arguments to create many UnitTypes.
     * @example
     * // Create many UnitTypes
     * const unitType = await prisma.unitType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitTypeCreateManyArgs>(args?: SelectSubset<T, UnitTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitTypes and returns the data saved in the database.
     * @param {UnitTypeCreateManyAndReturnArgs} args - Arguments to create many UnitTypes.
     * @example
     * // Create many UnitTypes
     * const unitType = await prisma.unitType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitTypes and only return the `id`
     * const unitTypeWithIdOnly = await prisma.unitType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitType.
     * @param {UnitTypeDeleteArgs} args - Arguments to delete one UnitType.
     * @example
     * // Delete one UnitType
     * const UnitType = await prisma.unitType.delete({
     *   where: {
     *     // ... filter to delete one UnitType
     *   }
     * })
     * 
     */
    delete<T extends UnitTypeDeleteArgs>(args: SelectSubset<T, UnitTypeDeleteArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitType.
     * @param {UnitTypeUpdateArgs} args - Arguments to update one UnitType.
     * @example
     * // Update one UnitType
     * const unitType = await prisma.unitType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitTypeUpdateArgs>(args: SelectSubset<T, UnitTypeUpdateArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitTypes.
     * @param {UnitTypeDeleteManyArgs} args - Arguments to filter UnitTypes to delete.
     * @example
     * // Delete a few UnitTypes
     * const { count } = await prisma.unitType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitTypeDeleteManyArgs>(args?: SelectSubset<T, UnitTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitTypes
     * const unitType = await prisma.unitType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitTypeUpdateManyArgs>(args: SelectSubset<T, UnitTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitTypes and returns the data updated in the database.
     * @param {UnitTypeUpdateManyAndReturnArgs} args - Arguments to update many UnitTypes.
     * @example
     * // Update many UnitTypes
     * const unitType = await prisma.unitType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitTypes and only return the `id`
     * const unitTypeWithIdOnly = await prisma.unitType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitType.
     * @param {UnitTypeUpsertArgs} args - Arguments to update or create a UnitType.
     * @example
     * // Update or create a UnitType
     * const unitType = await prisma.unitType.upsert({
     *   create: {
     *     // ... data to create a UnitType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitType we want to update
     *   }
     * })
     */
    upsert<T extends UnitTypeUpsertArgs>(args: SelectSubset<T, UnitTypeUpsertArgs<ExtArgs>>): Prisma__UnitTypeClient<$Result.GetResult<Prisma.$UnitTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCountArgs} args - Arguments to filter UnitTypes to count.
     * @example
     * // Count the number of UnitTypes
     * const count = await prisma.unitType.count({
     *   where: {
     *     // ... the filter for the UnitTypes we want to count
     *   }
     * })
    **/
    count<T extends UnitTypeCountArgs>(
      args?: Subset<T, UnitTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitTypeAggregateArgs>(args: Subset<T, UnitTypeAggregateArgs>): Prisma.PrismaPromise<GetUnitTypeAggregateType<T>>

    /**
     * Group by UnitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitTypeGroupByArgs['orderBy'] }
        : { orderBy?: UnitTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitType model
   */
  readonly fields: UnitTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    units<T extends UnitType$unitsArgs<ExtArgs> = {}>(args?: Subset<T, UnitType$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitType model
   */
  interface UnitTypeFieldRefs {
    readonly id: FieldRef<"UnitType", 'String'>
    readonly name: FieldRef<"UnitType", 'String'>
    readonly description: FieldRef<"UnitType", 'String'>
    readonly createdAt: FieldRef<"UnitType", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitType findUnique
   */
  export type UnitTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitType to fetch.
     */
    where: UnitTypeWhereUniqueInput
  }

  /**
   * UnitType findUniqueOrThrow
   */
  export type UnitTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitType to fetch.
     */
    where: UnitTypeWhereUniqueInput
  }

  /**
   * UnitType findFirst
   */
  export type UnitTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitType to fetch.
     */
    where?: UnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypes to fetch.
     */
    orderBy?: UnitTypeOrderByWithRelationInput | UnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTypes.
     */
    cursor?: UnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTypes.
     */
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * UnitType findFirstOrThrow
   */
  export type UnitTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitType to fetch.
     */
    where?: UnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypes to fetch.
     */
    orderBy?: UnitTypeOrderByWithRelationInput | UnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTypes.
     */
    cursor?: UnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTypes.
     */
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * UnitType findMany
   */
  export type UnitTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which UnitTypes to fetch.
     */
    where?: UnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypes to fetch.
     */
    orderBy?: UnitTypeOrderByWithRelationInput | UnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitTypes.
     */
    cursor?: UnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypes.
     */
    skip?: number
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * UnitType create
   */
  export type UnitTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitType.
     */
    data: XOR<UnitTypeCreateInput, UnitTypeUncheckedCreateInput>
  }

  /**
   * UnitType createMany
   */
  export type UnitTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitTypes.
     */
    data: UnitTypeCreateManyInput | UnitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitType createManyAndReturn
   */
  export type UnitTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * The data used to create many UnitTypes.
     */
    data: UnitTypeCreateManyInput | UnitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitType update
   */
  export type UnitTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitType.
     */
    data: XOR<UnitTypeUpdateInput, UnitTypeUncheckedUpdateInput>
    /**
     * Choose, which UnitType to update.
     */
    where: UnitTypeWhereUniqueInput
  }

  /**
   * UnitType updateMany
   */
  export type UnitTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitTypes.
     */
    data: XOR<UnitTypeUpdateManyMutationInput, UnitTypeUncheckedUpdateManyInput>
    /**
     * Filter which UnitTypes to update
     */
    where?: UnitTypeWhereInput
    /**
     * Limit how many UnitTypes to update.
     */
    limit?: number
  }

  /**
   * UnitType updateManyAndReturn
   */
  export type UnitTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * The data used to update UnitTypes.
     */
    data: XOR<UnitTypeUpdateManyMutationInput, UnitTypeUncheckedUpdateManyInput>
    /**
     * Filter which UnitTypes to update
     */
    where?: UnitTypeWhereInput
    /**
     * Limit how many UnitTypes to update.
     */
    limit?: number
  }

  /**
   * UnitType upsert
   */
  export type UnitTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitType to update in case it exists.
     */
    where: UnitTypeWhereUniqueInput
    /**
     * In case the UnitType found by the `where` argument doesn't exist, create a new UnitType with this data.
     */
    create: XOR<UnitTypeCreateInput, UnitTypeUncheckedCreateInput>
    /**
     * In case the UnitType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitTypeUpdateInput, UnitTypeUncheckedUpdateInput>
  }

  /**
   * UnitType delete
   */
  export type UnitTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
    /**
     * Filter which UnitType to delete.
     */
    where: UnitTypeWhereUniqueInput
  }

  /**
   * UnitType deleteMany
   */
  export type UnitTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitTypes to delete
     */
    where?: UnitTypeWhereInput
    /**
     * Limit how many UnitTypes to delete.
     */
    limit?: number
  }

  /**
   * UnitType.units
   */
  export type UnitType$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * UnitType without action
   */
  export type UnitTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitType
     */
    select?: UnitTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitType
     */
    omit?: UnitTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeInclude<ExtArgs> | null
  }


  /**
   * Model UnitServiceCharge
   */

  export type AggregateUnitServiceCharge = {
    _count: UnitServiceChargeCountAggregateOutputType | null
    _avg: UnitServiceChargeAvgAggregateOutputType | null
    _sum: UnitServiceChargeSumAggregateOutputType | null
    _min: UnitServiceChargeMinAggregateOutputType | null
    _max: UnitServiceChargeMaxAggregateOutputType | null
  }

  export type UnitServiceChargeAvgAggregateOutputType = {
    costPerArea: Decimal | null
    totalCost: Decimal | null
  }

  export type UnitServiceChargeSumAggregateOutputType = {
    costPerArea: Decimal | null
    totalCost: Decimal | null
  }

  export type UnitServiceChargeMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    serviceUtilityAmenity: string | null
    costPerArea: Decimal | null
    totalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitServiceChargeMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    serviceUtilityAmenity: string | null
    costPerArea: Decimal | null
    totalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitServiceChargeCountAggregateOutputType = {
    id: number
    unitId: number
    serviceUtilityAmenity: number
    costPerArea: number
    totalCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitServiceChargeAvgAggregateInputType = {
    costPerArea?: true
    totalCost?: true
  }

  export type UnitServiceChargeSumAggregateInputType = {
    costPerArea?: true
    totalCost?: true
  }

  export type UnitServiceChargeMinAggregateInputType = {
    id?: true
    unitId?: true
    serviceUtilityAmenity?: true
    costPerArea?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitServiceChargeMaxAggregateInputType = {
    id?: true
    unitId?: true
    serviceUtilityAmenity?: true
    costPerArea?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitServiceChargeCountAggregateInputType = {
    id?: true
    unitId?: true
    serviceUtilityAmenity?: true
    costPerArea?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitServiceChargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitServiceCharge to aggregate.
     */
    where?: UnitServiceChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServiceCharges to fetch.
     */
    orderBy?: UnitServiceChargeOrderByWithRelationInput | UnitServiceChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitServiceChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServiceCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServiceCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitServiceCharges
    **/
    _count?: true | UnitServiceChargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitServiceChargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitServiceChargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitServiceChargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitServiceChargeMaxAggregateInputType
  }

  export type GetUnitServiceChargeAggregateType<T extends UnitServiceChargeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitServiceCharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitServiceCharge[P]>
      : GetScalarType<T[P], AggregateUnitServiceCharge[P]>
  }




  export type UnitServiceChargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitServiceChargeWhereInput
    orderBy?: UnitServiceChargeOrderByWithAggregationInput | UnitServiceChargeOrderByWithAggregationInput[]
    by: UnitServiceChargeScalarFieldEnum[] | UnitServiceChargeScalarFieldEnum
    having?: UnitServiceChargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitServiceChargeCountAggregateInputType | true
    _avg?: UnitServiceChargeAvgAggregateInputType
    _sum?: UnitServiceChargeSumAggregateInputType
    _min?: UnitServiceChargeMinAggregateInputType
    _max?: UnitServiceChargeMaxAggregateInputType
  }

  export type UnitServiceChargeGroupByOutputType = {
    id: string
    unitId: string
    serviceUtilityAmenity: string
    costPerArea: Decimal | null
    totalCost: Decimal
    createdAt: Date
    updatedAt: Date
    _count: UnitServiceChargeCountAggregateOutputType | null
    _avg: UnitServiceChargeAvgAggregateOutputType | null
    _sum: UnitServiceChargeSumAggregateOutputType | null
    _min: UnitServiceChargeMinAggregateOutputType | null
    _max: UnitServiceChargeMaxAggregateOutputType | null
  }

  type GetUnitServiceChargeGroupByPayload<T extends UnitServiceChargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitServiceChargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitServiceChargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitServiceChargeGroupByOutputType[P]>
            : GetScalarType<T[P], UnitServiceChargeGroupByOutputType[P]>
        }
      >
    >


  export type UnitServiceChargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    serviceUtilityAmenity?: boolean
    costPerArea?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitServiceCharge"]>

  export type UnitServiceChargeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    serviceUtilityAmenity?: boolean
    costPerArea?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitServiceCharge"]>

  export type UnitServiceChargeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    serviceUtilityAmenity?: boolean
    costPerArea?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitServiceCharge"]>

  export type UnitServiceChargeSelectScalar = {
    id?: boolean
    unitId?: boolean
    serviceUtilityAmenity?: boolean
    costPerArea?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitServiceChargeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "serviceUtilityAmenity" | "costPerArea" | "totalCost" | "createdAt" | "updatedAt", ExtArgs["result"]["unitServiceCharge"]>
  export type UnitServiceChargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitServiceChargeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitServiceChargeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitServiceChargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitServiceCharge"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      serviceUtilityAmenity: string
      costPerArea: Prisma.Decimal | null
      totalCost: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitServiceCharge"]>
    composites: {}
  }

  type UnitServiceChargeGetPayload<S extends boolean | null | undefined | UnitServiceChargeDefaultArgs> = $Result.GetResult<Prisma.$UnitServiceChargePayload, S>

  type UnitServiceChargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitServiceChargeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitServiceChargeCountAggregateInputType | true
    }

  export interface UnitServiceChargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitServiceCharge'], meta: { name: 'UnitServiceCharge' } }
    /**
     * Find zero or one UnitServiceCharge that matches the filter.
     * @param {UnitServiceChargeFindUniqueArgs} args - Arguments to find a UnitServiceCharge
     * @example
     * // Get one UnitServiceCharge
     * const unitServiceCharge = await prisma.unitServiceCharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitServiceChargeFindUniqueArgs>(args: SelectSubset<T, UnitServiceChargeFindUniqueArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitServiceCharge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitServiceChargeFindUniqueOrThrowArgs} args - Arguments to find a UnitServiceCharge
     * @example
     * // Get one UnitServiceCharge
     * const unitServiceCharge = await prisma.unitServiceCharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitServiceChargeFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitServiceChargeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitServiceCharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceChargeFindFirstArgs} args - Arguments to find a UnitServiceCharge
     * @example
     * // Get one UnitServiceCharge
     * const unitServiceCharge = await prisma.unitServiceCharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitServiceChargeFindFirstArgs>(args?: SelectSubset<T, UnitServiceChargeFindFirstArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitServiceCharge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceChargeFindFirstOrThrowArgs} args - Arguments to find a UnitServiceCharge
     * @example
     * // Get one UnitServiceCharge
     * const unitServiceCharge = await prisma.unitServiceCharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitServiceChargeFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitServiceChargeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitServiceCharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceChargeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitServiceCharges
     * const unitServiceCharges = await prisma.unitServiceCharge.findMany()
     * 
     * // Get first 10 UnitServiceCharges
     * const unitServiceCharges = await prisma.unitServiceCharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitServiceChargeWithIdOnly = await prisma.unitServiceCharge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitServiceChargeFindManyArgs>(args?: SelectSubset<T, UnitServiceChargeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitServiceCharge.
     * @param {UnitServiceChargeCreateArgs} args - Arguments to create a UnitServiceCharge.
     * @example
     * // Create one UnitServiceCharge
     * const UnitServiceCharge = await prisma.unitServiceCharge.create({
     *   data: {
     *     // ... data to create a UnitServiceCharge
     *   }
     * })
     * 
     */
    create<T extends UnitServiceChargeCreateArgs>(args: SelectSubset<T, UnitServiceChargeCreateArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitServiceCharges.
     * @param {UnitServiceChargeCreateManyArgs} args - Arguments to create many UnitServiceCharges.
     * @example
     * // Create many UnitServiceCharges
     * const unitServiceCharge = await prisma.unitServiceCharge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitServiceChargeCreateManyArgs>(args?: SelectSubset<T, UnitServiceChargeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitServiceCharges and returns the data saved in the database.
     * @param {UnitServiceChargeCreateManyAndReturnArgs} args - Arguments to create many UnitServiceCharges.
     * @example
     * // Create many UnitServiceCharges
     * const unitServiceCharge = await prisma.unitServiceCharge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitServiceCharges and only return the `id`
     * const unitServiceChargeWithIdOnly = await prisma.unitServiceCharge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitServiceChargeCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitServiceChargeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitServiceCharge.
     * @param {UnitServiceChargeDeleteArgs} args - Arguments to delete one UnitServiceCharge.
     * @example
     * // Delete one UnitServiceCharge
     * const UnitServiceCharge = await prisma.unitServiceCharge.delete({
     *   where: {
     *     // ... filter to delete one UnitServiceCharge
     *   }
     * })
     * 
     */
    delete<T extends UnitServiceChargeDeleteArgs>(args: SelectSubset<T, UnitServiceChargeDeleteArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitServiceCharge.
     * @param {UnitServiceChargeUpdateArgs} args - Arguments to update one UnitServiceCharge.
     * @example
     * // Update one UnitServiceCharge
     * const unitServiceCharge = await prisma.unitServiceCharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitServiceChargeUpdateArgs>(args: SelectSubset<T, UnitServiceChargeUpdateArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitServiceCharges.
     * @param {UnitServiceChargeDeleteManyArgs} args - Arguments to filter UnitServiceCharges to delete.
     * @example
     * // Delete a few UnitServiceCharges
     * const { count } = await prisma.unitServiceCharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitServiceChargeDeleteManyArgs>(args?: SelectSubset<T, UnitServiceChargeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitServiceCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceChargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitServiceCharges
     * const unitServiceCharge = await prisma.unitServiceCharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitServiceChargeUpdateManyArgs>(args: SelectSubset<T, UnitServiceChargeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitServiceCharges and returns the data updated in the database.
     * @param {UnitServiceChargeUpdateManyAndReturnArgs} args - Arguments to update many UnitServiceCharges.
     * @example
     * // Update many UnitServiceCharges
     * const unitServiceCharge = await prisma.unitServiceCharge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitServiceCharges and only return the `id`
     * const unitServiceChargeWithIdOnly = await prisma.unitServiceCharge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitServiceChargeUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitServiceChargeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitServiceCharge.
     * @param {UnitServiceChargeUpsertArgs} args - Arguments to update or create a UnitServiceCharge.
     * @example
     * // Update or create a UnitServiceCharge
     * const unitServiceCharge = await prisma.unitServiceCharge.upsert({
     *   create: {
     *     // ... data to create a UnitServiceCharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitServiceCharge we want to update
     *   }
     * })
     */
    upsert<T extends UnitServiceChargeUpsertArgs>(args: SelectSubset<T, UnitServiceChargeUpsertArgs<ExtArgs>>): Prisma__UnitServiceChargeClient<$Result.GetResult<Prisma.$UnitServiceChargePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitServiceCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceChargeCountArgs} args - Arguments to filter UnitServiceCharges to count.
     * @example
     * // Count the number of UnitServiceCharges
     * const count = await prisma.unitServiceCharge.count({
     *   where: {
     *     // ... the filter for the UnitServiceCharges we want to count
     *   }
     * })
    **/
    count<T extends UnitServiceChargeCountArgs>(
      args?: Subset<T, UnitServiceChargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitServiceChargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitServiceCharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceChargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitServiceChargeAggregateArgs>(args: Subset<T, UnitServiceChargeAggregateArgs>): Prisma.PrismaPromise<GetUnitServiceChargeAggregateType<T>>

    /**
     * Group by UnitServiceCharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceChargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitServiceChargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitServiceChargeGroupByArgs['orderBy'] }
        : { orderBy?: UnitServiceChargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitServiceChargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitServiceChargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitServiceCharge model
   */
  readonly fields: UnitServiceChargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitServiceCharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitServiceChargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitServiceCharge model
   */
  interface UnitServiceChargeFieldRefs {
    readonly id: FieldRef<"UnitServiceCharge", 'String'>
    readonly unitId: FieldRef<"UnitServiceCharge", 'String'>
    readonly serviceUtilityAmenity: FieldRef<"UnitServiceCharge", 'String'>
    readonly costPerArea: FieldRef<"UnitServiceCharge", 'Decimal'>
    readonly totalCost: FieldRef<"UnitServiceCharge", 'Decimal'>
    readonly createdAt: FieldRef<"UnitServiceCharge", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitServiceCharge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitServiceCharge findUnique
   */
  export type UnitServiceChargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * Filter, which UnitServiceCharge to fetch.
     */
    where: UnitServiceChargeWhereUniqueInput
  }

  /**
   * UnitServiceCharge findUniqueOrThrow
   */
  export type UnitServiceChargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * Filter, which UnitServiceCharge to fetch.
     */
    where: UnitServiceChargeWhereUniqueInput
  }

  /**
   * UnitServiceCharge findFirst
   */
  export type UnitServiceChargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * Filter, which UnitServiceCharge to fetch.
     */
    where?: UnitServiceChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServiceCharges to fetch.
     */
    orderBy?: UnitServiceChargeOrderByWithRelationInput | UnitServiceChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitServiceCharges.
     */
    cursor?: UnitServiceChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServiceCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServiceCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitServiceCharges.
     */
    distinct?: UnitServiceChargeScalarFieldEnum | UnitServiceChargeScalarFieldEnum[]
  }

  /**
   * UnitServiceCharge findFirstOrThrow
   */
  export type UnitServiceChargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * Filter, which UnitServiceCharge to fetch.
     */
    where?: UnitServiceChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServiceCharges to fetch.
     */
    orderBy?: UnitServiceChargeOrderByWithRelationInput | UnitServiceChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitServiceCharges.
     */
    cursor?: UnitServiceChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServiceCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServiceCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitServiceCharges.
     */
    distinct?: UnitServiceChargeScalarFieldEnum | UnitServiceChargeScalarFieldEnum[]
  }

  /**
   * UnitServiceCharge findMany
   */
  export type UnitServiceChargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * Filter, which UnitServiceCharges to fetch.
     */
    where?: UnitServiceChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServiceCharges to fetch.
     */
    orderBy?: UnitServiceChargeOrderByWithRelationInput | UnitServiceChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitServiceCharges.
     */
    cursor?: UnitServiceChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServiceCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServiceCharges.
     */
    skip?: number
    distinct?: UnitServiceChargeScalarFieldEnum | UnitServiceChargeScalarFieldEnum[]
  }

  /**
   * UnitServiceCharge create
   */
  export type UnitServiceChargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitServiceCharge.
     */
    data: XOR<UnitServiceChargeCreateInput, UnitServiceChargeUncheckedCreateInput>
  }

  /**
   * UnitServiceCharge createMany
   */
  export type UnitServiceChargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitServiceCharges.
     */
    data: UnitServiceChargeCreateManyInput | UnitServiceChargeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitServiceCharge createManyAndReturn
   */
  export type UnitServiceChargeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * The data used to create many UnitServiceCharges.
     */
    data: UnitServiceChargeCreateManyInput | UnitServiceChargeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitServiceCharge update
   */
  export type UnitServiceChargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitServiceCharge.
     */
    data: XOR<UnitServiceChargeUpdateInput, UnitServiceChargeUncheckedUpdateInput>
    /**
     * Choose, which UnitServiceCharge to update.
     */
    where: UnitServiceChargeWhereUniqueInput
  }

  /**
   * UnitServiceCharge updateMany
   */
  export type UnitServiceChargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitServiceCharges.
     */
    data: XOR<UnitServiceChargeUpdateManyMutationInput, UnitServiceChargeUncheckedUpdateManyInput>
    /**
     * Filter which UnitServiceCharges to update
     */
    where?: UnitServiceChargeWhereInput
    /**
     * Limit how many UnitServiceCharges to update.
     */
    limit?: number
  }

  /**
   * UnitServiceCharge updateManyAndReturn
   */
  export type UnitServiceChargeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * The data used to update UnitServiceCharges.
     */
    data: XOR<UnitServiceChargeUpdateManyMutationInput, UnitServiceChargeUncheckedUpdateManyInput>
    /**
     * Filter which UnitServiceCharges to update
     */
    where?: UnitServiceChargeWhereInput
    /**
     * Limit how many UnitServiceCharges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitServiceCharge upsert
   */
  export type UnitServiceChargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitServiceCharge to update in case it exists.
     */
    where: UnitServiceChargeWhereUniqueInput
    /**
     * In case the UnitServiceCharge found by the `where` argument doesn't exist, create a new UnitServiceCharge with this data.
     */
    create: XOR<UnitServiceChargeCreateInput, UnitServiceChargeUncheckedCreateInput>
    /**
     * In case the UnitServiceCharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitServiceChargeUpdateInput, UnitServiceChargeUncheckedUpdateInput>
  }

  /**
   * UnitServiceCharge delete
   */
  export type UnitServiceChargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
    /**
     * Filter which UnitServiceCharge to delete.
     */
    where: UnitServiceChargeWhereUniqueInput
  }

  /**
   * UnitServiceCharge deleteMany
   */
  export type UnitServiceChargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitServiceCharges to delete
     */
    where?: UnitServiceChargeWhereInput
    /**
     * Limit how many UnitServiceCharges to delete.
     */
    limit?: number
  }

  /**
   * UnitServiceCharge without action
   */
  export type UnitServiceChargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitServiceCharge
     */
    select?: UnitServiceChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitServiceCharge
     */
    omit?: UnitServiceChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceChargeInclude<ExtArgs> | null
  }


  /**
   * Model UnitMeterNumber
   */

  export type AggregateUnitMeterNumber = {
    _count: UnitMeterNumberCountAggregateOutputType | null
    _min: UnitMeterNumberMinAggregateOutputType | null
    _max: UnitMeterNumberMaxAggregateOutputType | null
  }

  export type UnitMeterNumberMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    meterNo: string | null
    readingSetup: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMeterNumberMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    meterNo: string | null
    readingSetup: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMeterNumberCountAggregateOutputType = {
    id: number
    unitId: number
    meterNo: number
    readingSetup: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitMeterNumberMinAggregateInputType = {
    id?: true
    unitId?: true
    meterNo?: true
    readingSetup?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMeterNumberMaxAggregateInputType = {
    id?: true
    unitId?: true
    meterNo?: true
    readingSetup?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMeterNumberCountAggregateInputType = {
    id?: true
    unitId?: true
    meterNo?: true
    readingSetup?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitMeterNumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitMeterNumber to aggregate.
     */
    where?: UnitMeterNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMeterNumbers to fetch.
     */
    orderBy?: UnitMeterNumberOrderByWithRelationInput | UnitMeterNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitMeterNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMeterNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMeterNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitMeterNumbers
    **/
    _count?: true | UnitMeterNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMeterNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMeterNumberMaxAggregateInputType
  }

  export type GetUnitMeterNumberAggregateType<T extends UnitMeterNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitMeterNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitMeterNumber[P]>
      : GetScalarType<T[P], AggregateUnitMeterNumber[P]>
  }




  export type UnitMeterNumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitMeterNumberWhereInput
    orderBy?: UnitMeterNumberOrderByWithAggregationInput | UnitMeterNumberOrderByWithAggregationInput[]
    by: UnitMeterNumberScalarFieldEnum[] | UnitMeterNumberScalarFieldEnum
    having?: UnitMeterNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitMeterNumberCountAggregateInputType | true
    _min?: UnitMeterNumberMinAggregateInputType
    _max?: UnitMeterNumberMaxAggregateInputType
  }

  export type UnitMeterNumberGroupByOutputType = {
    id: string
    unitId: string
    meterNo: string
    readingSetup: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitMeterNumberCountAggregateOutputType | null
    _min: UnitMeterNumberMinAggregateOutputType | null
    _max: UnitMeterNumberMaxAggregateOutputType | null
  }

  type GetUnitMeterNumberGroupByPayload<T extends UnitMeterNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitMeterNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitMeterNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitMeterNumberGroupByOutputType[P]>
            : GetScalarType<T[P], UnitMeterNumberGroupByOutputType[P]>
        }
      >
    >


  export type UnitMeterNumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    meterNo?: boolean
    readingSetup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitMeterNumber"]>

  export type UnitMeterNumberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    meterNo?: boolean
    readingSetup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitMeterNumber"]>

  export type UnitMeterNumberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    meterNo?: boolean
    readingSetup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitMeterNumber"]>

  export type UnitMeterNumberSelectScalar = {
    id?: boolean
    unitId?: boolean
    meterNo?: boolean
    readingSetup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitMeterNumberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "meterNo" | "readingSetup" | "createdAt" | "updatedAt", ExtArgs["result"]["unitMeterNumber"]>
  export type UnitMeterNumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitMeterNumberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitMeterNumberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitMeterNumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitMeterNumber"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      meterNo: string
      readingSetup: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitMeterNumber"]>
    composites: {}
  }

  type UnitMeterNumberGetPayload<S extends boolean | null | undefined | UnitMeterNumberDefaultArgs> = $Result.GetResult<Prisma.$UnitMeterNumberPayload, S>

  type UnitMeterNumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitMeterNumberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitMeterNumberCountAggregateInputType | true
    }

  export interface UnitMeterNumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitMeterNumber'], meta: { name: 'UnitMeterNumber' } }
    /**
     * Find zero or one UnitMeterNumber that matches the filter.
     * @param {UnitMeterNumberFindUniqueArgs} args - Arguments to find a UnitMeterNumber
     * @example
     * // Get one UnitMeterNumber
     * const unitMeterNumber = await prisma.unitMeterNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitMeterNumberFindUniqueArgs>(args: SelectSubset<T, UnitMeterNumberFindUniqueArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitMeterNumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitMeterNumberFindUniqueOrThrowArgs} args - Arguments to find a UnitMeterNumber
     * @example
     * // Get one UnitMeterNumber
     * const unitMeterNumber = await prisma.unitMeterNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitMeterNumberFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitMeterNumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitMeterNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMeterNumberFindFirstArgs} args - Arguments to find a UnitMeterNumber
     * @example
     * // Get one UnitMeterNumber
     * const unitMeterNumber = await prisma.unitMeterNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitMeterNumberFindFirstArgs>(args?: SelectSubset<T, UnitMeterNumberFindFirstArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitMeterNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMeterNumberFindFirstOrThrowArgs} args - Arguments to find a UnitMeterNumber
     * @example
     * // Get one UnitMeterNumber
     * const unitMeterNumber = await prisma.unitMeterNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitMeterNumberFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitMeterNumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitMeterNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMeterNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitMeterNumbers
     * const unitMeterNumbers = await prisma.unitMeterNumber.findMany()
     * 
     * // Get first 10 UnitMeterNumbers
     * const unitMeterNumbers = await prisma.unitMeterNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitMeterNumberWithIdOnly = await prisma.unitMeterNumber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitMeterNumberFindManyArgs>(args?: SelectSubset<T, UnitMeterNumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitMeterNumber.
     * @param {UnitMeterNumberCreateArgs} args - Arguments to create a UnitMeterNumber.
     * @example
     * // Create one UnitMeterNumber
     * const UnitMeterNumber = await prisma.unitMeterNumber.create({
     *   data: {
     *     // ... data to create a UnitMeterNumber
     *   }
     * })
     * 
     */
    create<T extends UnitMeterNumberCreateArgs>(args: SelectSubset<T, UnitMeterNumberCreateArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitMeterNumbers.
     * @param {UnitMeterNumberCreateManyArgs} args - Arguments to create many UnitMeterNumbers.
     * @example
     * // Create many UnitMeterNumbers
     * const unitMeterNumber = await prisma.unitMeterNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitMeterNumberCreateManyArgs>(args?: SelectSubset<T, UnitMeterNumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitMeterNumbers and returns the data saved in the database.
     * @param {UnitMeterNumberCreateManyAndReturnArgs} args - Arguments to create many UnitMeterNumbers.
     * @example
     * // Create many UnitMeterNumbers
     * const unitMeterNumber = await prisma.unitMeterNumber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitMeterNumbers and only return the `id`
     * const unitMeterNumberWithIdOnly = await prisma.unitMeterNumber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitMeterNumberCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitMeterNumberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitMeterNumber.
     * @param {UnitMeterNumberDeleteArgs} args - Arguments to delete one UnitMeterNumber.
     * @example
     * // Delete one UnitMeterNumber
     * const UnitMeterNumber = await prisma.unitMeterNumber.delete({
     *   where: {
     *     // ... filter to delete one UnitMeterNumber
     *   }
     * })
     * 
     */
    delete<T extends UnitMeterNumberDeleteArgs>(args: SelectSubset<T, UnitMeterNumberDeleteArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitMeterNumber.
     * @param {UnitMeterNumberUpdateArgs} args - Arguments to update one UnitMeterNumber.
     * @example
     * // Update one UnitMeterNumber
     * const unitMeterNumber = await prisma.unitMeterNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitMeterNumberUpdateArgs>(args: SelectSubset<T, UnitMeterNumberUpdateArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitMeterNumbers.
     * @param {UnitMeterNumberDeleteManyArgs} args - Arguments to filter UnitMeterNumbers to delete.
     * @example
     * // Delete a few UnitMeterNumbers
     * const { count } = await prisma.unitMeterNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitMeterNumberDeleteManyArgs>(args?: SelectSubset<T, UnitMeterNumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitMeterNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMeterNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitMeterNumbers
     * const unitMeterNumber = await prisma.unitMeterNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitMeterNumberUpdateManyArgs>(args: SelectSubset<T, UnitMeterNumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitMeterNumbers and returns the data updated in the database.
     * @param {UnitMeterNumberUpdateManyAndReturnArgs} args - Arguments to update many UnitMeterNumbers.
     * @example
     * // Update many UnitMeterNumbers
     * const unitMeterNumber = await prisma.unitMeterNumber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitMeterNumbers and only return the `id`
     * const unitMeterNumberWithIdOnly = await prisma.unitMeterNumber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitMeterNumberUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitMeterNumberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitMeterNumber.
     * @param {UnitMeterNumberUpsertArgs} args - Arguments to update or create a UnitMeterNumber.
     * @example
     * // Update or create a UnitMeterNumber
     * const unitMeterNumber = await prisma.unitMeterNumber.upsert({
     *   create: {
     *     // ... data to create a UnitMeterNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitMeterNumber we want to update
     *   }
     * })
     */
    upsert<T extends UnitMeterNumberUpsertArgs>(args: SelectSubset<T, UnitMeterNumberUpsertArgs<ExtArgs>>): Prisma__UnitMeterNumberClient<$Result.GetResult<Prisma.$UnitMeterNumberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitMeterNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMeterNumberCountArgs} args - Arguments to filter UnitMeterNumbers to count.
     * @example
     * // Count the number of UnitMeterNumbers
     * const count = await prisma.unitMeterNumber.count({
     *   where: {
     *     // ... the filter for the UnitMeterNumbers we want to count
     *   }
     * })
    **/
    count<T extends UnitMeterNumberCountArgs>(
      args?: Subset<T, UnitMeterNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitMeterNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitMeterNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMeterNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitMeterNumberAggregateArgs>(args: Subset<T, UnitMeterNumberAggregateArgs>): Prisma.PrismaPromise<GetUnitMeterNumberAggregateType<T>>

    /**
     * Group by UnitMeterNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMeterNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitMeterNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitMeterNumberGroupByArgs['orderBy'] }
        : { orderBy?: UnitMeterNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitMeterNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitMeterNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitMeterNumber model
   */
  readonly fields: UnitMeterNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitMeterNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitMeterNumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitMeterNumber model
   */
  interface UnitMeterNumberFieldRefs {
    readonly id: FieldRef<"UnitMeterNumber", 'String'>
    readonly unitId: FieldRef<"UnitMeterNumber", 'String'>
    readonly meterNo: FieldRef<"UnitMeterNumber", 'String'>
    readonly readingSetup: FieldRef<"UnitMeterNumber", 'String'>
    readonly createdAt: FieldRef<"UnitMeterNumber", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitMeterNumber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitMeterNumber findUnique
   */
  export type UnitMeterNumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMeterNumber to fetch.
     */
    where: UnitMeterNumberWhereUniqueInput
  }

  /**
   * UnitMeterNumber findUniqueOrThrow
   */
  export type UnitMeterNumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMeterNumber to fetch.
     */
    where: UnitMeterNumberWhereUniqueInput
  }

  /**
   * UnitMeterNumber findFirst
   */
  export type UnitMeterNumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMeterNumber to fetch.
     */
    where?: UnitMeterNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMeterNumbers to fetch.
     */
    orderBy?: UnitMeterNumberOrderByWithRelationInput | UnitMeterNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitMeterNumbers.
     */
    cursor?: UnitMeterNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMeterNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMeterNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitMeterNumbers.
     */
    distinct?: UnitMeterNumberScalarFieldEnum | UnitMeterNumberScalarFieldEnum[]
  }

  /**
   * UnitMeterNumber findFirstOrThrow
   */
  export type UnitMeterNumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMeterNumber to fetch.
     */
    where?: UnitMeterNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMeterNumbers to fetch.
     */
    orderBy?: UnitMeterNumberOrderByWithRelationInput | UnitMeterNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitMeterNumbers.
     */
    cursor?: UnitMeterNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMeterNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMeterNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitMeterNumbers.
     */
    distinct?: UnitMeterNumberScalarFieldEnum | UnitMeterNumberScalarFieldEnum[]
  }

  /**
   * UnitMeterNumber findMany
   */
  export type UnitMeterNumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMeterNumbers to fetch.
     */
    where?: UnitMeterNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMeterNumbers to fetch.
     */
    orderBy?: UnitMeterNumberOrderByWithRelationInput | UnitMeterNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitMeterNumbers.
     */
    cursor?: UnitMeterNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMeterNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMeterNumbers.
     */
    skip?: number
    distinct?: UnitMeterNumberScalarFieldEnum | UnitMeterNumberScalarFieldEnum[]
  }

  /**
   * UnitMeterNumber create
   */
  export type UnitMeterNumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitMeterNumber.
     */
    data: XOR<UnitMeterNumberCreateInput, UnitMeterNumberUncheckedCreateInput>
  }

  /**
   * UnitMeterNumber createMany
   */
  export type UnitMeterNumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitMeterNumbers.
     */
    data: UnitMeterNumberCreateManyInput | UnitMeterNumberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitMeterNumber createManyAndReturn
   */
  export type UnitMeterNumberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * The data used to create many UnitMeterNumbers.
     */
    data: UnitMeterNumberCreateManyInput | UnitMeterNumberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitMeterNumber update
   */
  export type UnitMeterNumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitMeterNumber.
     */
    data: XOR<UnitMeterNumberUpdateInput, UnitMeterNumberUncheckedUpdateInput>
    /**
     * Choose, which UnitMeterNumber to update.
     */
    where: UnitMeterNumberWhereUniqueInput
  }

  /**
   * UnitMeterNumber updateMany
   */
  export type UnitMeterNumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitMeterNumbers.
     */
    data: XOR<UnitMeterNumberUpdateManyMutationInput, UnitMeterNumberUncheckedUpdateManyInput>
    /**
     * Filter which UnitMeterNumbers to update
     */
    where?: UnitMeterNumberWhereInput
    /**
     * Limit how many UnitMeterNumbers to update.
     */
    limit?: number
  }

  /**
   * UnitMeterNumber updateManyAndReturn
   */
  export type UnitMeterNumberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * The data used to update UnitMeterNumbers.
     */
    data: XOR<UnitMeterNumberUpdateManyMutationInput, UnitMeterNumberUncheckedUpdateManyInput>
    /**
     * Filter which UnitMeterNumbers to update
     */
    where?: UnitMeterNumberWhereInput
    /**
     * Limit how many UnitMeterNumbers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitMeterNumber upsert
   */
  export type UnitMeterNumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitMeterNumber to update in case it exists.
     */
    where: UnitMeterNumberWhereUniqueInput
    /**
     * In case the UnitMeterNumber found by the `where` argument doesn't exist, create a new UnitMeterNumber with this data.
     */
    create: XOR<UnitMeterNumberCreateInput, UnitMeterNumberUncheckedCreateInput>
    /**
     * In case the UnitMeterNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitMeterNumberUpdateInput, UnitMeterNumberUncheckedUpdateInput>
  }

  /**
   * UnitMeterNumber delete
   */
  export type UnitMeterNumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
    /**
     * Filter which UnitMeterNumber to delete.
     */
    where: UnitMeterNumberWhereUniqueInput
  }

  /**
   * UnitMeterNumber deleteMany
   */
  export type UnitMeterNumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitMeterNumbers to delete
     */
    where?: UnitMeterNumberWhereInput
    /**
     * Limit how many UnitMeterNumbers to delete.
     */
    limit?: number
  }

  /**
   * UnitMeterNumber without action
   */
  export type UnitMeterNumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMeterNumber
     */
    select?: UnitMeterNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMeterNumber
     */
    omit?: UnitMeterNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMeterNumberInclude<ExtArgs> | null
  }


  /**
   * Model UnitFeature
   */

  export type AggregateUnitFeature = {
    _count: UnitFeatureCountAggregateOutputType | null
    _min: UnitFeatureMinAggregateOutputType | null
    _max: UnitFeatureMaxAggregateOutputType | null
  }

  export type UnitFeatureMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    name: string | null
    featureType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitFeatureMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    name: string | null
    featureType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitFeatureCountAggregateOutputType = {
    id: number
    unitId: number
    name: number
    featureType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitFeatureMinAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    featureType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitFeatureMaxAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    featureType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitFeatureCountAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    featureType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitFeature to aggregate.
     */
    where?: UnitFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitFeatures to fetch.
     */
    orderBy?: UnitFeatureOrderByWithRelationInput | UnitFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitFeatures
    **/
    _count?: true | UnitFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitFeatureMaxAggregateInputType
  }

  export type GetUnitFeatureAggregateType<T extends UnitFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitFeature[P]>
      : GetScalarType<T[P], AggregateUnitFeature[P]>
  }




  export type UnitFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitFeatureWhereInput
    orderBy?: UnitFeatureOrderByWithAggregationInput | UnitFeatureOrderByWithAggregationInput[]
    by: UnitFeatureScalarFieldEnum[] | UnitFeatureScalarFieldEnum
    having?: UnitFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitFeatureCountAggregateInputType | true
    _min?: UnitFeatureMinAggregateInputType
    _max?: UnitFeatureMaxAggregateInputType
  }

  export type UnitFeatureGroupByOutputType = {
    id: string
    unitId: string
    name: string
    featureType: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitFeatureCountAggregateOutputType | null
    _min: UnitFeatureMinAggregateOutputType | null
    _max: UnitFeatureMaxAggregateOutputType | null
  }

  type GetUnitFeatureGroupByPayload<T extends UnitFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], UnitFeatureGroupByOutputType[P]>
        }
      >
    >


  export type UnitFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    featureType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitFeature"]>

  export type UnitFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    featureType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitFeature"]>

  export type UnitFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    featureType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitFeature"]>

  export type UnitFeatureSelectScalar = {
    id?: boolean
    unitId?: boolean
    name?: boolean
    featureType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "name" | "featureType" | "createdAt" | "updatedAt", ExtArgs["result"]["unitFeature"]>
  export type UnitFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitFeature"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      name: string
      featureType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitFeature"]>
    composites: {}
  }

  type UnitFeatureGetPayload<S extends boolean | null | undefined | UnitFeatureDefaultArgs> = $Result.GetResult<Prisma.$UnitFeaturePayload, S>

  type UnitFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitFeatureCountAggregateInputType | true
    }

  export interface UnitFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitFeature'], meta: { name: 'UnitFeature' } }
    /**
     * Find zero or one UnitFeature that matches the filter.
     * @param {UnitFeatureFindUniqueArgs} args - Arguments to find a UnitFeature
     * @example
     * // Get one UnitFeature
     * const unitFeature = await prisma.unitFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFeatureFindUniqueArgs>(args: SelectSubset<T, UnitFeatureFindUniqueArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFeatureFindUniqueOrThrowArgs} args - Arguments to find a UnitFeature
     * @example
     * // Get one UnitFeature
     * const unitFeature = await prisma.unitFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFeatureFindFirstArgs} args - Arguments to find a UnitFeature
     * @example
     * // Get one UnitFeature
     * const unitFeature = await prisma.unitFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFeatureFindFirstArgs>(args?: SelectSubset<T, UnitFeatureFindFirstArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFeatureFindFirstOrThrowArgs} args - Arguments to find a UnitFeature
     * @example
     * // Get one UnitFeature
     * const unitFeature = await prisma.unitFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitFeatures
     * const unitFeatures = await prisma.unitFeature.findMany()
     * 
     * // Get first 10 UnitFeatures
     * const unitFeatures = await prisma.unitFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitFeatureWithIdOnly = await prisma.unitFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFeatureFindManyArgs>(args?: SelectSubset<T, UnitFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitFeature.
     * @param {UnitFeatureCreateArgs} args - Arguments to create a UnitFeature.
     * @example
     * // Create one UnitFeature
     * const UnitFeature = await prisma.unitFeature.create({
     *   data: {
     *     // ... data to create a UnitFeature
     *   }
     * })
     * 
     */
    create<T extends UnitFeatureCreateArgs>(args: SelectSubset<T, UnitFeatureCreateArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitFeatures.
     * @param {UnitFeatureCreateManyArgs} args - Arguments to create many UnitFeatures.
     * @example
     * // Create many UnitFeatures
     * const unitFeature = await prisma.unitFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitFeatureCreateManyArgs>(args?: SelectSubset<T, UnitFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitFeatures and returns the data saved in the database.
     * @param {UnitFeatureCreateManyAndReturnArgs} args - Arguments to create many UnitFeatures.
     * @example
     * // Create many UnitFeatures
     * const unitFeature = await prisma.unitFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitFeatures and only return the `id`
     * const unitFeatureWithIdOnly = await prisma.unitFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitFeature.
     * @param {UnitFeatureDeleteArgs} args - Arguments to delete one UnitFeature.
     * @example
     * // Delete one UnitFeature
     * const UnitFeature = await prisma.unitFeature.delete({
     *   where: {
     *     // ... filter to delete one UnitFeature
     *   }
     * })
     * 
     */
    delete<T extends UnitFeatureDeleteArgs>(args: SelectSubset<T, UnitFeatureDeleteArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitFeature.
     * @param {UnitFeatureUpdateArgs} args - Arguments to update one UnitFeature.
     * @example
     * // Update one UnitFeature
     * const unitFeature = await prisma.unitFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitFeatureUpdateArgs>(args: SelectSubset<T, UnitFeatureUpdateArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitFeatures.
     * @param {UnitFeatureDeleteManyArgs} args - Arguments to filter UnitFeatures to delete.
     * @example
     * // Delete a few UnitFeatures
     * const { count } = await prisma.unitFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitFeatureDeleteManyArgs>(args?: SelectSubset<T, UnitFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitFeatures
     * const unitFeature = await prisma.unitFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitFeatureUpdateManyArgs>(args: SelectSubset<T, UnitFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitFeatures and returns the data updated in the database.
     * @param {UnitFeatureUpdateManyAndReturnArgs} args - Arguments to update many UnitFeatures.
     * @example
     * // Update many UnitFeatures
     * const unitFeature = await prisma.unitFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitFeatures and only return the `id`
     * const unitFeatureWithIdOnly = await prisma.unitFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitFeature.
     * @param {UnitFeatureUpsertArgs} args - Arguments to update or create a UnitFeature.
     * @example
     * // Update or create a UnitFeature
     * const unitFeature = await prisma.unitFeature.upsert({
     *   create: {
     *     // ... data to create a UnitFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitFeature we want to update
     *   }
     * })
     */
    upsert<T extends UnitFeatureUpsertArgs>(args: SelectSubset<T, UnitFeatureUpsertArgs<ExtArgs>>): Prisma__UnitFeatureClient<$Result.GetResult<Prisma.$UnitFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFeatureCountArgs} args - Arguments to filter UnitFeatures to count.
     * @example
     * // Count the number of UnitFeatures
     * const count = await prisma.unitFeature.count({
     *   where: {
     *     // ... the filter for the UnitFeatures we want to count
     *   }
     * })
    **/
    count<T extends UnitFeatureCountArgs>(
      args?: Subset<T, UnitFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitFeatureAggregateArgs>(args: Subset<T, UnitFeatureAggregateArgs>): Prisma.PrismaPromise<GetUnitFeatureAggregateType<T>>

    /**
     * Group by UnitFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitFeatureGroupByArgs['orderBy'] }
        : { orderBy?: UnitFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitFeature model
   */
  readonly fields: UnitFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitFeature model
   */
  interface UnitFeatureFieldRefs {
    readonly id: FieldRef<"UnitFeature", 'String'>
    readonly unitId: FieldRef<"UnitFeature", 'String'>
    readonly name: FieldRef<"UnitFeature", 'String'>
    readonly featureType: FieldRef<"UnitFeature", 'String'>
    readonly createdAt: FieldRef<"UnitFeature", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitFeature findUnique
   */
  export type UnitFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UnitFeature to fetch.
     */
    where: UnitFeatureWhereUniqueInput
  }

  /**
   * UnitFeature findUniqueOrThrow
   */
  export type UnitFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UnitFeature to fetch.
     */
    where: UnitFeatureWhereUniqueInput
  }

  /**
   * UnitFeature findFirst
   */
  export type UnitFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UnitFeature to fetch.
     */
    where?: UnitFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitFeatures to fetch.
     */
    orderBy?: UnitFeatureOrderByWithRelationInput | UnitFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitFeatures.
     */
    cursor?: UnitFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitFeatures.
     */
    distinct?: UnitFeatureScalarFieldEnum | UnitFeatureScalarFieldEnum[]
  }

  /**
   * UnitFeature findFirstOrThrow
   */
  export type UnitFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UnitFeature to fetch.
     */
    where?: UnitFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitFeatures to fetch.
     */
    orderBy?: UnitFeatureOrderByWithRelationInput | UnitFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitFeatures.
     */
    cursor?: UnitFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitFeatures.
     */
    distinct?: UnitFeatureScalarFieldEnum | UnitFeatureScalarFieldEnum[]
  }

  /**
   * UnitFeature findMany
   */
  export type UnitFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UnitFeatures to fetch.
     */
    where?: UnitFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitFeatures to fetch.
     */
    orderBy?: UnitFeatureOrderByWithRelationInput | UnitFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitFeatures.
     */
    cursor?: UnitFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitFeatures.
     */
    skip?: number
    distinct?: UnitFeatureScalarFieldEnum | UnitFeatureScalarFieldEnum[]
  }

  /**
   * UnitFeature create
   */
  export type UnitFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitFeature.
     */
    data: XOR<UnitFeatureCreateInput, UnitFeatureUncheckedCreateInput>
  }

  /**
   * UnitFeature createMany
   */
  export type UnitFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitFeatures.
     */
    data: UnitFeatureCreateManyInput | UnitFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitFeature createManyAndReturn
   */
  export type UnitFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many UnitFeatures.
     */
    data: UnitFeatureCreateManyInput | UnitFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitFeature update
   */
  export type UnitFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitFeature.
     */
    data: XOR<UnitFeatureUpdateInput, UnitFeatureUncheckedUpdateInput>
    /**
     * Choose, which UnitFeature to update.
     */
    where: UnitFeatureWhereUniqueInput
  }

  /**
   * UnitFeature updateMany
   */
  export type UnitFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitFeatures.
     */
    data: XOR<UnitFeatureUpdateManyMutationInput, UnitFeatureUncheckedUpdateManyInput>
    /**
     * Filter which UnitFeatures to update
     */
    where?: UnitFeatureWhereInput
    /**
     * Limit how many UnitFeatures to update.
     */
    limit?: number
  }

  /**
   * UnitFeature updateManyAndReturn
   */
  export type UnitFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * The data used to update UnitFeatures.
     */
    data: XOR<UnitFeatureUpdateManyMutationInput, UnitFeatureUncheckedUpdateManyInput>
    /**
     * Filter which UnitFeatures to update
     */
    where?: UnitFeatureWhereInput
    /**
     * Limit how many UnitFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitFeature upsert
   */
  export type UnitFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitFeature to update in case it exists.
     */
    where: UnitFeatureWhereUniqueInput
    /**
     * In case the UnitFeature found by the `where` argument doesn't exist, create a new UnitFeature with this data.
     */
    create: XOR<UnitFeatureCreateInput, UnitFeatureUncheckedCreateInput>
    /**
     * In case the UnitFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitFeatureUpdateInput, UnitFeatureUncheckedUpdateInput>
  }

  /**
   * UnitFeature delete
   */
  export type UnitFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
    /**
     * Filter which UnitFeature to delete.
     */
    where: UnitFeatureWhereUniqueInput
  }

  /**
   * UnitFeature deleteMany
   */
  export type UnitFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitFeatures to delete
     */
    where?: UnitFeatureWhereInput
    /**
     * Limit how many UnitFeatures to delete.
     */
    limit?: number
  }

  /**
   * UnitFeature without action
   */
  export type UnitFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitFeature
     */
    select?: UnitFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitFeature
     */
    omit?: UnitFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitFeatureInclude<ExtArgs> | null
  }


  /**
   * Model PropertyStandingCharge
   */

  export type AggregatePropertyStandingCharge = {
    _count: PropertyStandingChargeCountAggregateOutputType | null
    _avg: PropertyStandingChargeAvgAggregateOutputType | null
    _sum: PropertyStandingChargeSumAggregateOutputType | null
    _min: PropertyStandingChargeMinAggregateOutputType | null
    _max: PropertyStandingChargeMaxAggregateOutputType | null
  }

  export type PropertyStandingChargeAvgAggregateOutputType = {
    costPerArea: Decimal | null
    chargeValue: Decimal | null
    vatRate: Decimal | null
  }

  export type PropertyStandingChargeSumAggregateOutputType = {
    costPerArea: Decimal | null
    chargeValue: Decimal | null
    vatRate: Decimal | null
  }

  export type PropertyStandingChargeMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    chargeUtility: string | null
    chargeMode: string | null
    billingCurrency: string | null
    costPerArea: Decimal | null
    chargeValue: Decimal | null
    vatRate: Decimal | null
    excludesWithRent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyStandingChargeMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    chargeUtility: string | null
    chargeMode: string | null
    billingCurrency: string | null
    costPerArea: Decimal | null
    chargeValue: Decimal | null
    vatRate: Decimal | null
    excludesWithRent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyStandingChargeCountAggregateOutputType = {
    id: number
    propertyId: number
    chargeUtility: number
    chargeMode: number
    billingCurrency: number
    costPerArea: number
    chargeValue: number
    vatRate: number
    excludesWithRent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyStandingChargeAvgAggregateInputType = {
    costPerArea?: true
    chargeValue?: true
    vatRate?: true
  }

  export type PropertyStandingChargeSumAggregateInputType = {
    costPerArea?: true
    chargeValue?: true
    vatRate?: true
  }

  export type PropertyStandingChargeMinAggregateInputType = {
    id?: true
    propertyId?: true
    chargeUtility?: true
    chargeMode?: true
    billingCurrency?: true
    costPerArea?: true
    chargeValue?: true
    vatRate?: true
    excludesWithRent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyStandingChargeMaxAggregateInputType = {
    id?: true
    propertyId?: true
    chargeUtility?: true
    chargeMode?: true
    billingCurrency?: true
    costPerArea?: true
    chargeValue?: true
    vatRate?: true
    excludesWithRent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyStandingChargeCountAggregateInputType = {
    id?: true
    propertyId?: true
    chargeUtility?: true
    chargeMode?: true
    billingCurrency?: true
    costPerArea?: true
    chargeValue?: true
    vatRate?: true
    excludesWithRent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyStandingChargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyStandingCharge to aggregate.
     */
    where?: PropertyStandingChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStandingCharges to fetch.
     */
    orderBy?: PropertyStandingChargeOrderByWithRelationInput | PropertyStandingChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyStandingChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStandingCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStandingCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyStandingCharges
    **/
    _count?: true | PropertyStandingChargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyStandingChargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyStandingChargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyStandingChargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyStandingChargeMaxAggregateInputType
  }

  export type GetPropertyStandingChargeAggregateType<T extends PropertyStandingChargeAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyStandingCharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyStandingCharge[P]>
      : GetScalarType<T[P], AggregatePropertyStandingCharge[P]>
  }




  export type PropertyStandingChargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStandingChargeWhereInput
    orderBy?: PropertyStandingChargeOrderByWithAggregationInput | PropertyStandingChargeOrderByWithAggregationInput[]
    by: PropertyStandingChargeScalarFieldEnum[] | PropertyStandingChargeScalarFieldEnum
    having?: PropertyStandingChargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyStandingChargeCountAggregateInputType | true
    _avg?: PropertyStandingChargeAvgAggregateInputType
    _sum?: PropertyStandingChargeSumAggregateInputType
    _min?: PropertyStandingChargeMinAggregateInputType
    _max?: PropertyStandingChargeMaxAggregateInputType
  }

  export type PropertyStandingChargeGroupByOutputType = {
    id: string
    propertyId: string
    chargeUtility: string
    chargeMode: string
    billingCurrency: string
    costPerArea: Decimal | null
    chargeValue: Decimal
    vatRate: Decimal | null
    excludesWithRent: boolean
    createdAt: Date
    updatedAt: Date
    _count: PropertyStandingChargeCountAggregateOutputType | null
    _avg: PropertyStandingChargeAvgAggregateOutputType | null
    _sum: PropertyStandingChargeSumAggregateOutputType | null
    _min: PropertyStandingChargeMinAggregateOutputType | null
    _max: PropertyStandingChargeMaxAggregateOutputType | null
  }

  type GetPropertyStandingChargeGroupByPayload<T extends PropertyStandingChargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyStandingChargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyStandingChargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyStandingChargeGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyStandingChargeGroupByOutputType[P]>
        }
      >
    >


  export type PropertyStandingChargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    chargeUtility?: boolean
    chargeMode?: boolean
    billingCurrency?: boolean
    costPerArea?: boolean
    chargeValue?: boolean
    vatRate?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStandingCharge"]>

  export type PropertyStandingChargeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    chargeUtility?: boolean
    chargeMode?: boolean
    billingCurrency?: boolean
    costPerArea?: boolean
    chargeValue?: boolean
    vatRate?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStandingCharge"]>

  export type PropertyStandingChargeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    chargeUtility?: boolean
    chargeMode?: boolean
    billingCurrency?: boolean
    costPerArea?: boolean
    chargeValue?: boolean
    vatRate?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStandingCharge"]>

  export type PropertyStandingChargeSelectScalar = {
    id?: boolean
    propertyId?: boolean
    chargeUtility?: boolean
    chargeMode?: boolean
    billingCurrency?: boolean
    costPerArea?: boolean
    chargeValue?: boolean
    vatRate?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyStandingChargeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "chargeUtility" | "chargeMode" | "billingCurrency" | "costPerArea" | "chargeValue" | "vatRate" | "excludesWithRent" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyStandingCharge"]>
  export type PropertyStandingChargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyStandingChargeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyStandingChargeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyStandingChargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyStandingCharge"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      chargeUtility: string
      chargeMode: string
      billingCurrency: string
      costPerArea: Prisma.Decimal | null
      chargeValue: Prisma.Decimal
      vatRate: Prisma.Decimal | null
      excludesWithRent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyStandingCharge"]>
    composites: {}
  }

  type PropertyStandingChargeGetPayload<S extends boolean | null | undefined | PropertyStandingChargeDefaultArgs> = $Result.GetResult<Prisma.$PropertyStandingChargePayload, S>

  type PropertyStandingChargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyStandingChargeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyStandingChargeCountAggregateInputType | true
    }

  export interface PropertyStandingChargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyStandingCharge'], meta: { name: 'PropertyStandingCharge' } }
    /**
     * Find zero or one PropertyStandingCharge that matches the filter.
     * @param {PropertyStandingChargeFindUniqueArgs} args - Arguments to find a PropertyStandingCharge
     * @example
     * // Get one PropertyStandingCharge
     * const propertyStandingCharge = await prisma.propertyStandingCharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyStandingChargeFindUniqueArgs>(args: SelectSubset<T, PropertyStandingChargeFindUniqueArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyStandingCharge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyStandingChargeFindUniqueOrThrowArgs} args - Arguments to find a PropertyStandingCharge
     * @example
     * // Get one PropertyStandingCharge
     * const propertyStandingCharge = await prisma.propertyStandingCharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyStandingChargeFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyStandingChargeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyStandingCharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStandingChargeFindFirstArgs} args - Arguments to find a PropertyStandingCharge
     * @example
     * // Get one PropertyStandingCharge
     * const propertyStandingCharge = await prisma.propertyStandingCharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyStandingChargeFindFirstArgs>(args?: SelectSubset<T, PropertyStandingChargeFindFirstArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyStandingCharge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStandingChargeFindFirstOrThrowArgs} args - Arguments to find a PropertyStandingCharge
     * @example
     * // Get one PropertyStandingCharge
     * const propertyStandingCharge = await prisma.propertyStandingCharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyStandingChargeFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyStandingChargeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyStandingCharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStandingChargeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyStandingCharges
     * const propertyStandingCharges = await prisma.propertyStandingCharge.findMany()
     * 
     * // Get first 10 PropertyStandingCharges
     * const propertyStandingCharges = await prisma.propertyStandingCharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyStandingChargeWithIdOnly = await prisma.propertyStandingCharge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyStandingChargeFindManyArgs>(args?: SelectSubset<T, PropertyStandingChargeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyStandingCharge.
     * @param {PropertyStandingChargeCreateArgs} args - Arguments to create a PropertyStandingCharge.
     * @example
     * // Create one PropertyStandingCharge
     * const PropertyStandingCharge = await prisma.propertyStandingCharge.create({
     *   data: {
     *     // ... data to create a PropertyStandingCharge
     *   }
     * })
     * 
     */
    create<T extends PropertyStandingChargeCreateArgs>(args: SelectSubset<T, PropertyStandingChargeCreateArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyStandingCharges.
     * @param {PropertyStandingChargeCreateManyArgs} args - Arguments to create many PropertyStandingCharges.
     * @example
     * // Create many PropertyStandingCharges
     * const propertyStandingCharge = await prisma.propertyStandingCharge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyStandingChargeCreateManyArgs>(args?: SelectSubset<T, PropertyStandingChargeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyStandingCharges and returns the data saved in the database.
     * @param {PropertyStandingChargeCreateManyAndReturnArgs} args - Arguments to create many PropertyStandingCharges.
     * @example
     * // Create many PropertyStandingCharges
     * const propertyStandingCharge = await prisma.propertyStandingCharge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyStandingCharges and only return the `id`
     * const propertyStandingChargeWithIdOnly = await prisma.propertyStandingCharge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyStandingChargeCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyStandingChargeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyStandingCharge.
     * @param {PropertyStandingChargeDeleteArgs} args - Arguments to delete one PropertyStandingCharge.
     * @example
     * // Delete one PropertyStandingCharge
     * const PropertyStandingCharge = await prisma.propertyStandingCharge.delete({
     *   where: {
     *     // ... filter to delete one PropertyStandingCharge
     *   }
     * })
     * 
     */
    delete<T extends PropertyStandingChargeDeleteArgs>(args: SelectSubset<T, PropertyStandingChargeDeleteArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyStandingCharge.
     * @param {PropertyStandingChargeUpdateArgs} args - Arguments to update one PropertyStandingCharge.
     * @example
     * // Update one PropertyStandingCharge
     * const propertyStandingCharge = await prisma.propertyStandingCharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyStandingChargeUpdateArgs>(args: SelectSubset<T, PropertyStandingChargeUpdateArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyStandingCharges.
     * @param {PropertyStandingChargeDeleteManyArgs} args - Arguments to filter PropertyStandingCharges to delete.
     * @example
     * // Delete a few PropertyStandingCharges
     * const { count } = await prisma.propertyStandingCharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyStandingChargeDeleteManyArgs>(args?: SelectSubset<T, PropertyStandingChargeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyStandingCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStandingChargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyStandingCharges
     * const propertyStandingCharge = await prisma.propertyStandingCharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyStandingChargeUpdateManyArgs>(args: SelectSubset<T, PropertyStandingChargeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyStandingCharges and returns the data updated in the database.
     * @param {PropertyStandingChargeUpdateManyAndReturnArgs} args - Arguments to update many PropertyStandingCharges.
     * @example
     * // Update many PropertyStandingCharges
     * const propertyStandingCharge = await prisma.propertyStandingCharge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyStandingCharges and only return the `id`
     * const propertyStandingChargeWithIdOnly = await prisma.propertyStandingCharge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyStandingChargeUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyStandingChargeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyStandingCharge.
     * @param {PropertyStandingChargeUpsertArgs} args - Arguments to update or create a PropertyStandingCharge.
     * @example
     * // Update or create a PropertyStandingCharge
     * const propertyStandingCharge = await prisma.propertyStandingCharge.upsert({
     *   create: {
     *     // ... data to create a PropertyStandingCharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyStandingCharge we want to update
     *   }
     * })
     */
    upsert<T extends PropertyStandingChargeUpsertArgs>(args: SelectSubset<T, PropertyStandingChargeUpsertArgs<ExtArgs>>): Prisma__PropertyStandingChargeClient<$Result.GetResult<Prisma.$PropertyStandingChargePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyStandingCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStandingChargeCountArgs} args - Arguments to filter PropertyStandingCharges to count.
     * @example
     * // Count the number of PropertyStandingCharges
     * const count = await prisma.propertyStandingCharge.count({
     *   where: {
     *     // ... the filter for the PropertyStandingCharges we want to count
     *   }
     * })
    **/
    count<T extends PropertyStandingChargeCountArgs>(
      args?: Subset<T, PropertyStandingChargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyStandingChargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyStandingCharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStandingChargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyStandingChargeAggregateArgs>(args: Subset<T, PropertyStandingChargeAggregateArgs>): Prisma.PrismaPromise<GetPropertyStandingChargeAggregateType<T>>

    /**
     * Group by PropertyStandingCharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStandingChargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyStandingChargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyStandingChargeGroupByArgs['orderBy'] }
        : { orderBy?: PropertyStandingChargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyStandingChargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyStandingChargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyStandingCharge model
   */
  readonly fields: PropertyStandingChargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyStandingCharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyStandingChargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyStandingCharge model
   */
  interface PropertyStandingChargeFieldRefs {
    readonly id: FieldRef<"PropertyStandingCharge", 'String'>
    readonly propertyId: FieldRef<"PropertyStandingCharge", 'String'>
    readonly chargeUtility: FieldRef<"PropertyStandingCharge", 'String'>
    readonly chargeMode: FieldRef<"PropertyStandingCharge", 'String'>
    readonly billingCurrency: FieldRef<"PropertyStandingCharge", 'String'>
    readonly costPerArea: FieldRef<"PropertyStandingCharge", 'Decimal'>
    readonly chargeValue: FieldRef<"PropertyStandingCharge", 'Decimal'>
    readonly vatRate: FieldRef<"PropertyStandingCharge", 'Decimal'>
    readonly excludesWithRent: FieldRef<"PropertyStandingCharge", 'Boolean'>
    readonly createdAt: FieldRef<"PropertyStandingCharge", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyStandingCharge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyStandingCharge findUnique
   */
  export type PropertyStandingChargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStandingCharge to fetch.
     */
    where: PropertyStandingChargeWhereUniqueInput
  }

  /**
   * PropertyStandingCharge findUniqueOrThrow
   */
  export type PropertyStandingChargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStandingCharge to fetch.
     */
    where: PropertyStandingChargeWhereUniqueInput
  }

  /**
   * PropertyStandingCharge findFirst
   */
  export type PropertyStandingChargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStandingCharge to fetch.
     */
    where?: PropertyStandingChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStandingCharges to fetch.
     */
    orderBy?: PropertyStandingChargeOrderByWithRelationInput | PropertyStandingChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyStandingCharges.
     */
    cursor?: PropertyStandingChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStandingCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStandingCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyStandingCharges.
     */
    distinct?: PropertyStandingChargeScalarFieldEnum | PropertyStandingChargeScalarFieldEnum[]
  }

  /**
   * PropertyStandingCharge findFirstOrThrow
   */
  export type PropertyStandingChargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStandingCharge to fetch.
     */
    where?: PropertyStandingChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStandingCharges to fetch.
     */
    orderBy?: PropertyStandingChargeOrderByWithRelationInput | PropertyStandingChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyStandingCharges.
     */
    cursor?: PropertyStandingChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStandingCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStandingCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyStandingCharges.
     */
    distinct?: PropertyStandingChargeScalarFieldEnum | PropertyStandingChargeScalarFieldEnum[]
  }

  /**
   * PropertyStandingCharge findMany
   */
  export type PropertyStandingChargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStandingCharges to fetch.
     */
    where?: PropertyStandingChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStandingCharges to fetch.
     */
    orderBy?: PropertyStandingChargeOrderByWithRelationInput | PropertyStandingChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyStandingCharges.
     */
    cursor?: PropertyStandingChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStandingCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStandingCharges.
     */
    skip?: number
    distinct?: PropertyStandingChargeScalarFieldEnum | PropertyStandingChargeScalarFieldEnum[]
  }

  /**
   * PropertyStandingCharge create
   */
  export type PropertyStandingChargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyStandingCharge.
     */
    data: XOR<PropertyStandingChargeCreateInput, PropertyStandingChargeUncheckedCreateInput>
  }

  /**
   * PropertyStandingCharge createMany
   */
  export type PropertyStandingChargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyStandingCharges.
     */
    data: PropertyStandingChargeCreateManyInput | PropertyStandingChargeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyStandingCharge createManyAndReturn
   */
  export type PropertyStandingChargeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyStandingCharges.
     */
    data: PropertyStandingChargeCreateManyInput | PropertyStandingChargeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyStandingCharge update
   */
  export type PropertyStandingChargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyStandingCharge.
     */
    data: XOR<PropertyStandingChargeUpdateInput, PropertyStandingChargeUncheckedUpdateInput>
    /**
     * Choose, which PropertyStandingCharge to update.
     */
    where: PropertyStandingChargeWhereUniqueInput
  }

  /**
   * PropertyStandingCharge updateMany
   */
  export type PropertyStandingChargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyStandingCharges.
     */
    data: XOR<PropertyStandingChargeUpdateManyMutationInput, PropertyStandingChargeUncheckedUpdateManyInput>
    /**
     * Filter which PropertyStandingCharges to update
     */
    where?: PropertyStandingChargeWhereInput
    /**
     * Limit how many PropertyStandingCharges to update.
     */
    limit?: number
  }

  /**
   * PropertyStandingCharge updateManyAndReturn
   */
  export type PropertyStandingChargeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * The data used to update PropertyStandingCharges.
     */
    data: XOR<PropertyStandingChargeUpdateManyMutationInput, PropertyStandingChargeUncheckedUpdateManyInput>
    /**
     * Filter which PropertyStandingCharges to update
     */
    where?: PropertyStandingChargeWhereInput
    /**
     * Limit how many PropertyStandingCharges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyStandingCharge upsert
   */
  export type PropertyStandingChargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyStandingCharge to update in case it exists.
     */
    where: PropertyStandingChargeWhereUniqueInput
    /**
     * In case the PropertyStandingCharge found by the `where` argument doesn't exist, create a new PropertyStandingCharge with this data.
     */
    create: XOR<PropertyStandingChargeCreateInput, PropertyStandingChargeUncheckedCreateInput>
    /**
     * In case the PropertyStandingCharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyStandingChargeUpdateInput, PropertyStandingChargeUncheckedUpdateInput>
  }

  /**
   * PropertyStandingCharge delete
   */
  export type PropertyStandingChargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
    /**
     * Filter which PropertyStandingCharge to delete.
     */
    where: PropertyStandingChargeWhereUniqueInput
  }

  /**
   * PropertyStandingCharge deleteMany
   */
  export type PropertyStandingChargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyStandingCharges to delete
     */
    where?: PropertyStandingChargeWhereInput
    /**
     * Limit how many PropertyStandingCharges to delete.
     */
    limit?: number
  }

  /**
   * PropertyStandingCharge without action
   */
  export type PropertyStandingChargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStandingCharge
     */
    select?: PropertyStandingChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStandingCharge
     */
    omit?: PropertyStandingChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStandingChargeInclude<ExtArgs> | null
  }


  /**
   * Model PropertySecurityDeposit
   */

  export type AggregatePropertySecurityDeposit = {
    _count: PropertySecurityDepositCountAggregateOutputType | null
    _avg: PropertySecurityDepositAvgAggregateOutputType | null
    _sum: PropertySecurityDepositSumAggregateOutputType | null
    _min: PropertySecurityDepositMinAggregateOutputType | null
    _max: PropertySecurityDepositMaxAggregateOutputType | null
  }

  export type PropertySecurityDepositAvgAggregateOutputType = {
    value: Decimal | null
  }

  export type PropertySecurityDepositSumAggregateOutputType = {
    value: Decimal | null
  }

  export type PropertySecurityDepositMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    month: string | null
    value: Decimal | null
    ofRentBillingAmount: boolean | null
    ofInitialRent: boolean | null
    ofLastEscalation: boolean | null
    excludesWithRent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySecurityDepositMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    month: string | null
    value: Decimal | null
    ofRentBillingAmount: boolean | null
    ofInitialRent: boolean | null
    ofLastEscalation: boolean | null
    excludesWithRent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySecurityDepositCountAggregateOutputType = {
    id: number
    propertyId: number
    month: number
    value: number
    ofRentBillingAmount: number
    ofInitialRent: number
    ofLastEscalation: number
    excludesWithRent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertySecurityDepositAvgAggregateInputType = {
    value?: true
  }

  export type PropertySecurityDepositSumAggregateInputType = {
    value?: true
  }

  export type PropertySecurityDepositMinAggregateInputType = {
    id?: true
    propertyId?: true
    month?: true
    value?: true
    ofRentBillingAmount?: true
    ofInitialRent?: true
    ofLastEscalation?: true
    excludesWithRent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySecurityDepositMaxAggregateInputType = {
    id?: true
    propertyId?: true
    month?: true
    value?: true
    ofRentBillingAmount?: true
    ofInitialRent?: true
    ofLastEscalation?: true
    excludesWithRent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySecurityDepositCountAggregateInputType = {
    id?: true
    propertyId?: true
    month?: true
    value?: true
    ofRentBillingAmount?: true
    ofInitialRent?: true
    ofLastEscalation?: true
    excludesWithRent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertySecurityDepositAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySecurityDeposit to aggregate.
     */
    where?: PropertySecurityDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySecurityDeposits to fetch.
     */
    orderBy?: PropertySecurityDepositOrderByWithRelationInput | PropertySecurityDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertySecurityDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySecurityDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySecurityDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertySecurityDeposits
    **/
    _count?: true | PropertySecurityDepositCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertySecurityDepositAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySecurityDepositSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertySecurityDepositMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertySecurityDepositMaxAggregateInputType
  }

  export type GetPropertySecurityDepositAggregateType<T extends PropertySecurityDepositAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertySecurityDeposit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertySecurityDeposit[P]>
      : GetScalarType<T[P], AggregatePropertySecurityDeposit[P]>
  }




  export type PropertySecurityDepositGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySecurityDepositWhereInput
    orderBy?: PropertySecurityDepositOrderByWithAggregationInput | PropertySecurityDepositOrderByWithAggregationInput[]
    by: PropertySecurityDepositScalarFieldEnum[] | PropertySecurityDepositScalarFieldEnum
    having?: PropertySecurityDepositScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertySecurityDepositCountAggregateInputType | true
    _avg?: PropertySecurityDepositAvgAggregateInputType
    _sum?: PropertySecurityDepositSumAggregateInputType
    _min?: PropertySecurityDepositMinAggregateInputType
    _max?: PropertySecurityDepositMaxAggregateInputType
  }

  export type PropertySecurityDepositGroupByOutputType = {
    id: string
    propertyId: string
    month: string
    value: Decimal
    ofRentBillingAmount: boolean
    ofInitialRent: boolean
    ofLastEscalation: boolean
    excludesWithRent: boolean
    createdAt: Date
    updatedAt: Date
    _count: PropertySecurityDepositCountAggregateOutputType | null
    _avg: PropertySecurityDepositAvgAggregateOutputType | null
    _sum: PropertySecurityDepositSumAggregateOutputType | null
    _min: PropertySecurityDepositMinAggregateOutputType | null
    _max: PropertySecurityDepositMaxAggregateOutputType | null
  }

  type GetPropertySecurityDepositGroupByPayload<T extends PropertySecurityDepositGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertySecurityDepositGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertySecurityDepositGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertySecurityDepositGroupByOutputType[P]>
            : GetScalarType<T[P], PropertySecurityDepositGroupByOutputType[P]>
        }
      >
    >


  export type PropertySecurityDepositSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    month?: boolean
    value?: boolean
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySecurityDeposit"]>

  export type PropertySecurityDepositSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    month?: boolean
    value?: boolean
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySecurityDeposit"]>

  export type PropertySecurityDepositSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    month?: boolean
    value?: boolean
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySecurityDeposit"]>

  export type PropertySecurityDepositSelectScalar = {
    id?: boolean
    propertyId?: boolean
    month?: boolean
    value?: boolean
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertySecurityDepositOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "month" | "value" | "ofRentBillingAmount" | "ofInitialRent" | "ofLastEscalation" | "excludesWithRent" | "createdAt" | "updatedAt", ExtArgs["result"]["propertySecurityDeposit"]>
  export type PropertySecurityDepositInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertySecurityDepositIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertySecurityDepositIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertySecurityDepositPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertySecurityDeposit"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      month: string
      value: Prisma.Decimal
      ofRentBillingAmount: boolean
      ofInitialRent: boolean
      ofLastEscalation: boolean
      excludesWithRent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertySecurityDeposit"]>
    composites: {}
  }

  type PropertySecurityDepositGetPayload<S extends boolean | null | undefined | PropertySecurityDepositDefaultArgs> = $Result.GetResult<Prisma.$PropertySecurityDepositPayload, S>

  type PropertySecurityDepositCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertySecurityDepositFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertySecurityDepositCountAggregateInputType | true
    }

  export interface PropertySecurityDepositDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertySecurityDeposit'], meta: { name: 'PropertySecurityDeposit' } }
    /**
     * Find zero or one PropertySecurityDeposit that matches the filter.
     * @param {PropertySecurityDepositFindUniqueArgs} args - Arguments to find a PropertySecurityDeposit
     * @example
     * // Get one PropertySecurityDeposit
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertySecurityDepositFindUniqueArgs>(args: SelectSubset<T, PropertySecurityDepositFindUniqueArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertySecurityDeposit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertySecurityDepositFindUniqueOrThrowArgs} args - Arguments to find a PropertySecurityDeposit
     * @example
     * // Get one PropertySecurityDeposit
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertySecurityDepositFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertySecurityDepositFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySecurityDeposit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySecurityDepositFindFirstArgs} args - Arguments to find a PropertySecurityDeposit
     * @example
     * // Get one PropertySecurityDeposit
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertySecurityDepositFindFirstArgs>(args?: SelectSubset<T, PropertySecurityDepositFindFirstArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySecurityDeposit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySecurityDepositFindFirstOrThrowArgs} args - Arguments to find a PropertySecurityDeposit
     * @example
     * // Get one PropertySecurityDeposit
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertySecurityDepositFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertySecurityDepositFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertySecurityDeposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySecurityDepositFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertySecurityDeposits
     * const propertySecurityDeposits = await prisma.propertySecurityDeposit.findMany()
     * 
     * // Get first 10 PropertySecurityDeposits
     * const propertySecurityDeposits = await prisma.propertySecurityDeposit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertySecurityDepositWithIdOnly = await prisma.propertySecurityDeposit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertySecurityDepositFindManyArgs>(args?: SelectSubset<T, PropertySecurityDepositFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertySecurityDeposit.
     * @param {PropertySecurityDepositCreateArgs} args - Arguments to create a PropertySecurityDeposit.
     * @example
     * // Create one PropertySecurityDeposit
     * const PropertySecurityDeposit = await prisma.propertySecurityDeposit.create({
     *   data: {
     *     // ... data to create a PropertySecurityDeposit
     *   }
     * })
     * 
     */
    create<T extends PropertySecurityDepositCreateArgs>(args: SelectSubset<T, PropertySecurityDepositCreateArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertySecurityDeposits.
     * @param {PropertySecurityDepositCreateManyArgs} args - Arguments to create many PropertySecurityDeposits.
     * @example
     * // Create many PropertySecurityDeposits
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertySecurityDepositCreateManyArgs>(args?: SelectSubset<T, PropertySecurityDepositCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertySecurityDeposits and returns the data saved in the database.
     * @param {PropertySecurityDepositCreateManyAndReturnArgs} args - Arguments to create many PropertySecurityDeposits.
     * @example
     * // Create many PropertySecurityDeposits
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertySecurityDeposits and only return the `id`
     * const propertySecurityDepositWithIdOnly = await prisma.propertySecurityDeposit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertySecurityDepositCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertySecurityDepositCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertySecurityDeposit.
     * @param {PropertySecurityDepositDeleteArgs} args - Arguments to delete one PropertySecurityDeposit.
     * @example
     * // Delete one PropertySecurityDeposit
     * const PropertySecurityDeposit = await prisma.propertySecurityDeposit.delete({
     *   where: {
     *     // ... filter to delete one PropertySecurityDeposit
     *   }
     * })
     * 
     */
    delete<T extends PropertySecurityDepositDeleteArgs>(args: SelectSubset<T, PropertySecurityDepositDeleteArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertySecurityDeposit.
     * @param {PropertySecurityDepositUpdateArgs} args - Arguments to update one PropertySecurityDeposit.
     * @example
     * // Update one PropertySecurityDeposit
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertySecurityDepositUpdateArgs>(args: SelectSubset<T, PropertySecurityDepositUpdateArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertySecurityDeposits.
     * @param {PropertySecurityDepositDeleteManyArgs} args - Arguments to filter PropertySecurityDeposits to delete.
     * @example
     * // Delete a few PropertySecurityDeposits
     * const { count } = await prisma.propertySecurityDeposit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertySecurityDepositDeleteManyArgs>(args?: SelectSubset<T, PropertySecurityDepositDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySecurityDeposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySecurityDepositUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertySecurityDeposits
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertySecurityDepositUpdateManyArgs>(args: SelectSubset<T, PropertySecurityDepositUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySecurityDeposits and returns the data updated in the database.
     * @param {PropertySecurityDepositUpdateManyAndReturnArgs} args - Arguments to update many PropertySecurityDeposits.
     * @example
     * // Update many PropertySecurityDeposits
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertySecurityDeposits and only return the `id`
     * const propertySecurityDepositWithIdOnly = await prisma.propertySecurityDeposit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertySecurityDepositUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertySecurityDepositUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertySecurityDeposit.
     * @param {PropertySecurityDepositUpsertArgs} args - Arguments to update or create a PropertySecurityDeposit.
     * @example
     * // Update or create a PropertySecurityDeposit
     * const propertySecurityDeposit = await prisma.propertySecurityDeposit.upsert({
     *   create: {
     *     // ... data to create a PropertySecurityDeposit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertySecurityDeposit we want to update
     *   }
     * })
     */
    upsert<T extends PropertySecurityDepositUpsertArgs>(args: SelectSubset<T, PropertySecurityDepositUpsertArgs<ExtArgs>>): Prisma__PropertySecurityDepositClient<$Result.GetResult<Prisma.$PropertySecurityDepositPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertySecurityDeposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySecurityDepositCountArgs} args - Arguments to filter PropertySecurityDeposits to count.
     * @example
     * // Count the number of PropertySecurityDeposits
     * const count = await prisma.propertySecurityDeposit.count({
     *   where: {
     *     // ... the filter for the PropertySecurityDeposits we want to count
     *   }
     * })
    **/
    count<T extends PropertySecurityDepositCountArgs>(
      args?: Subset<T, PropertySecurityDepositCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertySecurityDepositCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertySecurityDeposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySecurityDepositAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertySecurityDepositAggregateArgs>(args: Subset<T, PropertySecurityDepositAggregateArgs>): Prisma.PrismaPromise<GetPropertySecurityDepositAggregateType<T>>

    /**
     * Group by PropertySecurityDeposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySecurityDepositGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertySecurityDepositGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertySecurityDepositGroupByArgs['orderBy'] }
        : { orderBy?: PropertySecurityDepositGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertySecurityDepositGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertySecurityDepositGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertySecurityDeposit model
   */
  readonly fields: PropertySecurityDepositFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertySecurityDeposit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertySecurityDepositClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertySecurityDeposit model
   */
  interface PropertySecurityDepositFieldRefs {
    readonly id: FieldRef<"PropertySecurityDeposit", 'String'>
    readonly propertyId: FieldRef<"PropertySecurityDeposit", 'String'>
    readonly month: FieldRef<"PropertySecurityDeposit", 'String'>
    readonly value: FieldRef<"PropertySecurityDeposit", 'Decimal'>
    readonly ofRentBillingAmount: FieldRef<"PropertySecurityDeposit", 'Boolean'>
    readonly ofInitialRent: FieldRef<"PropertySecurityDeposit", 'Boolean'>
    readonly ofLastEscalation: FieldRef<"PropertySecurityDeposit", 'Boolean'>
    readonly excludesWithRent: FieldRef<"PropertySecurityDeposit", 'Boolean'>
    readonly createdAt: FieldRef<"PropertySecurityDeposit", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertySecurityDeposit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertySecurityDeposit findUnique
   */
  export type PropertySecurityDepositFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * Filter, which PropertySecurityDeposit to fetch.
     */
    where: PropertySecurityDepositWhereUniqueInput
  }

  /**
   * PropertySecurityDeposit findUniqueOrThrow
   */
  export type PropertySecurityDepositFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * Filter, which PropertySecurityDeposit to fetch.
     */
    where: PropertySecurityDepositWhereUniqueInput
  }

  /**
   * PropertySecurityDeposit findFirst
   */
  export type PropertySecurityDepositFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * Filter, which PropertySecurityDeposit to fetch.
     */
    where?: PropertySecurityDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySecurityDeposits to fetch.
     */
    orderBy?: PropertySecurityDepositOrderByWithRelationInput | PropertySecurityDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySecurityDeposits.
     */
    cursor?: PropertySecurityDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySecurityDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySecurityDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySecurityDeposits.
     */
    distinct?: PropertySecurityDepositScalarFieldEnum | PropertySecurityDepositScalarFieldEnum[]
  }

  /**
   * PropertySecurityDeposit findFirstOrThrow
   */
  export type PropertySecurityDepositFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * Filter, which PropertySecurityDeposit to fetch.
     */
    where?: PropertySecurityDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySecurityDeposits to fetch.
     */
    orderBy?: PropertySecurityDepositOrderByWithRelationInput | PropertySecurityDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySecurityDeposits.
     */
    cursor?: PropertySecurityDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySecurityDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySecurityDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySecurityDeposits.
     */
    distinct?: PropertySecurityDepositScalarFieldEnum | PropertySecurityDepositScalarFieldEnum[]
  }

  /**
   * PropertySecurityDeposit findMany
   */
  export type PropertySecurityDepositFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * Filter, which PropertySecurityDeposits to fetch.
     */
    where?: PropertySecurityDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySecurityDeposits to fetch.
     */
    orderBy?: PropertySecurityDepositOrderByWithRelationInput | PropertySecurityDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertySecurityDeposits.
     */
    cursor?: PropertySecurityDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySecurityDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySecurityDeposits.
     */
    skip?: number
    distinct?: PropertySecurityDepositScalarFieldEnum | PropertySecurityDepositScalarFieldEnum[]
  }

  /**
   * PropertySecurityDeposit create
   */
  export type PropertySecurityDepositCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertySecurityDeposit.
     */
    data: XOR<PropertySecurityDepositCreateInput, PropertySecurityDepositUncheckedCreateInput>
  }

  /**
   * PropertySecurityDeposit createMany
   */
  export type PropertySecurityDepositCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertySecurityDeposits.
     */
    data: PropertySecurityDepositCreateManyInput | PropertySecurityDepositCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertySecurityDeposit createManyAndReturn
   */
  export type PropertySecurityDepositCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * The data used to create many PropertySecurityDeposits.
     */
    data: PropertySecurityDepositCreateManyInput | PropertySecurityDepositCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySecurityDeposit update
   */
  export type PropertySecurityDepositUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertySecurityDeposit.
     */
    data: XOR<PropertySecurityDepositUpdateInput, PropertySecurityDepositUncheckedUpdateInput>
    /**
     * Choose, which PropertySecurityDeposit to update.
     */
    where: PropertySecurityDepositWhereUniqueInput
  }

  /**
   * PropertySecurityDeposit updateMany
   */
  export type PropertySecurityDepositUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertySecurityDeposits.
     */
    data: XOR<PropertySecurityDepositUpdateManyMutationInput, PropertySecurityDepositUncheckedUpdateManyInput>
    /**
     * Filter which PropertySecurityDeposits to update
     */
    where?: PropertySecurityDepositWhereInput
    /**
     * Limit how many PropertySecurityDeposits to update.
     */
    limit?: number
  }

  /**
   * PropertySecurityDeposit updateManyAndReturn
   */
  export type PropertySecurityDepositUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * The data used to update PropertySecurityDeposits.
     */
    data: XOR<PropertySecurityDepositUpdateManyMutationInput, PropertySecurityDepositUncheckedUpdateManyInput>
    /**
     * Filter which PropertySecurityDeposits to update
     */
    where?: PropertySecurityDepositWhereInput
    /**
     * Limit how many PropertySecurityDeposits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySecurityDeposit upsert
   */
  export type PropertySecurityDepositUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertySecurityDeposit to update in case it exists.
     */
    where: PropertySecurityDepositWhereUniqueInput
    /**
     * In case the PropertySecurityDeposit found by the `where` argument doesn't exist, create a new PropertySecurityDeposit with this data.
     */
    create: XOR<PropertySecurityDepositCreateInput, PropertySecurityDepositUncheckedCreateInput>
    /**
     * In case the PropertySecurityDeposit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertySecurityDepositUpdateInput, PropertySecurityDepositUncheckedUpdateInput>
  }

  /**
   * PropertySecurityDeposit delete
   */
  export type PropertySecurityDepositDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
    /**
     * Filter which PropertySecurityDeposit to delete.
     */
    where: PropertySecurityDepositWhereUniqueInput
  }

  /**
   * PropertySecurityDeposit deleteMany
   */
  export type PropertySecurityDepositDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySecurityDeposits to delete
     */
    where?: PropertySecurityDepositWhereInput
    /**
     * Limit how many PropertySecurityDeposits to delete.
     */
    limit?: number
  }

  /**
   * PropertySecurityDeposit without action
   */
  export type PropertySecurityDepositDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySecurityDeposit
     */
    select?: PropertySecurityDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySecurityDeposit
     */
    omit?: PropertySecurityDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySecurityDepositInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    code: string | null
    tenantType: string | null
    surname: string | null
    otherNames: string | null
    gender: string | null
    email: string | null
    phone: string | null
    town: string | null
    sendMobileNumber: boolean | null
    idNoRegNo: string | null
    taxPin: string | null
    postalAddress: string | null
    postalCode: string | null
    country: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    code: string | null
    tenantType: string | null
    surname: string | null
    otherNames: string | null
    gender: string | null
    email: string | null
    phone: string | null
    town: string | null
    sendMobileNumber: boolean | null
    idNoRegNo: string | null
    taxPin: string | null
    postalAddress: string | null
    postalCode: string | null
    country: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    accountNumber: number
    code: number
    tenantType: number
    surname: number
    otherNames: number
    gender: number
    email: number
    phone: number
    town: number
    sendMobileNumber: number
    idNoRegNo: number
    taxPin: number
    postalAddress: number
    postalCode: number
    country: number
    photoUrl: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    accountNumber?: true
    code?: true
    tenantType?: true
    surname?: true
    otherNames?: true
    gender?: true
    email?: true
    phone?: true
    town?: true
    sendMobileNumber?: true
    idNoRegNo?: true
    taxPin?: true
    postalAddress?: true
    postalCode?: true
    country?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    accountNumber?: true
    code?: true
    tenantType?: true
    surname?: true
    otherNames?: true
    gender?: true
    email?: true
    phone?: true
    town?: true
    sendMobileNumber?: true
    idNoRegNo?: true
    taxPin?: true
    postalAddress?: true
    postalCode?: true
    country?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    accountNumber?: true
    code?: true
    tenantType?: true
    surname?: true
    otherNames?: true
    gender?: true
    email?: true
    phone?: true
    town?: true
    sendMobileNumber?: true
    idNoRegNo?: true
    taxPin?: true
    postalAddress?: true
    postalCode?: true
    country?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    accountNumber: string
    code: string
    tenantType: string | null
    surname: string
    otherNames: string | null
    gender: string | null
    email: string | null
    phone: string
    town: string | null
    sendMobileNumber: boolean
    idNoRegNo: string | null
    taxPin: string | null
    postalAddress: string | null
    postalCode: string | null
    country: string | null
    photoUrl: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    code?: boolean
    tenantType?: boolean
    surname?: boolean
    otherNames?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    town?: boolean
    sendMobileNumber?: boolean
    idNoRegNo?: boolean
    taxPin?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    country?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    leases?: boolean | Tenant$leasesArgs<ExtArgs>
    emergencyContacts?: boolean | Tenant$emergencyContactsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    code?: boolean
    tenantType?: boolean
    surname?: boolean
    otherNames?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    town?: boolean
    sendMobileNumber?: boolean
    idNoRegNo?: boolean
    taxPin?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    country?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    code?: boolean
    tenantType?: boolean
    surname?: boolean
    otherNames?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    town?: boolean
    sendMobileNumber?: boolean
    idNoRegNo?: boolean
    taxPin?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    country?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    accountNumber?: boolean
    code?: boolean
    tenantType?: boolean
    surname?: boolean
    otherNames?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    town?: boolean
    sendMobileNumber?: boolean
    idNoRegNo?: boolean
    taxPin?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    country?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountNumber" | "code" | "tenantType" | "surname" | "otherNames" | "gender" | "email" | "phone" | "town" | "sendMobileNumber" | "idNoRegNo" | "taxPin" | "postalAddress" | "postalCode" | "country" | "photoUrl" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leases?: boolean | Tenant$leasesArgs<ExtArgs>
    emergencyContacts?: boolean | Tenant$emergencyContactsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      leases: Prisma.$LeasePayload<ExtArgs>[]
      emergencyContacts: Prisma.$TenantEmergencyContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountNumber: string
      code: string
      tenantType: string | null
      surname: string
      otherNames: string | null
      gender: string | null
      email: string | null
      phone: string
      town: string | null
      sendMobileNumber: boolean
      idNoRegNo: string | null
      taxPin: string | null
      postalAddress: string | null
      postalCode: string | null
      country: string | null
      photoUrl: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leases<T extends Tenant$leasesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$leasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyContacts<T extends Tenant$emergencyContactsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$emergencyContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly accountNumber: FieldRef<"Tenant", 'String'>
    readonly code: FieldRef<"Tenant", 'String'>
    readonly tenantType: FieldRef<"Tenant", 'String'>
    readonly surname: FieldRef<"Tenant", 'String'>
    readonly otherNames: FieldRef<"Tenant", 'String'>
    readonly gender: FieldRef<"Tenant", 'String'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly town: FieldRef<"Tenant", 'String'>
    readonly sendMobileNumber: FieldRef<"Tenant", 'Boolean'>
    readonly idNoRegNo: FieldRef<"Tenant", 'String'>
    readonly taxPin: FieldRef<"Tenant", 'String'>
    readonly postalAddress: FieldRef<"Tenant", 'String'>
    readonly postalCode: FieldRef<"Tenant", 'String'>
    readonly country: FieldRef<"Tenant", 'String'>
    readonly photoUrl: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly deletedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.leases
   */
  export type Tenant$leasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Tenant.emergencyContacts
   */
  export type Tenant$emergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    where?: TenantEmergencyContactWhereInput
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    cursor?: TenantEmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantEmergencyContact
   */

  export type AggregateTenantEmergencyContact = {
    _count: TenantEmergencyContactCountAggregateOutputType | null
    _avg: TenantEmergencyContactAvgAggregateOutputType | null
    _sum: TenantEmergencyContactSumAggregateOutputType | null
    _min: TenantEmergencyContactMinAggregateOutputType | null
    _max: TenantEmergencyContactMaxAggregateOutputType | null
  }

  export type TenantEmergencyContactAvgAggregateOutputType = {
    priority: number | null
  }

  export type TenantEmergencyContactSumAggregateOutputType = {
    priority: number | null
  }

  export type TenantEmergencyContactMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactName: string | null
    relationship: string | null
    phone: string | null
    email: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantEmergencyContactMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactName: string | null
    relationship: string | null
    phone: string | null
    email: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantEmergencyContactCountAggregateOutputType = {
    id: number
    tenantId: number
    contactName: number
    relationship: number
    phone: number
    email: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantEmergencyContactAvgAggregateInputType = {
    priority?: true
  }

  export type TenantEmergencyContactSumAggregateInputType = {
    priority?: true
  }

  export type TenantEmergencyContactMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactName?: true
    relationship?: true
    phone?: true
    email?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantEmergencyContactMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactName?: true
    relationship?: true
    phone?: true
    email?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantEmergencyContactCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactName?: true
    relationship?: true
    phone?: true
    email?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantEmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantEmergencyContact to aggregate.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantEmergencyContacts
    **/
    _count?: true | TenantEmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantEmergencyContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantEmergencyContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantEmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantEmergencyContactMaxAggregateInputType
  }

  export type GetTenantEmergencyContactAggregateType<T extends TenantEmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantEmergencyContact[P]>
      : GetScalarType<T[P], AggregateTenantEmergencyContact[P]>
  }




  export type TenantEmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantEmergencyContactWhereInput
    orderBy?: TenantEmergencyContactOrderByWithAggregationInput | TenantEmergencyContactOrderByWithAggregationInput[]
    by: TenantEmergencyContactScalarFieldEnum[] | TenantEmergencyContactScalarFieldEnum
    having?: TenantEmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantEmergencyContactCountAggregateInputType | true
    _avg?: TenantEmergencyContactAvgAggregateInputType
    _sum?: TenantEmergencyContactSumAggregateInputType
    _min?: TenantEmergencyContactMinAggregateInputType
    _max?: TenantEmergencyContactMaxAggregateInputType
  }

  export type TenantEmergencyContactGroupByOutputType = {
    id: string
    tenantId: string
    contactName: string
    relationship: string | null
    phone: string | null
    email: string | null
    priority: number
    createdAt: Date
    updatedAt: Date
    _count: TenantEmergencyContactCountAggregateOutputType | null
    _avg: TenantEmergencyContactAvgAggregateOutputType | null
    _sum: TenantEmergencyContactSumAggregateOutputType | null
    _min: TenantEmergencyContactMinAggregateOutputType | null
    _max: TenantEmergencyContactMaxAggregateOutputType | null
  }

  type GetTenantEmergencyContactGroupByPayload<T extends TenantEmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantEmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantEmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantEmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], TenantEmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type TenantEmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactName?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantEmergencyContact"]>

  export type TenantEmergencyContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactName?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantEmergencyContact"]>

  export type TenantEmergencyContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactName?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantEmergencyContact"]>

  export type TenantEmergencyContactSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactName?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantEmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactName" | "relationship" | "phone" | "email" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantEmergencyContact"]>
  export type TenantEmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantEmergencyContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantEmergencyContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantEmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantEmergencyContact"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactName: string
      relationship: string | null
      phone: string | null
      email: string | null
      priority: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantEmergencyContact"]>
    composites: {}
  }

  type TenantEmergencyContactGetPayload<S extends boolean | null | undefined | TenantEmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$TenantEmergencyContactPayload, S>

  type TenantEmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantEmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantEmergencyContactCountAggregateInputType | true
    }

  export interface TenantEmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantEmergencyContact'], meta: { name: 'TenantEmergencyContact' } }
    /**
     * Find zero or one TenantEmergencyContact that matches the filter.
     * @param {TenantEmergencyContactFindUniqueArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantEmergencyContactFindUniqueArgs>(args: SelectSubset<T, TenantEmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantEmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantEmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantEmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantEmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantEmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactFindFirstArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantEmergencyContactFindFirstArgs>(args?: SelectSubset<T, TenantEmergencyContactFindFirstArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantEmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactFindFirstOrThrowArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantEmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantEmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantEmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantEmergencyContacts
     * const tenantEmergencyContacts = await prisma.tenantEmergencyContact.findMany()
     * 
     * // Get first 10 TenantEmergencyContacts
     * const tenantEmergencyContacts = await prisma.tenantEmergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantEmergencyContactWithIdOnly = await prisma.tenantEmergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantEmergencyContactFindManyArgs>(args?: SelectSubset<T, TenantEmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantEmergencyContact.
     * @param {TenantEmergencyContactCreateArgs} args - Arguments to create a TenantEmergencyContact.
     * @example
     * // Create one TenantEmergencyContact
     * const TenantEmergencyContact = await prisma.tenantEmergencyContact.create({
     *   data: {
     *     // ... data to create a TenantEmergencyContact
     *   }
     * })
     * 
     */
    create<T extends TenantEmergencyContactCreateArgs>(args: SelectSubset<T, TenantEmergencyContactCreateArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantEmergencyContacts.
     * @param {TenantEmergencyContactCreateManyArgs} args - Arguments to create many TenantEmergencyContacts.
     * @example
     * // Create many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantEmergencyContactCreateManyArgs>(args?: SelectSubset<T, TenantEmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantEmergencyContacts and returns the data saved in the database.
     * @param {TenantEmergencyContactCreateManyAndReturnArgs} args - Arguments to create many TenantEmergencyContacts.
     * @example
     * // Create many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantEmergencyContacts and only return the `id`
     * const tenantEmergencyContactWithIdOnly = await prisma.tenantEmergencyContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantEmergencyContactCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantEmergencyContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantEmergencyContact.
     * @param {TenantEmergencyContactDeleteArgs} args - Arguments to delete one TenantEmergencyContact.
     * @example
     * // Delete one TenantEmergencyContact
     * const TenantEmergencyContact = await prisma.tenantEmergencyContact.delete({
     *   where: {
     *     // ... filter to delete one TenantEmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends TenantEmergencyContactDeleteArgs>(args: SelectSubset<T, TenantEmergencyContactDeleteArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantEmergencyContact.
     * @param {TenantEmergencyContactUpdateArgs} args - Arguments to update one TenantEmergencyContact.
     * @example
     * // Update one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantEmergencyContactUpdateArgs>(args: SelectSubset<T, TenantEmergencyContactUpdateArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantEmergencyContacts.
     * @param {TenantEmergencyContactDeleteManyArgs} args - Arguments to filter TenantEmergencyContacts to delete.
     * @example
     * // Delete a few TenantEmergencyContacts
     * const { count } = await prisma.tenantEmergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantEmergencyContactDeleteManyArgs>(args?: SelectSubset<T, TenantEmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantEmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantEmergencyContactUpdateManyArgs>(args: SelectSubset<T, TenantEmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantEmergencyContacts and returns the data updated in the database.
     * @param {TenantEmergencyContactUpdateManyAndReturnArgs} args - Arguments to update many TenantEmergencyContacts.
     * @example
     * // Update many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantEmergencyContacts and only return the `id`
     * const tenantEmergencyContactWithIdOnly = await prisma.tenantEmergencyContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantEmergencyContactUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantEmergencyContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantEmergencyContact.
     * @param {TenantEmergencyContactUpsertArgs} args - Arguments to update or create a TenantEmergencyContact.
     * @example
     * // Update or create a TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.upsert({
     *   create: {
     *     // ... data to create a TenantEmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantEmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends TenantEmergencyContactUpsertArgs>(args: SelectSubset<T, TenantEmergencyContactUpsertArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantEmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactCountArgs} args - Arguments to filter TenantEmergencyContacts to count.
     * @example
     * // Count the number of TenantEmergencyContacts
     * const count = await prisma.tenantEmergencyContact.count({
     *   where: {
     *     // ... the filter for the TenantEmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends TenantEmergencyContactCountArgs>(
      args?: Subset<T, TenantEmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantEmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantEmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantEmergencyContactAggregateArgs>(args: Subset<T, TenantEmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetTenantEmergencyContactAggregateType<T>>

    /**
     * Group by TenantEmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantEmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantEmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: TenantEmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantEmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantEmergencyContact model
   */
  readonly fields: TenantEmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantEmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantEmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantEmergencyContact model
   */
  interface TenantEmergencyContactFieldRefs {
    readonly id: FieldRef<"TenantEmergencyContact", 'String'>
    readonly tenantId: FieldRef<"TenantEmergencyContact", 'String'>
    readonly contactName: FieldRef<"TenantEmergencyContact", 'String'>
    readonly relationship: FieldRef<"TenantEmergencyContact", 'String'>
    readonly phone: FieldRef<"TenantEmergencyContact", 'String'>
    readonly email: FieldRef<"TenantEmergencyContact", 'String'>
    readonly priority: FieldRef<"TenantEmergencyContact", 'Int'>
    readonly createdAt: FieldRef<"TenantEmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantEmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantEmergencyContact findUnique
   */
  export type TenantEmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact findUniqueOrThrow
   */
  export type TenantEmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact findFirst
   */
  export type TenantEmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantEmergencyContacts.
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantEmergencyContacts.
     */
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * TenantEmergencyContact findFirstOrThrow
   */
  export type TenantEmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantEmergencyContacts.
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantEmergencyContacts.
     */
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * TenantEmergencyContact findMany
   */
  export type TenantEmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContacts to fetch.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantEmergencyContacts.
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * TenantEmergencyContact create
   */
  export type TenantEmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantEmergencyContact.
     */
    data: XOR<TenantEmergencyContactCreateInput, TenantEmergencyContactUncheckedCreateInput>
  }

  /**
   * TenantEmergencyContact createMany
   */
  export type TenantEmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantEmergencyContacts.
     */
    data: TenantEmergencyContactCreateManyInput | TenantEmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantEmergencyContact createManyAndReturn
   */
  export type TenantEmergencyContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to create many TenantEmergencyContacts.
     */
    data: TenantEmergencyContactCreateManyInput | TenantEmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantEmergencyContact update
   */
  export type TenantEmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantEmergencyContact.
     */
    data: XOR<TenantEmergencyContactUpdateInput, TenantEmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which TenantEmergencyContact to update.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact updateMany
   */
  export type TenantEmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantEmergencyContacts.
     */
    data: XOR<TenantEmergencyContactUpdateManyMutationInput, TenantEmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which TenantEmergencyContacts to update
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * Limit how many TenantEmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * TenantEmergencyContact updateManyAndReturn
   */
  export type TenantEmergencyContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to update TenantEmergencyContacts.
     */
    data: XOR<TenantEmergencyContactUpdateManyMutationInput, TenantEmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which TenantEmergencyContacts to update
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * Limit how many TenantEmergencyContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantEmergencyContact upsert
   */
  export type TenantEmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantEmergencyContact to update in case it exists.
     */
    where: TenantEmergencyContactWhereUniqueInput
    /**
     * In case the TenantEmergencyContact found by the `where` argument doesn't exist, create a new TenantEmergencyContact with this data.
     */
    create: XOR<TenantEmergencyContactCreateInput, TenantEmergencyContactUncheckedCreateInput>
    /**
     * In case the TenantEmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantEmergencyContactUpdateInput, TenantEmergencyContactUncheckedUpdateInput>
  }

  /**
   * TenantEmergencyContact delete
   */
  export type TenantEmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which TenantEmergencyContact to delete.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact deleteMany
   */
  export type TenantEmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantEmergencyContacts to delete
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * Limit how many TenantEmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * TenantEmergencyContact without action
   */
  export type TenantEmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model Lease
   */

  export type AggregateLease = {
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  export type LeaseAvgAggregateOutputType = {
    rentAmount: Decimal | null
    paymentDay: number | null
    securityDeposit: Decimal | null
  }

  export type LeaseSumAggregateOutputType = {
    rentAmount: Decimal | null
    paymentDay: number | null
    securityDeposit: Decimal | null
  }

  export type LeaseMinAggregateOutputType = {
    id: string | null
    code: string | null
    unitId: string | null
    tenantId: string | null
    startDate: Date | null
    endDate: Date | null
    rentAmount: Decimal | null
    currency: string | null
    paymentDay: number | null
    securityDeposit: Decimal | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LeaseMaxAggregateOutputType = {
    id: string | null
    code: string | null
    unitId: string | null
    tenantId: string | null
    startDate: Date | null
    endDate: Date | null
    rentAmount: Decimal | null
    currency: string | null
    paymentDay: number | null
    securityDeposit: Decimal | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LeaseCountAggregateOutputType = {
    id: number
    code: number
    unitId: number
    tenantId: number
    startDate: number
    endDate: number
    rentAmount: number
    currency: number
    paymentDay: number
    securityDeposit: number
    status: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LeaseAvgAggregateInputType = {
    rentAmount?: true
    paymentDay?: true
    securityDeposit?: true
  }

  export type LeaseSumAggregateInputType = {
    rentAmount?: true
    paymentDay?: true
    securityDeposit?: true
  }

  export type LeaseMinAggregateInputType = {
    id?: true
    code?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rentAmount?: true
    currency?: true
    paymentDay?: true
    securityDeposit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LeaseMaxAggregateInputType = {
    id?: true
    code?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rentAmount?: true
    currency?: true
    paymentDay?: true
    securityDeposit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LeaseCountAggregateInputType = {
    id?: true
    code?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rentAmount?: true
    currency?: true
    paymentDay?: true
    securityDeposit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LeaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lease to aggregate.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leases
    **/
    _count?: true | LeaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaseMaxAggregateInputType
  }

  export type GetLeaseAggregateType<T extends LeaseAggregateArgs> = {
        [P in keyof T & keyof AggregateLease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLease[P]>
      : GetScalarType<T[P], AggregateLease[P]>
  }




  export type LeaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithAggregationInput | LeaseOrderByWithAggregationInput[]
    by: LeaseScalarFieldEnum[] | LeaseScalarFieldEnum
    having?: LeaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaseCountAggregateInputType | true
    _avg?: LeaseAvgAggregateInputType
    _sum?: LeaseSumAggregateInputType
    _min?: LeaseMinAggregateInputType
    _max?: LeaseMaxAggregateInputType
  }

  export type LeaseGroupByOutputType = {
    id: string
    code: string
    unitId: string
    tenantId: string
    startDate: Date
    endDate: Date | null
    rentAmount: Decimal
    currency: string
    paymentDay: number
    securityDeposit: Decimal | null
    status: $Enums.LeaseStatus
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  type GetLeaseGroupByPayload<T extends LeaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaseGroupByOutputType[P]>
            : GetScalarType<T[P], LeaseGroupByOutputType[P]>
        }
      >
    >


  export type LeaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    currency?: boolean
    paymentDay?: boolean
    securityDeposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoices?: boolean | Lease$invoicesArgs<ExtArgs>
    payments?: boolean | Lease$paymentsArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    currency?: boolean
    paymentDay?: boolean
    securityDeposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    currency?: boolean
    paymentDay?: boolean
    securityDeposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectScalar = {
    id?: boolean
    code?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    currency?: boolean
    paymentDay?: boolean
    securityDeposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LeaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "unitId" | "tenantId" | "startDate" | "endDate" | "rentAmount" | "currency" | "paymentDay" | "securityDeposit" | "status" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["lease"]>
  export type LeaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoices?: boolean | Lease$invoicesArgs<ExtArgs>
    payments?: boolean | Lease$paymentsArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LeaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $LeasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lease"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      unitId: string
      tenantId: string
      startDate: Date
      endDate: Date | null
      rentAmount: Prisma.Decimal
      currency: string
      paymentDay: number
      securityDeposit: Prisma.Decimal | null
      status: $Enums.LeaseStatus
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["lease"]>
    composites: {}
  }

  type LeaseGetPayload<S extends boolean | null | undefined | LeaseDefaultArgs> = $Result.GetResult<Prisma.$LeasePayload, S>

  type LeaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaseCountAggregateInputType | true
    }

  export interface LeaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lease'], meta: { name: 'Lease' } }
    /**
     * Find zero or one Lease that matches the filter.
     * @param {LeaseFindUniqueArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaseFindUniqueArgs>(args: SelectSubset<T, LeaseFindUniqueArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lease that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaseFindUniqueOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaseFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaseFindFirstArgs>(args?: SelectSubset<T, LeaseFindFirstArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaseFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leases
     * const leases = await prisma.lease.findMany()
     * 
     * // Get first 10 Leases
     * const leases = await prisma.lease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaseWithIdOnly = await prisma.lease.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaseFindManyArgs>(args?: SelectSubset<T, LeaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lease.
     * @param {LeaseCreateArgs} args - Arguments to create a Lease.
     * @example
     * // Create one Lease
     * const Lease = await prisma.lease.create({
     *   data: {
     *     // ... data to create a Lease
     *   }
     * })
     * 
     */
    create<T extends LeaseCreateArgs>(args: SelectSubset<T, LeaseCreateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leases.
     * @param {LeaseCreateManyArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaseCreateManyArgs>(args?: SelectSubset<T, LeaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leases and returns the data saved in the database.
     * @param {LeaseCreateManyAndReturnArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaseCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lease.
     * @param {LeaseDeleteArgs} args - Arguments to delete one Lease.
     * @example
     * // Delete one Lease
     * const Lease = await prisma.lease.delete({
     *   where: {
     *     // ... filter to delete one Lease
     *   }
     * })
     * 
     */
    delete<T extends LeaseDeleteArgs>(args: SelectSubset<T, LeaseDeleteArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lease.
     * @param {LeaseUpdateArgs} args - Arguments to update one Lease.
     * @example
     * // Update one Lease
     * const lease = await prisma.lease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaseUpdateArgs>(args: SelectSubset<T, LeaseUpdateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leases.
     * @param {LeaseDeleteManyArgs} args - Arguments to filter Leases to delete.
     * @example
     * // Delete a few Leases
     * const { count } = await prisma.lease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaseDeleteManyArgs>(args?: SelectSubset<T, LeaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaseUpdateManyArgs>(args: SelectSubset<T, LeaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases and returns the data updated in the database.
     * @param {LeaseUpdateManyAndReturnArgs} args - Arguments to update many Leases.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaseUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lease.
     * @param {LeaseUpsertArgs} args - Arguments to update or create a Lease.
     * @example
     * // Update or create a Lease
     * const lease = await prisma.lease.upsert({
     *   create: {
     *     // ... data to create a Lease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lease we want to update
     *   }
     * })
     */
    upsert<T extends LeaseUpsertArgs>(args: SelectSubset<T, LeaseUpsertArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseCountArgs} args - Arguments to filter Leases to count.
     * @example
     * // Count the number of Leases
     * const count = await prisma.lease.count({
     *   where: {
     *     // ... the filter for the Leases we want to count
     *   }
     * })
    **/
    count<T extends LeaseCountArgs>(
      args?: Subset<T, LeaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaseAggregateArgs>(args: Subset<T, LeaseAggregateArgs>): Prisma.PrismaPromise<GetLeaseAggregateType<T>>

    /**
     * Group by Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaseGroupByArgs['orderBy'] }
        : { orderBy?: LeaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lease model
   */
  readonly fields: LeaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Lease$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Lease$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Lease$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Lease$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lease model
   */
  interface LeaseFieldRefs {
    readonly id: FieldRef<"Lease", 'String'>
    readonly code: FieldRef<"Lease", 'String'>
    readonly unitId: FieldRef<"Lease", 'String'>
    readonly tenantId: FieldRef<"Lease", 'String'>
    readonly startDate: FieldRef<"Lease", 'DateTime'>
    readonly endDate: FieldRef<"Lease", 'DateTime'>
    readonly rentAmount: FieldRef<"Lease", 'Decimal'>
    readonly currency: FieldRef<"Lease", 'String'>
    readonly paymentDay: FieldRef<"Lease", 'Int'>
    readonly securityDeposit: FieldRef<"Lease", 'Decimal'>
    readonly status: FieldRef<"Lease", 'LeaseStatus'>
    readonly createdAt: FieldRef<"Lease", 'DateTime'>
    readonly updatedAt: FieldRef<"Lease", 'DateTime'>
    readonly deletedAt: FieldRef<"Lease", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lease findUnique
   */
  export type LeaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findUniqueOrThrow
   */
  export type LeaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findFirst
   */
  export type LeaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findFirstOrThrow
   */
  export type LeaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findMany
   */
  export type LeaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Leases to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease create
   */
  export type LeaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Lease.
     */
    data: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
  }

  /**
   * Lease createMany
   */
  export type LeaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lease createManyAndReturn
   */
  export type LeaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease update
   */
  export type LeaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Lease.
     */
    data: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
    /**
     * Choose, which Lease to update.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease updateMany
   */
  export type LeaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
  }

  /**
   * Lease updateManyAndReturn
   */
  export type LeaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease upsert
   */
  export type LeaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Lease to update in case it exists.
     */
    where: LeaseWhereUniqueInput
    /**
     * In case the Lease found by the `where` argument doesn't exist, create a new Lease with this data.
     */
    create: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
    /**
     * In case the Lease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
  }

  /**
   * Lease delete
   */
  export type LeaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter which Lease to delete.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease deleteMany
   */
  export type LeaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leases to delete
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to delete.
     */
    limit?: number
  }

  /**
   * Lease.invoices
   */
  export type Lease$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Lease.payments
   */
  export type Lease$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Lease without action
   */
  export type LeaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: Decimal | null
    vatAmount: Decimal | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    balanceAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: Decimal | null
    vatAmount: Decimal | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    balanceAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    leaseId: string | null
    issueDate: Date | null
    dueDate: Date | null
    amount: Decimal | null
    vatAmount: Decimal | null
    totalAmount: Decimal | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    paidAmount: Decimal | null
    balanceAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    leaseId: string | null
    issueDate: Date | null
    dueDate: Date | null
    amount: Decimal | null
    vatAmount: Decimal | null
    totalAmount: Decimal | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    paidAmount: Decimal | null
    balanceAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    leaseId: number
    issueDate: number
    dueDate: number
    amount: number
    vatAmount: number
    totalAmount: number
    currency: number
    status: number
    paidAmount: number
    balanceAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
    vatAmount?: true
    totalAmount?: true
    paidAmount?: true
    balanceAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
    vatAmount?: true
    totalAmount?: true
    paidAmount?: true
    balanceAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    leaseId?: true
    issueDate?: true
    dueDate?: true
    amount?: true
    vatAmount?: true
    totalAmount?: true
    currency?: true
    status?: true
    paidAmount?: true
    balanceAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    leaseId?: true
    issueDate?: true
    dueDate?: true
    amount?: true
    vatAmount?: true
    totalAmount?: true
    currency?: true
    status?: true
    paidAmount?: true
    balanceAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    leaseId?: true
    issueDate?: true
    dueDate?: true
    amount?: true
    vatAmount?: true
    totalAmount?: true
    currency?: true
    status?: true
    paidAmount?: true
    balanceAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    leaseId: string
    issueDate: Date
    dueDate: Date
    amount: Decimal
    vatAmount: Decimal | null
    totalAmount: Decimal
    currency: string
    status: $Enums.InvoiceStatus
    paidAmount: Decimal
    balanceAmount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    leaseId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    amount?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    leaseId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    amount?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    leaseId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    amount?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    leaseId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    amount?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "leaseId" | "issueDate" | "dueDate" | "amount" | "vatAmount" | "totalAmount" | "currency" | "status" | "paidAmount" | "balanceAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      leaseId: string
      issueDate: Date
      dueDate: Date
      amount: Prisma.Decimal
      vatAmount: Prisma.Decimal | null
      totalAmount: Prisma.Decimal
      currency: string
      status: $Enums.InvoiceStatus
      paidAmount: Prisma.Decimal
      balanceAmount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoiceItems<T extends Invoice$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly leaseId: FieldRef<"Invoice", 'String'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly vatAmount: FieldRef<"Invoice", 'Decimal'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly paidAmount: FieldRef<"Invoice", 'Decimal'>
    readonly balanceAmount: FieldRef<"Invoice", 'Decimal'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.invoiceItems
   */
  export type Invoice$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    amount: Decimal | null
    vatRate: Decimal | null
    vatAmount: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    amount: Decimal | null
    vatRate: Decimal | null
    vatAmount: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    amount: Decimal | null
    vatRate: Decimal | null
    vatAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    amount: Decimal | null
    vatRate: Decimal | null
    vatAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    unitPrice: number
    amount: number
    vatRate: number
    vatAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
    vatRate?: true
    vatAmount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
    vatRate?: true
    vatAmount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    vatRate?: true
    vatAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    vatRate?: true
    vatAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    vatRate?: true
    vatAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    quantity: Decimal
    unitPrice: Decimal
    amount: Decimal
    vatRate: Decimal | null
    vatAmount: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "quantity" | "unitPrice" | "amount" | "vatRate" | "vatAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      quantity: Prisma.Decimal
      unitPrice: Prisma.Decimal
      amount: Prisma.Decimal
      vatRate: Prisma.Decimal | null
      vatAmount: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Decimal'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Decimal'>
    readonly amount: FieldRef<"InvoiceItem", 'Decimal'>
    readonly vatRate: FieldRef<"InvoiceItem", 'Decimal'>
    readonly vatAmount: FieldRef<"InvoiceItem", 'Decimal'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    leaseId: string | null
    invoiceId: string | null
    paymentDate: Date | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentReference: string | null
    mpesaReceiptNumber: string | null
    mpesaPhoneNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    leaseId: string | null
    invoiceId: string | null
    paymentDate: Date | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentReference: string | null
    mpesaReceiptNumber: string | null
    mpesaPhoneNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    receiptNumber: number
    leaseId: number
    invoiceId: number
    paymentDate: number
    amount: number
    currency: number
    paymentMethod: number
    paymentReference: number
    mpesaReceiptNumber: number
    mpesaPhoneNumber: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    receiptNumber?: true
    leaseId?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentReference?: true
    mpesaReceiptNumber?: true
    mpesaPhoneNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    receiptNumber?: true
    leaseId?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentReference?: true
    mpesaReceiptNumber?: true
    mpesaPhoneNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    receiptNumber?: true
    leaseId?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentReference?: true
    mpesaReceiptNumber?: true
    mpesaPhoneNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    receiptNumber: string
    leaseId: string
    invoiceId: string | null
    paymentDate: Date
    amount: Decimal
    currency: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference: string | null
    mpesaReceiptNumber: string | null
    mpesaPhoneNumber: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    mpesaReceiptNumber?: boolean
    mpesaPhoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    mpesaReceiptNumber?: boolean
    mpesaPhoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    mpesaReceiptNumber?: boolean
    mpesaPhoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    receiptNumber?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentReference?: boolean
    mpesaReceiptNumber?: boolean
    mpesaPhoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptNumber" | "leaseId" | "invoiceId" | "paymentDate" | "amount" | "currency" | "paymentMethod" | "paymentReference" | "mpesaReceiptNumber" | "mpesaPhoneNumber" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiptNumber: string
      leaseId: string
      invoiceId: string | null
      paymentDate: Date
      amount: Prisma.Decimal
      currency: string
      paymentMethod: $Enums.PaymentMethod
      paymentReference: string | null
      mpesaReceiptNumber: string | null
      mpesaPhoneNumber: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly receiptNumber: FieldRef<"Payment", 'String'>
    readonly leaseId: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly paymentReference: FieldRef<"Payment", 'String'>
    readonly mpesaReceiptNumber: FieldRef<"Payment", 'String'>
    readonly mpesaPhoneNumber: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    phone: number
    passwordHash: number
    role: number
    isActive: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    phone: string | null
    passwordHash: string
    role: $Enums.UserRole
    isActive: boolean
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "phone" | "passwordHash" | "role" | "isActive" | "emailVerified" | "createdAt" | "updatedAt" | "lastLoginAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string
      lastName: string
      phone: string | null
      passwordHash: string
      role: $Enums.UserRole
      isActive: boolean
      emailVerified: boolean
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entity: string
    entityId: string
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entity: string
      entityId: string
      details: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    dateAcquired: 'dateAcquired',
    lrNumber: 'lrNumber',
    country: 'country',
    estateArea: 'estateArea',
    areaRegion: 'areaRegion',
    roadStreet: 'roadStreet',
    specification: 'specification',
    multiStoryType: 'multiStoryType',
    numberOfFloors: 'numberOfFloors',
    latitude: 'latitude',
    longitude: 'longitude',
    notes: 'notes',
    specificContactInfo: 'specificContactInfo',
    landlordId: 'landlordId',
    categoryId: 'categoryId',
    propertyTypeId: 'propertyTypeId',
    accountLedgerType: 'accountLedgerType',
    primaryBankAccount: 'primaryBankAccount',
    alternativeTaxPin: 'alternativeTaxPin',
    propertyWorkingTaxPin: 'propertyWorkingTaxPin',
    invoicePaymentInfo: 'invoicePaymentInfo',
    holderPaymentTerms: 'holderPaymentTerms',
    mpesaPropertyPayNumber: 'mpesaPropertyPayNumber',
    disableMpesaStkPush: 'disableMpesaStkPush',
    disableMpesaStkNarration: 'disableMpesaStkNarration',
    tenantReceiptAccountCodeCounter: 'tenantReceiptAccountCodeCounter',
    lpgExempted: 'lpgExempted',
    penaltyChargeMode: 'penaltyChargeMode',
    penaltyDay: 'penaltyDay',
    landlordDrawerBank: 'landlordDrawerBank',
    landlordBankBranch: 'landlordBankBranch',
    landlordAccountName: 'landlordAccountName',
    landlordAccountNumber: 'landlordAccountNumber',
    exemptAllSms: 'exemptAllSms',
    exemptInvoiceSms: 'exemptInvoiceSms',
    exemptGeneralSms: 'exemptGeneralSms',
    exemptHagueSms: 'exemptHagueSms',
    exemptBalanceSms: 'exemptBalanceSms',
    exemptAllEmail: 'exemptAllEmail',
    exemptInvoiceEmail: 'exemptInvoiceEmail',
    exemptGeneralEmail: 'exemptGeneralEmail',
    exemptReceiptEmail: 'exemptReceiptEmail',
    exemptBalanceEmail: 'exemptBalanceEmail',
    excludeInTwoSummaryReport: 'excludeInTwoSummaryReport',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const LandlordScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    email: 'email',
    phone: 'phone',
    alternativePhone: 'alternativePhone',
    address: 'address',
    city: 'city',
    country: 'country',
    postalCode: 'postalCode',
    bankName: 'bankName',
    bankBranch: 'bankBranch',
    accountName: 'accountName',
    accountNumber: 'accountNumber',
    taxPin: 'taxPin',
    vatRegistered: 'vatRegistered',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LandlordScalarFieldEnum = (typeof LandlordScalarFieldEnum)[keyof typeof LandlordScalarFieldEnum]


  export const PropertyCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyCategoryScalarFieldEnum = (typeof PropertyCategoryScalarFieldEnum)[keyof typeof PropertyCategoryScalarFieldEnum]


  export const PropertyTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyTypeScalarFieldEnum = (typeof PropertyTypeScalarFieldEnum)[keyof typeof PropertyTypeScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    sequence: 'sequence',
    propertyId: 'propertyId',
    quotedPrice: 'quotedPrice',
    baseRent: 'baseRent',
    basePerUnitArea: 'basePerUnitArea',
    currency: 'currency',
    areaSqFt: 'areaSqFt',
    chargePlan: 'chargePlan',
    floor: 'floor',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    furnished: 'furnished',
    outSourceParking: 'outSourceParking',
    unitTypeId: 'unitTypeId',
    ownerOccupied: 'ownerOccupied',
    electricityAcno: 'electricityAcno',
    waterAcno: 'waterAcno',
    electricityMeethno: 'electricityMeethno',
    waterMeethno: 'waterMeethno',
    takeOnLettingDate: 'takeOnLettingDate',
    tenantResidentCodeCounter: 'tenantResidentCodeCounter',
    apartmentNotes: 'apartmentNotes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const UnitTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitTypeScalarFieldEnum = (typeof UnitTypeScalarFieldEnum)[keyof typeof UnitTypeScalarFieldEnum]


  export const UnitServiceChargeScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    serviceUtilityAmenity: 'serviceUtilityAmenity',
    costPerArea: 'costPerArea',
    totalCost: 'totalCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitServiceChargeScalarFieldEnum = (typeof UnitServiceChargeScalarFieldEnum)[keyof typeof UnitServiceChargeScalarFieldEnum]


  export const UnitMeterNumberScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    meterNo: 'meterNo',
    readingSetup: 'readingSetup',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitMeterNumberScalarFieldEnum = (typeof UnitMeterNumberScalarFieldEnum)[keyof typeof UnitMeterNumberScalarFieldEnum]


  export const UnitFeatureScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    name: 'name',
    featureType: 'featureType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitFeatureScalarFieldEnum = (typeof UnitFeatureScalarFieldEnum)[keyof typeof UnitFeatureScalarFieldEnum]


  export const PropertyStandingChargeScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    chargeUtility: 'chargeUtility',
    chargeMode: 'chargeMode',
    billingCurrency: 'billingCurrency',
    costPerArea: 'costPerArea',
    chargeValue: 'chargeValue',
    vatRate: 'vatRate',
    excludesWithRent: 'excludesWithRent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyStandingChargeScalarFieldEnum = (typeof PropertyStandingChargeScalarFieldEnum)[keyof typeof PropertyStandingChargeScalarFieldEnum]


  export const PropertySecurityDepositScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    month: 'month',
    value: 'value',
    ofRentBillingAmount: 'ofRentBillingAmount',
    ofInitialRent: 'ofInitialRent',
    ofLastEscalation: 'ofLastEscalation',
    excludesWithRent: 'excludesWithRent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertySecurityDepositScalarFieldEnum = (typeof PropertySecurityDepositScalarFieldEnum)[keyof typeof PropertySecurityDepositScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    accountNumber: 'accountNumber',
    code: 'code',
    tenantType: 'tenantType',
    surname: 'surname',
    otherNames: 'otherNames',
    gender: 'gender',
    email: 'email',
    phone: 'phone',
    town: 'town',
    sendMobileNumber: 'sendMobileNumber',
    idNoRegNo: 'idNoRegNo',
    taxPin: 'taxPin',
    postalAddress: 'postalAddress',
    postalCode: 'postalCode',
    country: 'country',
    photoUrl: 'photoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantEmergencyContactScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactName: 'contactName',
    relationship: 'relationship',
    phone: 'phone',
    email: 'email',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantEmergencyContactScalarFieldEnum = (typeof TenantEmergencyContactScalarFieldEnum)[keyof typeof TenantEmergencyContactScalarFieldEnum]


  export const LeaseScalarFieldEnum: {
    id: 'id',
    code: 'code',
    unitId: 'unitId',
    tenantId: 'tenantId',
    startDate: 'startDate',
    endDate: 'endDate',
    rentAmount: 'rentAmount',
    currency: 'currency',
    paymentDay: 'paymentDay',
    securityDeposit: 'securityDeposit',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LeaseScalarFieldEnum = (typeof LeaseScalarFieldEnum)[keyof typeof LeaseScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    leaseId: 'leaseId',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    amount: 'amount',
    vatAmount: 'vatAmount',
    totalAmount: 'totalAmount',
    currency: 'currency',
    status: 'status',
    paidAmount: 'paidAmount',
    balanceAmount: 'balanceAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    amount: 'amount',
    vatRate: 'vatRate',
    vatAmount: 'vatAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    receiptNumber: 'receiptNumber',
    leaseId: 'leaseId',
    invoiceId: 'invoiceId',
    paymentDate: 'paymentDate',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    paymentReference: 'paymentReference',
    mpesaReceiptNumber: 'mpesaReceiptNumber',
    mpesaPhoneNumber: 'mpesaPhoneNumber',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UnitStatus'
   */
  export type EnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus'>
    


  /**
   * Reference to a field of type 'UnitStatus[]'
   */
  export type ListEnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus[]'>
    


  /**
   * Reference to a field of type 'LeaseStatus'
   */
  export type EnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus'>
    


  /**
   * Reference to a field of type 'LeaseStatus[]'
   */
  export type ListEnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    code?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    dateAcquired?: DateTimeNullableFilter<"Property"> | Date | string | null
    lrNumber?: StringNullableFilter<"Property"> | string | null
    country?: StringNullableFilter<"Property"> | string | null
    estateArea?: StringNullableFilter<"Property"> | string | null
    areaRegion?: StringNullableFilter<"Property"> | string | null
    roadStreet?: StringNullableFilter<"Property"> | string | null
    specification?: StringNullableFilter<"Property"> | string | null
    multiStoryType?: StringNullableFilter<"Property"> | string | null
    numberOfFloors?: IntNullableFilter<"Property"> | number | null
    latitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Property"> | string | null
    specificContactInfo?: StringNullableFilter<"Property"> | string | null
    landlordId?: StringNullableFilter<"Property"> | string | null
    categoryId?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: StringNullableFilter<"Property"> | string | null
    accountLedgerType?: StringNullableFilter<"Property"> | string | null
    primaryBankAccount?: StringNullableFilter<"Property"> | string | null
    alternativeTaxPin?: StringNullableFilter<"Property"> | string | null
    propertyWorkingTaxPin?: StringNullableFilter<"Property"> | string | null
    invoicePaymentInfo?: StringNullableFilter<"Property"> | string | null
    holderPaymentTerms?: StringNullableFilter<"Property"> | string | null
    mpesaPropertyPayNumber?: StringNullableFilter<"Property"> | string | null
    disableMpesaStkPush?: BoolFilter<"Property"> | boolean
    disableMpesaStkNarration?: BoolFilter<"Property"> | boolean
    tenantReceiptAccountCodeCounter?: IntNullableFilter<"Property"> | number | null
    lpgExempted?: BoolFilter<"Property"> | boolean
    penaltyChargeMode?: StringNullableFilter<"Property"> | string | null
    penaltyDay?: IntNullableFilter<"Property"> | number | null
    landlordDrawerBank?: StringNullableFilter<"Property"> | string | null
    landlordBankBranch?: StringNullableFilter<"Property"> | string | null
    landlordAccountName?: StringNullableFilter<"Property"> | string | null
    landlordAccountNumber?: StringNullableFilter<"Property"> | string | null
    exemptAllSms?: BoolFilter<"Property"> | boolean
    exemptInvoiceSms?: BoolFilter<"Property"> | boolean
    exemptGeneralSms?: BoolFilter<"Property"> | boolean
    exemptHagueSms?: BoolFilter<"Property"> | boolean
    exemptBalanceSms?: BoolFilter<"Property"> | boolean
    exemptAllEmail?: BoolFilter<"Property"> | boolean
    exemptInvoiceEmail?: BoolFilter<"Property"> | boolean
    exemptGeneralEmail?: BoolFilter<"Property"> | boolean
    exemptReceiptEmail?: BoolFilter<"Property"> | boolean
    exemptBalanceEmail?: BoolFilter<"Property"> | boolean
    excludeInTwoSummaryReport?: BoolFilter<"Property"> | boolean
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    landlord?: XOR<LandlordNullableScalarRelationFilter, LandlordWhereInput> | null
    category?: XOR<PropertyCategoryNullableScalarRelationFilter, PropertyCategoryWhereInput> | null
    propertyType?: XOR<PropertyTypeNullableScalarRelationFilter, PropertyTypeWhereInput> | null
    units?: UnitListRelationFilter
    standingCharges?: PropertyStandingChargeListRelationFilter
    securityDeposits?: PropertySecurityDepositListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    dateAcquired?: SortOrderInput | SortOrder
    lrNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    estateArea?: SortOrderInput | SortOrder
    areaRegion?: SortOrderInput | SortOrder
    roadStreet?: SortOrderInput | SortOrder
    specification?: SortOrderInput | SortOrder
    multiStoryType?: SortOrderInput | SortOrder
    numberOfFloors?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    specificContactInfo?: SortOrderInput | SortOrder
    landlordId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    accountLedgerType?: SortOrderInput | SortOrder
    primaryBankAccount?: SortOrderInput | SortOrder
    alternativeTaxPin?: SortOrderInput | SortOrder
    propertyWorkingTaxPin?: SortOrderInput | SortOrder
    invoicePaymentInfo?: SortOrderInput | SortOrder
    holderPaymentTerms?: SortOrderInput | SortOrder
    mpesaPropertyPayNumber?: SortOrderInput | SortOrder
    disableMpesaStkPush?: SortOrder
    disableMpesaStkNarration?: SortOrder
    tenantReceiptAccountCodeCounter?: SortOrderInput | SortOrder
    lpgExempted?: SortOrder
    penaltyChargeMode?: SortOrderInput | SortOrder
    penaltyDay?: SortOrderInput | SortOrder
    landlordDrawerBank?: SortOrderInput | SortOrder
    landlordBankBranch?: SortOrderInput | SortOrder
    landlordAccountName?: SortOrderInput | SortOrder
    landlordAccountNumber?: SortOrderInput | SortOrder
    exemptAllSms?: SortOrder
    exemptInvoiceSms?: SortOrder
    exemptGeneralSms?: SortOrder
    exemptHagueSms?: SortOrder
    exemptBalanceSms?: SortOrder
    exemptAllEmail?: SortOrder
    exemptInvoiceEmail?: SortOrder
    exemptGeneralEmail?: SortOrder
    exemptReceiptEmail?: SortOrder
    exemptBalanceEmail?: SortOrder
    excludeInTwoSummaryReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    landlord?: LandlordOrderByWithRelationInput
    category?: PropertyCategoryOrderByWithRelationInput
    propertyType?: PropertyTypeOrderByWithRelationInput
    units?: UnitOrderByRelationAggregateInput
    standingCharges?: PropertyStandingChargeOrderByRelationAggregateInput
    securityDeposits?: PropertySecurityDepositOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: StringFilter<"Property"> | string
    dateAcquired?: DateTimeNullableFilter<"Property"> | Date | string | null
    lrNumber?: StringNullableFilter<"Property"> | string | null
    country?: StringNullableFilter<"Property"> | string | null
    estateArea?: StringNullableFilter<"Property"> | string | null
    areaRegion?: StringNullableFilter<"Property"> | string | null
    roadStreet?: StringNullableFilter<"Property"> | string | null
    specification?: StringNullableFilter<"Property"> | string | null
    multiStoryType?: StringNullableFilter<"Property"> | string | null
    numberOfFloors?: IntNullableFilter<"Property"> | number | null
    latitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Property"> | string | null
    specificContactInfo?: StringNullableFilter<"Property"> | string | null
    landlordId?: StringNullableFilter<"Property"> | string | null
    categoryId?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: StringNullableFilter<"Property"> | string | null
    accountLedgerType?: StringNullableFilter<"Property"> | string | null
    primaryBankAccount?: StringNullableFilter<"Property"> | string | null
    alternativeTaxPin?: StringNullableFilter<"Property"> | string | null
    propertyWorkingTaxPin?: StringNullableFilter<"Property"> | string | null
    invoicePaymentInfo?: StringNullableFilter<"Property"> | string | null
    holderPaymentTerms?: StringNullableFilter<"Property"> | string | null
    mpesaPropertyPayNumber?: StringNullableFilter<"Property"> | string | null
    disableMpesaStkPush?: BoolFilter<"Property"> | boolean
    disableMpesaStkNarration?: BoolFilter<"Property"> | boolean
    tenantReceiptAccountCodeCounter?: IntNullableFilter<"Property"> | number | null
    lpgExempted?: BoolFilter<"Property"> | boolean
    penaltyChargeMode?: StringNullableFilter<"Property"> | string | null
    penaltyDay?: IntNullableFilter<"Property"> | number | null
    landlordDrawerBank?: StringNullableFilter<"Property"> | string | null
    landlordBankBranch?: StringNullableFilter<"Property"> | string | null
    landlordAccountName?: StringNullableFilter<"Property"> | string | null
    landlordAccountNumber?: StringNullableFilter<"Property"> | string | null
    exemptAllSms?: BoolFilter<"Property"> | boolean
    exemptInvoiceSms?: BoolFilter<"Property"> | boolean
    exemptGeneralSms?: BoolFilter<"Property"> | boolean
    exemptHagueSms?: BoolFilter<"Property"> | boolean
    exemptBalanceSms?: BoolFilter<"Property"> | boolean
    exemptAllEmail?: BoolFilter<"Property"> | boolean
    exemptInvoiceEmail?: BoolFilter<"Property"> | boolean
    exemptGeneralEmail?: BoolFilter<"Property"> | boolean
    exemptReceiptEmail?: BoolFilter<"Property"> | boolean
    exemptBalanceEmail?: BoolFilter<"Property"> | boolean
    excludeInTwoSummaryReport?: BoolFilter<"Property"> | boolean
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    landlord?: XOR<LandlordNullableScalarRelationFilter, LandlordWhereInput> | null
    category?: XOR<PropertyCategoryNullableScalarRelationFilter, PropertyCategoryWhereInput> | null
    propertyType?: XOR<PropertyTypeNullableScalarRelationFilter, PropertyTypeWhereInput> | null
    units?: UnitListRelationFilter
    standingCharges?: PropertyStandingChargeListRelationFilter
    securityDeposits?: PropertySecurityDepositListRelationFilter
  }, "id" | "code">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    dateAcquired?: SortOrderInput | SortOrder
    lrNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    estateArea?: SortOrderInput | SortOrder
    areaRegion?: SortOrderInput | SortOrder
    roadStreet?: SortOrderInput | SortOrder
    specification?: SortOrderInput | SortOrder
    multiStoryType?: SortOrderInput | SortOrder
    numberOfFloors?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    specificContactInfo?: SortOrderInput | SortOrder
    landlordId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    accountLedgerType?: SortOrderInput | SortOrder
    primaryBankAccount?: SortOrderInput | SortOrder
    alternativeTaxPin?: SortOrderInput | SortOrder
    propertyWorkingTaxPin?: SortOrderInput | SortOrder
    invoicePaymentInfo?: SortOrderInput | SortOrder
    holderPaymentTerms?: SortOrderInput | SortOrder
    mpesaPropertyPayNumber?: SortOrderInput | SortOrder
    disableMpesaStkPush?: SortOrder
    disableMpesaStkNarration?: SortOrder
    tenantReceiptAccountCodeCounter?: SortOrderInput | SortOrder
    lpgExempted?: SortOrder
    penaltyChargeMode?: SortOrderInput | SortOrder
    penaltyDay?: SortOrderInput | SortOrder
    landlordDrawerBank?: SortOrderInput | SortOrder
    landlordBankBranch?: SortOrderInput | SortOrder
    landlordAccountName?: SortOrderInput | SortOrder
    landlordAccountNumber?: SortOrderInput | SortOrder
    exemptAllSms?: SortOrder
    exemptInvoiceSms?: SortOrder
    exemptGeneralSms?: SortOrder
    exemptHagueSms?: SortOrder
    exemptBalanceSms?: SortOrder
    exemptAllEmail?: SortOrder
    exemptInvoiceEmail?: SortOrder
    exemptGeneralEmail?: SortOrder
    exemptReceiptEmail?: SortOrder
    exemptBalanceEmail?: SortOrder
    excludeInTwoSummaryReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    code?: StringWithAggregatesFilter<"Property"> | string
    name?: StringWithAggregatesFilter<"Property"> | string
    dateAcquired?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    lrNumber?: StringNullableWithAggregatesFilter<"Property"> | string | null
    country?: StringNullableWithAggregatesFilter<"Property"> | string | null
    estateArea?: StringNullableWithAggregatesFilter<"Property"> | string | null
    areaRegion?: StringNullableWithAggregatesFilter<"Property"> | string | null
    roadStreet?: StringNullableWithAggregatesFilter<"Property"> | string | null
    specification?: StringNullableWithAggregatesFilter<"Property"> | string | null
    multiStoryType?: StringNullableWithAggregatesFilter<"Property"> | string | null
    numberOfFloors?: IntNullableWithAggregatesFilter<"Property"> | number | null
    latitude?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Property"> | string | null
    specificContactInfo?: StringNullableWithAggregatesFilter<"Property"> | string | null
    landlordId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyTypeId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    accountLedgerType?: StringNullableWithAggregatesFilter<"Property"> | string | null
    primaryBankAccount?: StringNullableWithAggregatesFilter<"Property"> | string | null
    alternativeTaxPin?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyWorkingTaxPin?: StringNullableWithAggregatesFilter<"Property"> | string | null
    invoicePaymentInfo?: StringNullableWithAggregatesFilter<"Property"> | string | null
    holderPaymentTerms?: StringNullableWithAggregatesFilter<"Property"> | string | null
    mpesaPropertyPayNumber?: StringNullableWithAggregatesFilter<"Property"> | string | null
    disableMpesaStkPush?: BoolWithAggregatesFilter<"Property"> | boolean
    disableMpesaStkNarration?: BoolWithAggregatesFilter<"Property"> | boolean
    tenantReceiptAccountCodeCounter?: IntNullableWithAggregatesFilter<"Property"> | number | null
    lpgExempted?: BoolWithAggregatesFilter<"Property"> | boolean
    penaltyChargeMode?: StringNullableWithAggregatesFilter<"Property"> | string | null
    penaltyDay?: IntNullableWithAggregatesFilter<"Property"> | number | null
    landlordDrawerBank?: StringNullableWithAggregatesFilter<"Property"> | string | null
    landlordBankBranch?: StringNullableWithAggregatesFilter<"Property"> | string | null
    landlordAccountName?: StringNullableWithAggregatesFilter<"Property"> | string | null
    landlordAccountNumber?: StringNullableWithAggregatesFilter<"Property"> | string | null
    exemptAllSms?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptInvoiceSms?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptGeneralSms?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptHagueSms?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptBalanceSms?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptAllEmail?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptInvoiceEmail?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptGeneralEmail?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptReceiptEmail?: BoolWithAggregatesFilter<"Property"> | boolean
    exemptBalanceEmail?: BoolWithAggregatesFilter<"Property"> | boolean
    excludeInTwoSummaryReport?: BoolWithAggregatesFilter<"Property"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
  }

  export type LandlordWhereInput = {
    AND?: LandlordWhereInput | LandlordWhereInput[]
    OR?: LandlordWhereInput[]
    NOT?: LandlordWhereInput | LandlordWhereInput[]
    id?: StringFilter<"Landlord"> | string
    code?: StringFilter<"Landlord"> | string
    name?: StringFilter<"Landlord"> | string
    email?: StringNullableFilter<"Landlord"> | string | null
    phone?: StringNullableFilter<"Landlord"> | string | null
    alternativePhone?: StringNullableFilter<"Landlord"> | string | null
    address?: StringNullableFilter<"Landlord"> | string | null
    city?: StringNullableFilter<"Landlord"> | string | null
    country?: StringNullableFilter<"Landlord"> | string | null
    postalCode?: StringNullableFilter<"Landlord"> | string | null
    bankName?: StringNullableFilter<"Landlord"> | string | null
    bankBranch?: StringNullableFilter<"Landlord"> | string | null
    accountName?: StringNullableFilter<"Landlord"> | string | null
    accountNumber?: StringNullableFilter<"Landlord"> | string | null
    taxPin?: StringNullableFilter<"Landlord"> | string | null
    vatRegistered?: BoolFilter<"Landlord"> | boolean
    createdAt?: DateTimeFilter<"Landlord"> | Date | string
    updatedAt?: DateTimeFilter<"Landlord"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Landlord"> | Date | string | null
    properties?: PropertyListRelationFilter
  }

  export type LandlordOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    alternativePhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    taxPin?: SortOrderInput | SortOrder
    vatRegistered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type LandlordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LandlordWhereInput | LandlordWhereInput[]
    OR?: LandlordWhereInput[]
    NOT?: LandlordWhereInput | LandlordWhereInput[]
    name?: StringFilter<"Landlord"> | string
    email?: StringNullableFilter<"Landlord"> | string | null
    phone?: StringNullableFilter<"Landlord"> | string | null
    alternativePhone?: StringNullableFilter<"Landlord"> | string | null
    address?: StringNullableFilter<"Landlord"> | string | null
    city?: StringNullableFilter<"Landlord"> | string | null
    country?: StringNullableFilter<"Landlord"> | string | null
    postalCode?: StringNullableFilter<"Landlord"> | string | null
    bankName?: StringNullableFilter<"Landlord"> | string | null
    bankBranch?: StringNullableFilter<"Landlord"> | string | null
    accountName?: StringNullableFilter<"Landlord"> | string | null
    accountNumber?: StringNullableFilter<"Landlord"> | string | null
    taxPin?: StringNullableFilter<"Landlord"> | string | null
    vatRegistered?: BoolFilter<"Landlord"> | boolean
    createdAt?: DateTimeFilter<"Landlord"> | Date | string
    updatedAt?: DateTimeFilter<"Landlord"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Landlord"> | Date | string | null
    properties?: PropertyListRelationFilter
  }, "id" | "code">

  export type LandlordOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    alternativePhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    taxPin?: SortOrderInput | SortOrder
    vatRegistered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LandlordCountOrderByAggregateInput
    _max?: LandlordMaxOrderByAggregateInput
    _min?: LandlordMinOrderByAggregateInput
  }

  export type LandlordScalarWhereWithAggregatesInput = {
    AND?: LandlordScalarWhereWithAggregatesInput | LandlordScalarWhereWithAggregatesInput[]
    OR?: LandlordScalarWhereWithAggregatesInput[]
    NOT?: LandlordScalarWhereWithAggregatesInput | LandlordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Landlord"> | string
    code?: StringWithAggregatesFilter<"Landlord"> | string
    name?: StringWithAggregatesFilter<"Landlord"> | string
    email?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    alternativePhone?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    address?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    city?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    country?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    bankBranch?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    accountName?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    taxPin?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    vatRegistered?: BoolWithAggregatesFilter<"Landlord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Landlord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Landlord"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Landlord"> | Date | string | null
  }

  export type PropertyCategoryWhereInput = {
    AND?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    OR?: PropertyCategoryWhereInput[]
    NOT?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    id?: StringFilter<"PropertyCategory"> | string
    name?: StringFilter<"PropertyCategory"> | string
    description?: StringNullableFilter<"PropertyCategory"> | string | null
    code?: StringNullableFilter<"PropertyCategory"> | string | null
    createdAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    properties?: PropertyListRelationFilter
  }

  export type PropertyCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type PropertyCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    OR?: PropertyCategoryWhereInput[]
    NOT?: PropertyCategoryWhereInput | PropertyCategoryWhereInput[]
    description?: StringNullableFilter<"PropertyCategory"> | string | null
    createdAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyCategory"> | Date | string
    properties?: PropertyListRelationFilter
  }, "id" | "name" | "code">

  export type PropertyCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCategoryCountOrderByAggregateInput
    _max?: PropertyCategoryMaxOrderByAggregateInput
    _min?: PropertyCategoryMinOrderByAggregateInput
  }

  export type PropertyCategoryScalarWhereWithAggregatesInput = {
    AND?: PropertyCategoryScalarWhereWithAggregatesInput | PropertyCategoryScalarWhereWithAggregatesInput[]
    OR?: PropertyCategoryScalarWhereWithAggregatesInput[]
    NOT?: PropertyCategoryScalarWhereWithAggregatesInput | PropertyCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyCategory"> | string
    name?: StringWithAggregatesFilter<"PropertyCategory"> | string
    description?: StringNullableWithAggregatesFilter<"PropertyCategory"> | string | null
    code?: StringNullableWithAggregatesFilter<"PropertyCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyCategory"> | Date | string
  }

  export type PropertyTypeWhereInput = {
    AND?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    OR?: PropertyTypeWhereInput[]
    NOT?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    id?: StringFilter<"PropertyType"> | string
    name?: StringFilter<"PropertyType"> | string
    description?: StringNullableFilter<"PropertyType"> | string | null
    code?: StringNullableFilter<"PropertyType"> | string | null
    createdAt?: DateTimeFilter<"PropertyType"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyType"> | Date | string
    properties?: PropertyListRelationFilter
  }

  export type PropertyTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type PropertyTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    OR?: PropertyTypeWhereInput[]
    NOT?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    description?: StringNullableFilter<"PropertyType"> | string | null
    createdAt?: DateTimeFilter<"PropertyType"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyType"> | Date | string
    properties?: PropertyListRelationFilter
  }, "id" | "name" | "code">

  export type PropertyTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyTypeCountOrderByAggregateInput
    _max?: PropertyTypeMaxOrderByAggregateInput
    _min?: PropertyTypeMinOrderByAggregateInput
  }

  export type PropertyTypeScalarWhereWithAggregatesInput = {
    AND?: PropertyTypeScalarWhereWithAggregatesInput | PropertyTypeScalarWhereWithAggregatesInput[]
    OR?: PropertyTypeScalarWhereWithAggregatesInput[]
    NOT?: PropertyTypeScalarWhereWithAggregatesInput | PropertyTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyType"> | string
    name?: StringWithAggregatesFilter<"PropertyType"> | string
    description?: StringNullableWithAggregatesFilter<"PropertyType"> | string | null
    code?: StringNullableWithAggregatesFilter<"PropertyType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyType"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    code?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    sequence?: IntNullableFilter<"Unit"> | number | null
    propertyId?: StringFilter<"Unit"> | string
    quotedPrice?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    baseRent?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Unit"> | string
    areaSqFt?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    chargePlan?: StringNullableFilter<"Unit"> | string | null
    floor?: IntNullableFilter<"Unit"> | number | null
    bedrooms?: IntNullableFilter<"Unit"> | number | null
    bathrooms?: IntNullableFilter<"Unit"> | number | null
    furnished?: BoolFilter<"Unit"> | boolean
    outSourceParking?: StringNullableFilter<"Unit"> | string | null
    unitTypeId?: StringNullableFilter<"Unit"> | string | null
    ownerOccupied?: BoolFilter<"Unit"> | boolean
    electricityAcno?: StringNullableFilter<"Unit"> | string | null
    waterAcno?: StringNullableFilter<"Unit"> | string | null
    electricityMeethno?: StringNullableFilter<"Unit"> | string | null
    waterMeethno?: StringNullableFilter<"Unit"> | string | null
    takeOnLettingDate?: DateTimeNullableFilter<"Unit"> | Date | string | null
    tenantResidentCodeCounter?: IntNullableFilter<"Unit"> | number | null
    apartmentNotes?: StringNullableFilter<"Unit"> | string | null
    status?: EnumUnitStatusFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    unitType?: XOR<UnitTypeNullableScalarRelationFilter, UnitTypeWhereInput> | null
    leases?: LeaseListRelationFilter
    serviceCharges?: UnitServiceChargeListRelationFilter
    meterNumbers?: UnitMeterNumberListRelationFilter
    features?: UnitFeatureListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    sequence?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    baseRent?: SortOrderInput | SortOrder
    basePerUnitArea?: SortOrderInput | SortOrder
    currency?: SortOrder
    areaSqFt?: SortOrderInput | SortOrder
    chargePlan?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    furnished?: SortOrder
    outSourceParking?: SortOrderInput | SortOrder
    unitTypeId?: SortOrderInput | SortOrder
    ownerOccupied?: SortOrder
    electricityAcno?: SortOrderInput | SortOrder
    waterAcno?: SortOrderInput | SortOrder
    electricityMeethno?: SortOrderInput | SortOrder
    waterMeethno?: SortOrderInput | SortOrder
    takeOnLettingDate?: SortOrderInput | SortOrder
    tenantResidentCodeCounter?: SortOrderInput | SortOrder
    apartmentNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
    unitType?: UnitTypeOrderByWithRelationInput
    leases?: LeaseOrderByRelationAggregateInput
    serviceCharges?: UnitServiceChargeOrderByRelationAggregateInput
    meterNumbers?: UnitMeterNumberOrderByRelationAggregateInput
    features?: UnitFeatureOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    name?: StringFilter<"Unit"> | string
    sequence?: IntNullableFilter<"Unit"> | number | null
    propertyId?: StringFilter<"Unit"> | string
    quotedPrice?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    baseRent?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Unit"> | string
    areaSqFt?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    chargePlan?: StringNullableFilter<"Unit"> | string | null
    floor?: IntNullableFilter<"Unit"> | number | null
    bedrooms?: IntNullableFilter<"Unit"> | number | null
    bathrooms?: IntNullableFilter<"Unit"> | number | null
    furnished?: BoolFilter<"Unit"> | boolean
    outSourceParking?: StringNullableFilter<"Unit"> | string | null
    unitTypeId?: StringNullableFilter<"Unit"> | string | null
    ownerOccupied?: BoolFilter<"Unit"> | boolean
    electricityAcno?: StringNullableFilter<"Unit"> | string | null
    waterAcno?: StringNullableFilter<"Unit"> | string | null
    electricityMeethno?: StringNullableFilter<"Unit"> | string | null
    waterMeethno?: StringNullableFilter<"Unit"> | string | null
    takeOnLettingDate?: DateTimeNullableFilter<"Unit"> | Date | string | null
    tenantResidentCodeCounter?: IntNullableFilter<"Unit"> | number | null
    apartmentNotes?: StringNullableFilter<"Unit"> | string | null
    status?: EnumUnitStatusFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    unitType?: XOR<UnitTypeNullableScalarRelationFilter, UnitTypeWhereInput> | null
    leases?: LeaseListRelationFilter
    serviceCharges?: UnitServiceChargeListRelationFilter
    meterNumbers?: UnitMeterNumberListRelationFilter
    features?: UnitFeatureListRelationFilter
  }, "id" | "code">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    sequence?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    baseRent?: SortOrderInput | SortOrder
    basePerUnitArea?: SortOrderInput | SortOrder
    currency?: SortOrder
    areaSqFt?: SortOrderInput | SortOrder
    chargePlan?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    furnished?: SortOrder
    outSourceParking?: SortOrderInput | SortOrder
    unitTypeId?: SortOrderInput | SortOrder
    ownerOccupied?: SortOrder
    electricityAcno?: SortOrderInput | SortOrder
    waterAcno?: SortOrderInput | SortOrder
    electricityMeethno?: SortOrderInput | SortOrder
    waterMeethno?: SortOrderInput | SortOrder
    takeOnLettingDate?: SortOrderInput | SortOrder
    tenantResidentCodeCounter?: SortOrderInput | SortOrder
    apartmentNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    code?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    sequence?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    propertyId?: StringWithAggregatesFilter<"Unit"> | string
    quotedPrice?: DecimalNullableWithAggregatesFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    baseRent?: DecimalNullableWithAggregatesFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: DecimalNullableWithAggregatesFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"Unit"> | string
    areaSqFt?: DecimalNullableWithAggregatesFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    chargePlan?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    floor?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    bedrooms?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    bathrooms?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    furnished?: BoolWithAggregatesFilter<"Unit"> | boolean
    outSourceParking?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    unitTypeId?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    ownerOccupied?: BoolWithAggregatesFilter<"Unit"> | boolean
    electricityAcno?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    waterAcno?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    electricityMeethno?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    waterMeethno?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    takeOnLettingDate?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
    tenantResidentCodeCounter?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    apartmentNotes?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    status?: EnumUnitStatusWithAggregatesFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
  }

  export type UnitTypeWhereInput = {
    AND?: UnitTypeWhereInput | UnitTypeWhereInput[]
    OR?: UnitTypeWhereInput[]
    NOT?: UnitTypeWhereInput | UnitTypeWhereInput[]
    id?: StringFilter<"UnitType"> | string
    name?: StringFilter<"UnitType"> | string
    description?: StringNullableFilter<"UnitType"> | string | null
    createdAt?: DateTimeFilter<"UnitType"> | Date | string
    updatedAt?: DateTimeFilter<"UnitType"> | Date | string
    units?: UnitListRelationFilter
  }

  export type UnitTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    units?: UnitOrderByRelationAggregateInput
  }

  export type UnitTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: UnitTypeWhereInput | UnitTypeWhereInput[]
    OR?: UnitTypeWhereInput[]
    NOT?: UnitTypeWhereInput | UnitTypeWhereInput[]
    description?: StringNullableFilter<"UnitType"> | string | null
    createdAt?: DateTimeFilter<"UnitType"> | Date | string
    updatedAt?: DateTimeFilter<"UnitType"> | Date | string
    units?: UnitListRelationFilter
  }, "id" | "name">

  export type UnitTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitTypeCountOrderByAggregateInput
    _max?: UnitTypeMaxOrderByAggregateInput
    _min?: UnitTypeMinOrderByAggregateInput
  }

  export type UnitTypeScalarWhereWithAggregatesInput = {
    AND?: UnitTypeScalarWhereWithAggregatesInput | UnitTypeScalarWhereWithAggregatesInput[]
    OR?: UnitTypeScalarWhereWithAggregatesInput[]
    NOT?: UnitTypeScalarWhereWithAggregatesInput | UnitTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitType"> | string
    name?: StringWithAggregatesFilter<"UnitType"> | string
    description?: StringNullableWithAggregatesFilter<"UnitType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitType"> | Date | string
  }

  export type UnitServiceChargeWhereInput = {
    AND?: UnitServiceChargeWhereInput | UnitServiceChargeWhereInput[]
    OR?: UnitServiceChargeWhereInput[]
    NOT?: UnitServiceChargeWhereInput | UnitServiceChargeWhereInput[]
    id?: StringFilter<"UnitServiceCharge"> | string
    unitId?: StringFilter<"UnitServiceCharge"> | string
    serviceUtilityAmenity?: StringFilter<"UnitServiceCharge"> | string
    costPerArea?: DecimalNullableFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"UnitServiceCharge"> | Date | string
    updatedAt?: DateTimeFilter<"UnitServiceCharge"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitServiceChargeOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    serviceUtilityAmenity?: SortOrder
    costPerArea?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type UnitServiceChargeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitServiceChargeWhereInput | UnitServiceChargeWhereInput[]
    OR?: UnitServiceChargeWhereInput[]
    NOT?: UnitServiceChargeWhereInput | UnitServiceChargeWhereInput[]
    unitId?: StringFilter<"UnitServiceCharge"> | string
    serviceUtilityAmenity?: StringFilter<"UnitServiceCharge"> | string
    costPerArea?: DecimalNullableFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"UnitServiceCharge"> | Date | string
    updatedAt?: DateTimeFilter<"UnitServiceCharge"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitServiceChargeOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    serviceUtilityAmenity?: SortOrder
    costPerArea?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitServiceChargeCountOrderByAggregateInput
    _avg?: UnitServiceChargeAvgOrderByAggregateInput
    _max?: UnitServiceChargeMaxOrderByAggregateInput
    _min?: UnitServiceChargeMinOrderByAggregateInput
    _sum?: UnitServiceChargeSumOrderByAggregateInput
  }

  export type UnitServiceChargeScalarWhereWithAggregatesInput = {
    AND?: UnitServiceChargeScalarWhereWithAggregatesInput | UnitServiceChargeScalarWhereWithAggregatesInput[]
    OR?: UnitServiceChargeScalarWhereWithAggregatesInput[]
    NOT?: UnitServiceChargeScalarWhereWithAggregatesInput | UnitServiceChargeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitServiceCharge"> | string
    unitId?: StringWithAggregatesFilter<"UnitServiceCharge"> | string
    serviceUtilityAmenity?: StringWithAggregatesFilter<"UnitServiceCharge"> | string
    costPerArea?: DecimalNullableWithAggregatesFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalWithAggregatesFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"UnitServiceCharge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitServiceCharge"> | Date | string
  }

  export type UnitMeterNumberWhereInput = {
    AND?: UnitMeterNumberWhereInput | UnitMeterNumberWhereInput[]
    OR?: UnitMeterNumberWhereInput[]
    NOT?: UnitMeterNumberWhereInput | UnitMeterNumberWhereInput[]
    id?: StringFilter<"UnitMeterNumber"> | string
    unitId?: StringFilter<"UnitMeterNumber"> | string
    meterNo?: StringFilter<"UnitMeterNumber"> | string
    readingSetup?: StringNullableFilter<"UnitMeterNumber"> | string | null
    createdAt?: DateTimeFilter<"UnitMeterNumber"> | Date | string
    updatedAt?: DateTimeFilter<"UnitMeterNumber"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitMeterNumberOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    meterNo?: SortOrder
    readingSetup?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type UnitMeterNumberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitMeterNumberWhereInput | UnitMeterNumberWhereInput[]
    OR?: UnitMeterNumberWhereInput[]
    NOT?: UnitMeterNumberWhereInput | UnitMeterNumberWhereInput[]
    unitId?: StringFilter<"UnitMeterNumber"> | string
    meterNo?: StringFilter<"UnitMeterNumber"> | string
    readingSetup?: StringNullableFilter<"UnitMeterNumber"> | string | null
    createdAt?: DateTimeFilter<"UnitMeterNumber"> | Date | string
    updatedAt?: DateTimeFilter<"UnitMeterNumber"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitMeterNumberOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    meterNo?: SortOrder
    readingSetup?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitMeterNumberCountOrderByAggregateInput
    _max?: UnitMeterNumberMaxOrderByAggregateInput
    _min?: UnitMeterNumberMinOrderByAggregateInput
  }

  export type UnitMeterNumberScalarWhereWithAggregatesInput = {
    AND?: UnitMeterNumberScalarWhereWithAggregatesInput | UnitMeterNumberScalarWhereWithAggregatesInput[]
    OR?: UnitMeterNumberScalarWhereWithAggregatesInput[]
    NOT?: UnitMeterNumberScalarWhereWithAggregatesInput | UnitMeterNumberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitMeterNumber"> | string
    unitId?: StringWithAggregatesFilter<"UnitMeterNumber"> | string
    meterNo?: StringWithAggregatesFilter<"UnitMeterNumber"> | string
    readingSetup?: StringNullableWithAggregatesFilter<"UnitMeterNumber"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitMeterNumber"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitMeterNumber"> | Date | string
  }

  export type UnitFeatureWhereInput = {
    AND?: UnitFeatureWhereInput | UnitFeatureWhereInput[]
    OR?: UnitFeatureWhereInput[]
    NOT?: UnitFeatureWhereInput | UnitFeatureWhereInput[]
    id?: StringFilter<"UnitFeature"> | string
    unitId?: StringFilter<"UnitFeature"> | string
    name?: StringFilter<"UnitFeature"> | string
    featureType?: StringNullableFilter<"UnitFeature"> | string | null
    createdAt?: DateTimeFilter<"UnitFeature"> | Date | string
    updatedAt?: DateTimeFilter<"UnitFeature"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitFeatureOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    featureType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type UnitFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitFeatureWhereInput | UnitFeatureWhereInput[]
    OR?: UnitFeatureWhereInput[]
    NOT?: UnitFeatureWhereInput | UnitFeatureWhereInput[]
    unitId?: StringFilter<"UnitFeature"> | string
    name?: StringFilter<"UnitFeature"> | string
    featureType?: StringNullableFilter<"UnitFeature"> | string | null
    createdAt?: DateTimeFilter<"UnitFeature"> | Date | string
    updatedAt?: DateTimeFilter<"UnitFeature"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    featureType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitFeatureCountOrderByAggregateInput
    _max?: UnitFeatureMaxOrderByAggregateInput
    _min?: UnitFeatureMinOrderByAggregateInput
  }

  export type UnitFeatureScalarWhereWithAggregatesInput = {
    AND?: UnitFeatureScalarWhereWithAggregatesInput | UnitFeatureScalarWhereWithAggregatesInput[]
    OR?: UnitFeatureScalarWhereWithAggregatesInput[]
    NOT?: UnitFeatureScalarWhereWithAggregatesInput | UnitFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitFeature"> | string
    unitId?: StringWithAggregatesFilter<"UnitFeature"> | string
    name?: StringWithAggregatesFilter<"UnitFeature"> | string
    featureType?: StringNullableWithAggregatesFilter<"UnitFeature"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitFeature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitFeature"> | Date | string
  }

  export type PropertyStandingChargeWhereInput = {
    AND?: PropertyStandingChargeWhereInput | PropertyStandingChargeWhereInput[]
    OR?: PropertyStandingChargeWhereInput[]
    NOT?: PropertyStandingChargeWhereInput | PropertyStandingChargeWhereInput[]
    id?: StringFilter<"PropertyStandingCharge"> | string
    propertyId?: StringFilter<"PropertyStandingCharge"> | string
    chargeUtility?: StringFilter<"PropertyStandingCharge"> | string
    chargeMode?: StringFilter<"PropertyStandingCharge"> | string
    billingCurrency?: StringFilter<"PropertyStandingCharge"> | string
    costPerArea?: DecimalNullableFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFilter<"PropertyStandingCharge"> | boolean
    createdAt?: DateTimeFilter<"PropertyStandingCharge"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyStandingCharge"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyStandingChargeOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    chargeUtility?: SortOrder
    chargeMode?: SortOrder
    billingCurrency?: SortOrder
    costPerArea?: SortOrderInput | SortOrder
    chargeValue?: SortOrder
    vatRate?: SortOrderInput | SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyStandingChargeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyStandingChargeWhereInput | PropertyStandingChargeWhereInput[]
    OR?: PropertyStandingChargeWhereInput[]
    NOT?: PropertyStandingChargeWhereInput | PropertyStandingChargeWhereInput[]
    propertyId?: StringFilter<"PropertyStandingCharge"> | string
    chargeUtility?: StringFilter<"PropertyStandingCharge"> | string
    chargeMode?: StringFilter<"PropertyStandingCharge"> | string
    billingCurrency?: StringFilter<"PropertyStandingCharge"> | string
    costPerArea?: DecimalNullableFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFilter<"PropertyStandingCharge"> | boolean
    createdAt?: DateTimeFilter<"PropertyStandingCharge"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyStandingCharge"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyStandingChargeOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    chargeUtility?: SortOrder
    chargeMode?: SortOrder
    billingCurrency?: SortOrder
    costPerArea?: SortOrderInput | SortOrder
    chargeValue?: SortOrder
    vatRate?: SortOrderInput | SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyStandingChargeCountOrderByAggregateInput
    _avg?: PropertyStandingChargeAvgOrderByAggregateInput
    _max?: PropertyStandingChargeMaxOrderByAggregateInput
    _min?: PropertyStandingChargeMinOrderByAggregateInput
    _sum?: PropertyStandingChargeSumOrderByAggregateInput
  }

  export type PropertyStandingChargeScalarWhereWithAggregatesInput = {
    AND?: PropertyStandingChargeScalarWhereWithAggregatesInput | PropertyStandingChargeScalarWhereWithAggregatesInput[]
    OR?: PropertyStandingChargeScalarWhereWithAggregatesInput[]
    NOT?: PropertyStandingChargeScalarWhereWithAggregatesInput | PropertyStandingChargeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyStandingCharge"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyStandingCharge"> | string
    chargeUtility?: StringWithAggregatesFilter<"PropertyStandingCharge"> | string
    chargeMode?: StringWithAggregatesFilter<"PropertyStandingCharge"> | string
    billingCurrency?: StringWithAggregatesFilter<"PropertyStandingCharge"> | string
    costPerArea?: DecimalNullableWithAggregatesFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalWithAggregatesFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableWithAggregatesFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolWithAggregatesFilter<"PropertyStandingCharge"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PropertyStandingCharge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyStandingCharge"> | Date | string
  }

  export type PropertySecurityDepositWhereInput = {
    AND?: PropertySecurityDepositWhereInput | PropertySecurityDepositWhereInput[]
    OR?: PropertySecurityDepositWhereInput[]
    NOT?: PropertySecurityDepositWhereInput | PropertySecurityDepositWhereInput[]
    id?: StringFilter<"PropertySecurityDeposit"> | string
    propertyId?: StringFilter<"PropertySecurityDeposit"> | string
    month?: StringFilter<"PropertySecurityDeposit"> | string
    value?: DecimalFilter<"PropertySecurityDeposit"> | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFilter<"PropertySecurityDeposit"> | boolean
    ofInitialRent?: BoolFilter<"PropertySecurityDeposit"> | boolean
    ofLastEscalation?: BoolFilter<"PropertySecurityDeposit"> | boolean
    excludesWithRent?: BoolFilter<"PropertySecurityDeposit"> | boolean
    createdAt?: DateTimeFilter<"PropertySecurityDeposit"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySecurityDeposit"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertySecurityDepositOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    month?: SortOrder
    value?: SortOrder
    ofRentBillingAmount?: SortOrder
    ofInitialRent?: SortOrder
    ofLastEscalation?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertySecurityDepositWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertySecurityDepositWhereInput | PropertySecurityDepositWhereInput[]
    OR?: PropertySecurityDepositWhereInput[]
    NOT?: PropertySecurityDepositWhereInput | PropertySecurityDepositWhereInput[]
    propertyId?: StringFilter<"PropertySecurityDeposit"> | string
    month?: StringFilter<"PropertySecurityDeposit"> | string
    value?: DecimalFilter<"PropertySecurityDeposit"> | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFilter<"PropertySecurityDeposit"> | boolean
    ofInitialRent?: BoolFilter<"PropertySecurityDeposit"> | boolean
    ofLastEscalation?: BoolFilter<"PropertySecurityDeposit"> | boolean
    excludesWithRent?: BoolFilter<"PropertySecurityDeposit"> | boolean
    createdAt?: DateTimeFilter<"PropertySecurityDeposit"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySecurityDeposit"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertySecurityDepositOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    month?: SortOrder
    value?: SortOrder
    ofRentBillingAmount?: SortOrder
    ofInitialRent?: SortOrder
    ofLastEscalation?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertySecurityDepositCountOrderByAggregateInput
    _avg?: PropertySecurityDepositAvgOrderByAggregateInput
    _max?: PropertySecurityDepositMaxOrderByAggregateInput
    _min?: PropertySecurityDepositMinOrderByAggregateInput
    _sum?: PropertySecurityDepositSumOrderByAggregateInput
  }

  export type PropertySecurityDepositScalarWhereWithAggregatesInput = {
    AND?: PropertySecurityDepositScalarWhereWithAggregatesInput | PropertySecurityDepositScalarWhereWithAggregatesInput[]
    OR?: PropertySecurityDepositScalarWhereWithAggregatesInput[]
    NOT?: PropertySecurityDepositScalarWhereWithAggregatesInput | PropertySecurityDepositScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertySecurityDeposit"> | string
    propertyId?: StringWithAggregatesFilter<"PropertySecurityDeposit"> | string
    month?: StringWithAggregatesFilter<"PropertySecurityDeposit"> | string
    value?: DecimalWithAggregatesFilter<"PropertySecurityDeposit"> | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolWithAggregatesFilter<"PropertySecurityDeposit"> | boolean
    ofInitialRent?: BoolWithAggregatesFilter<"PropertySecurityDeposit"> | boolean
    ofLastEscalation?: BoolWithAggregatesFilter<"PropertySecurityDeposit"> | boolean
    excludesWithRent?: BoolWithAggregatesFilter<"PropertySecurityDeposit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PropertySecurityDeposit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertySecurityDeposit"> | Date | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    accountNumber?: StringFilter<"Tenant"> | string
    code?: StringFilter<"Tenant"> | string
    tenantType?: StringNullableFilter<"Tenant"> | string | null
    surname?: StringFilter<"Tenant"> | string
    otherNames?: StringNullableFilter<"Tenant"> | string | null
    gender?: StringNullableFilter<"Tenant"> | string | null
    email?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringFilter<"Tenant"> | string
    town?: StringNullableFilter<"Tenant"> | string | null
    sendMobileNumber?: BoolFilter<"Tenant"> | boolean
    idNoRegNo?: StringNullableFilter<"Tenant"> | string | null
    taxPin?: StringNullableFilter<"Tenant"> | string | null
    postalAddress?: StringNullableFilter<"Tenant"> | string | null
    postalCode?: StringNullableFilter<"Tenant"> | string | null
    country?: StringNullableFilter<"Tenant"> | string | null
    photoUrl?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    leases?: LeaseListRelationFilter
    emergencyContacts?: TenantEmergencyContactListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    code?: SortOrder
    tenantType?: SortOrderInput | SortOrder
    surname?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    town?: SortOrderInput | SortOrder
    sendMobileNumber?: SortOrder
    idNoRegNo?: SortOrderInput | SortOrder
    taxPin?: SortOrderInput | SortOrder
    postalAddress?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    leases?: LeaseOrderByRelationAggregateInput
    emergencyContacts?: TenantEmergencyContactOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountNumber?: string
    code?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    tenantType?: StringNullableFilter<"Tenant"> | string | null
    surname?: StringFilter<"Tenant"> | string
    otherNames?: StringNullableFilter<"Tenant"> | string | null
    gender?: StringNullableFilter<"Tenant"> | string | null
    email?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringFilter<"Tenant"> | string
    town?: StringNullableFilter<"Tenant"> | string | null
    sendMobileNumber?: BoolFilter<"Tenant"> | boolean
    idNoRegNo?: StringNullableFilter<"Tenant"> | string | null
    taxPin?: StringNullableFilter<"Tenant"> | string | null
    postalAddress?: StringNullableFilter<"Tenant"> | string | null
    postalCode?: StringNullableFilter<"Tenant"> | string | null
    country?: StringNullableFilter<"Tenant"> | string | null
    photoUrl?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    leases?: LeaseListRelationFilter
    emergencyContacts?: TenantEmergencyContactListRelationFilter
  }, "id" | "accountNumber" | "code">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    code?: SortOrder
    tenantType?: SortOrderInput | SortOrder
    surname?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    town?: SortOrderInput | SortOrder
    sendMobileNumber?: SortOrder
    idNoRegNo?: SortOrderInput | SortOrder
    taxPin?: SortOrderInput | SortOrder
    postalAddress?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    accountNumber?: StringWithAggregatesFilter<"Tenant"> | string
    code?: StringWithAggregatesFilter<"Tenant"> | string
    tenantType?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    surname?: StringWithAggregatesFilter<"Tenant"> | string
    otherNames?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    email?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    phone?: StringWithAggregatesFilter<"Tenant"> | string
    town?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    sendMobileNumber?: BoolWithAggregatesFilter<"Tenant"> | boolean
    idNoRegNo?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    taxPin?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    postalAddress?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    country?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
  }

  export type TenantEmergencyContactWhereInput = {
    AND?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    OR?: TenantEmergencyContactWhereInput[]
    NOT?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    id?: StringFilter<"TenantEmergencyContact"> | string
    tenantId?: StringFilter<"TenantEmergencyContact"> | string
    contactName?: StringFilter<"TenantEmergencyContact"> | string
    relationship?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    phone?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    email?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    priority?: IntFilter<"TenantEmergencyContact"> | number
    createdAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantEmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactName?: SortOrder
    relationship?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantEmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    OR?: TenantEmergencyContactWhereInput[]
    NOT?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    tenantId?: StringFilter<"TenantEmergencyContact"> | string
    contactName?: StringFilter<"TenantEmergencyContact"> | string
    relationship?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    phone?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    email?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    priority?: IntFilter<"TenantEmergencyContact"> | number
    createdAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type TenantEmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactName?: SortOrder
    relationship?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantEmergencyContactCountOrderByAggregateInput
    _avg?: TenantEmergencyContactAvgOrderByAggregateInput
    _max?: TenantEmergencyContactMaxOrderByAggregateInput
    _min?: TenantEmergencyContactMinOrderByAggregateInput
    _sum?: TenantEmergencyContactSumOrderByAggregateInput
  }

  export type TenantEmergencyContactScalarWhereWithAggregatesInput = {
    AND?: TenantEmergencyContactScalarWhereWithAggregatesInput | TenantEmergencyContactScalarWhereWithAggregatesInput[]
    OR?: TenantEmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: TenantEmergencyContactScalarWhereWithAggregatesInput | TenantEmergencyContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    tenantId?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    contactName?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    relationship?: StringNullableWithAggregatesFilter<"TenantEmergencyContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"TenantEmergencyContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"TenantEmergencyContact"> | string | null
    priority?: IntWithAggregatesFilter<"TenantEmergencyContact"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantEmergencyContact"> | Date | string
  }

  export type LeaseWhereInput = {
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    id?: StringFilter<"Lease"> | string
    code?: StringFilter<"Lease"> | string
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableFilter<"Lease"> | Date | string | null
    rentAmount?: DecimalFilter<"Lease"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Lease"> | string
    paymentDay?: IntFilter<"Lease"> | number
    securityDeposit?: DecimalNullableFilter<"Lease"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Lease"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type LeaseOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    rentAmount?: SortOrder
    currency?: SortOrder
    paymentDay?: SortOrder
    securityDeposit?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    unit?: UnitOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type LeaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableFilter<"Lease"> | Date | string | null
    rentAmount?: DecimalFilter<"Lease"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Lease"> | string
    paymentDay?: IntFilter<"Lease"> | number
    securityDeposit?: DecimalNullableFilter<"Lease"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Lease"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "code">

  export type LeaseOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    rentAmount?: SortOrder
    currency?: SortOrder
    paymentDay?: SortOrder
    securityDeposit?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LeaseCountOrderByAggregateInput
    _avg?: LeaseAvgOrderByAggregateInput
    _max?: LeaseMaxOrderByAggregateInput
    _min?: LeaseMinOrderByAggregateInput
    _sum?: LeaseSumOrderByAggregateInput
  }

  export type LeaseScalarWhereWithAggregatesInput = {
    AND?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    OR?: LeaseScalarWhereWithAggregatesInput[]
    NOT?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lease"> | string
    code?: StringWithAggregatesFilter<"Lease"> | string
    unitId?: StringWithAggregatesFilter<"Lease"> | string
    tenantId?: StringWithAggregatesFilter<"Lease"> | string
    startDate?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Lease"> | Date | string | null
    rentAmount?: DecimalWithAggregatesFilter<"Lease"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Lease"> | string
    paymentDay?: IntWithAggregatesFilter<"Lease"> | number
    securityDeposit?: DecimalNullableWithAggregatesFilter<"Lease"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusWithAggregatesFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Lease"> | Date | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    leaseId?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    vatAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    leaseId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    vatAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lease?: LeaseOrderByWithRelationInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    leaseId?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    vatAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    leaseId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    vatAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    leaseId?: StringWithAggregatesFilter<"Invoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    vatAmount?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    paidAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    vatAmount?: DecimalNullableFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    vatRate?: SortOrderInput | SortOrder
    vatAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    vatAmount?: DecimalNullableFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    vatRate?: SortOrderInput | SortOrder
    vatAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    vatAmount?: DecimalNullableWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    receiptNumber?: StringFilter<"Payment"> | string
    leaseId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    paymentReference?: StringNullableFilter<"Payment"> | string | null
    mpesaReceiptNumber?: StringNullableFilter<"Payment"> | string | null
    mpesaPhoneNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrderInput | SortOrder
    mpesaReceiptNumber?: SortOrderInput | SortOrder
    mpesaPhoneNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lease?: LeaseOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    receiptNumber?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    leaseId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    paymentReference?: StringNullableFilter<"Payment"> | string | null
    mpesaReceiptNumber?: StringNullableFilter<"Payment"> | string | null
    mpesaPhoneNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id" | "receiptNumber">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrderInput | SortOrder
    mpesaReceiptNumber?: SortOrderInput | SortOrder
    mpesaPhoneNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    receiptNumber?: StringWithAggregatesFilter<"Payment"> | string
    leaseId?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    paymentReference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    mpesaReceiptNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    mpesaPhoneNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    landlord?: LandlordCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
    units?: UnitCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    categoryId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeUncheckedCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landlord?: LandlordUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
    units?: UnitUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUncheckedUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    categoryId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LandlordCreateInput = {
    id?: string
    code: string
    name: string
    email?: string | null
    phone?: string | null
    alternativePhone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    bankName?: string | null
    bankBranch?: string | null
    accountName?: string | null
    accountNumber?: string | null
    taxPin?: string | null
    vatRegistered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyCreateNestedManyWithoutLandlordInput
  }

  export type LandlordUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    email?: string | null
    phone?: string | null
    alternativePhone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    bankName?: string | null
    bankBranch?: string | null
    accountName?: string | null
    accountNumber?: string | null
    taxPin?: string | null
    vatRegistered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutLandlordInput
  }

  export type LandlordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUpdateManyWithoutLandlordNestedInput
  }

  export type LandlordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUncheckedUpdateManyWithoutLandlordNestedInput
  }

  export type LandlordCreateManyInput = {
    id?: string
    code: string
    name: string
    email?: string | null
    phone?: string | null
    alternativePhone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    bankName?: string | null
    bankBranch?: string | null
    accountName?: string | null
    accountNumber?: string | null
    taxPin?: string | null
    vatRegistered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LandlordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LandlordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type PropertyCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PropertyCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutUnitsInput
    unitType?: UnitTypeCreateNestedOneWithoutUnitsInput
    leases?: LeaseCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberCreateNestedManyWithoutUnitInput
    features?: UnitFeatureCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeUncheckedCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberUncheckedCreateNestedManyWithoutUnitInput
    features?: UnitFeatureUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeUpdateOneWithoutUnitsNestedInput
    leases?: LeaseUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUncheckedUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUncheckedUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUpdateManyWithoutUnitTypeNestedInput
  }

  export type UnitTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type UnitTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceChargeCreateInput = {
    id?: string
    serviceUtilityAmenity: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    totalCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutServiceChargesInput
  }

  export type UnitServiceChargeUncheckedCreateInput = {
    id?: string
    unitId: string
    serviceUtilityAmenity: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    totalCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitServiceChargeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceUtilityAmenity?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutServiceChargesNestedInput
  }

  export type UnitServiceChargeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    serviceUtilityAmenity?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceChargeCreateManyInput = {
    id?: string
    unitId: string
    serviceUtilityAmenity: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    totalCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitServiceChargeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceUtilityAmenity?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceChargeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    serviceUtilityAmenity?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMeterNumberCreateInput = {
    id?: string
    meterNo: string
    readingSetup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutMeterNumbersInput
  }

  export type UnitMeterNumberUncheckedCreateInput = {
    id?: string
    unitId: string
    meterNo: string
    readingSetup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitMeterNumberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meterNo?: StringFieldUpdateOperationsInput | string
    readingSetup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutMeterNumbersNestedInput
  }

  export type UnitMeterNumberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    meterNo?: StringFieldUpdateOperationsInput | string
    readingSetup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMeterNumberCreateManyInput = {
    id?: string
    unitId: string
    meterNo: string
    readingSetup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitMeterNumberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meterNo?: StringFieldUpdateOperationsInput | string
    readingSetup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMeterNumberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    meterNo?: StringFieldUpdateOperationsInput | string
    readingSetup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitFeatureCreateInput = {
    id?: string
    name: string
    featureType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutFeaturesInput
  }

  export type UnitFeatureUncheckedCreateInput = {
    id?: string
    unitId: string
    name: string
    featureType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type UnitFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitFeatureCreateManyInput = {
    id?: string
    unitId: string
    name: string
    featureType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStandingChargeCreateInput = {
    id?: string
    chargeUtility: string
    chargeMode: string
    billingCurrency?: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    chargeValue: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutStandingChargesInput
  }

  export type PropertyStandingChargeUncheckedCreateInput = {
    id?: string
    propertyId: string
    chargeUtility: string
    chargeMode: string
    billingCurrency?: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    chargeValue: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyStandingChargeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeUtility?: StringFieldUpdateOperationsInput | string
    chargeMode?: StringFieldUpdateOperationsInput | string
    billingCurrency?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutStandingChargesNestedInput
  }

  export type PropertyStandingChargeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    chargeUtility?: StringFieldUpdateOperationsInput | string
    chargeMode?: StringFieldUpdateOperationsInput | string
    billingCurrency?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStandingChargeCreateManyInput = {
    id?: string
    propertyId: string
    chargeUtility: string
    chargeMode: string
    billingCurrency?: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    chargeValue: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyStandingChargeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeUtility?: StringFieldUpdateOperationsInput | string
    chargeMode?: StringFieldUpdateOperationsInput | string
    billingCurrency?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStandingChargeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    chargeUtility?: StringFieldUpdateOperationsInput | string
    chargeMode?: StringFieldUpdateOperationsInput | string
    billingCurrency?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySecurityDepositCreateInput = {
    id?: string
    month: string
    value: Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutSecurityDepositsInput
  }

  export type PropertySecurityDepositUncheckedCreateInput = {
    id?: string
    propertyId: string
    month: string
    value: Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySecurityDepositUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFieldUpdateOperationsInput | boolean
    ofInitialRent?: BoolFieldUpdateOperationsInput | boolean
    ofLastEscalation?: BoolFieldUpdateOperationsInput | boolean
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutSecurityDepositsNestedInput
  }

  export type PropertySecurityDepositUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFieldUpdateOperationsInput | boolean
    ofInitialRent?: BoolFieldUpdateOperationsInput | boolean
    ofLastEscalation?: BoolFieldUpdateOperationsInput | boolean
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySecurityDepositCreateManyInput = {
    id?: string
    propertyId: string
    month: string
    value: Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySecurityDepositUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFieldUpdateOperationsInput | boolean
    ofInitialRent?: BoolFieldUpdateOperationsInput | boolean
    ofLastEscalation?: BoolFieldUpdateOperationsInput | boolean
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySecurityDepositUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFieldUpdateOperationsInput | boolean
    ofInitialRent?: BoolFieldUpdateOperationsInput | boolean
    ofLastEscalation?: BoolFieldUpdateOperationsInput | boolean
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    accountNumber: string
    code: string
    tenantType?: string | null
    surname: string
    otherNames?: string | null
    gender?: string | null
    email?: string | null
    phone: string
    town?: string | null
    sendMobileNumber?: boolean
    idNoRegNo?: string | null
    taxPin?: string | null
    postalAddress?: string | null
    postalCode?: string | null
    country?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseCreateNestedManyWithoutTenantInput
    emergencyContacts?: TenantEmergencyContactCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    accountNumber: string
    code: string
    tenantType?: string | null
    surname: string
    otherNames?: string | null
    gender?: string | null
    email?: string | null
    phone: string
    town?: string | null
    sendMobileNumber?: boolean
    idNoRegNo?: string | null
    taxPin?: string | null
    postalAddress?: string | null
    postalCode?: string | null
    country?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutTenantInput
    emergencyContacts?: TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUpdateManyWithoutTenantNestedInput
    emergencyContacts?: TenantEmergencyContactUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
    emergencyContacts?: TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    accountNumber: string
    code: string
    tenantType?: string | null
    surname: string
    otherNames?: string | null
    gender?: string | null
    email?: string | null
    phone: string
    town?: string | null
    sendMobileNumber?: boolean
    idNoRegNo?: string | null
    taxPin?: string | null
    postalAddress?: string | null
    postalCode?: string | null
    country?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantEmergencyContactCreateInput = {
    id?: string
    contactName: string
    relationship?: string | null
    phone?: string | null
    email?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmergencyContactsInput
  }

  export type TenantEmergencyContactUncheckedCreateInput = {
    id?: string
    tenantId: string
    contactName: string
    relationship?: string | null
    phone?: string | null
    email?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmergencyContactsNestedInput
  }

  export type TenantEmergencyContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactCreateManyInput = {
    id?: string
    tenantId: string
    contactName: string
    relationship?: string | null
    phone?: string | null
    email?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseCreateInput = {
    id?: string
    code: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutLeasesInput
    tenant: TenantCreateNestedOneWithoutLeasesInput
    invoices?: InvoiceCreateNestedManyWithoutLeaseInput
    payments?: PaymentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateInput = {
    id?: string
    code: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutLeasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeasesNestedInput
    invoices?: InvoiceUpdateManyWithoutLeaseNestedInput
    payments?: PaymentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseCreateManyInput = {
    id?: string
    code: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    leaseId: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    leaseId: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    description: string
    quantity?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    receiptNumber: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    receiptNumber: string
    leaseId: string
    invoiceId?: string | null
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    receiptNumber: string
    leaseId: string
    invoiceId?: string | null
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LandlordNullableScalarRelationFilter = {
    is?: LandlordWhereInput | null
    isNot?: LandlordWhereInput | null
  }

  export type PropertyCategoryNullableScalarRelationFilter = {
    is?: PropertyCategoryWhereInput | null
    isNot?: PropertyCategoryWhereInput | null
  }

  export type PropertyTypeNullableScalarRelationFilter = {
    is?: PropertyTypeWhereInput | null
    isNot?: PropertyTypeWhereInput | null
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type PropertyStandingChargeListRelationFilter = {
    every?: PropertyStandingChargeWhereInput
    some?: PropertyStandingChargeWhereInput
    none?: PropertyStandingChargeWhereInput
  }

  export type PropertySecurityDepositListRelationFilter = {
    every?: PropertySecurityDepositWhereInput
    some?: PropertySecurityDepositWhereInput
    none?: PropertySecurityDepositWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyStandingChargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertySecurityDepositOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    dateAcquired?: SortOrder
    lrNumber?: SortOrder
    country?: SortOrder
    estateArea?: SortOrder
    areaRegion?: SortOrder
    roadStreet?: SortOrder
    specification?: SortOrder
    multiStoryType?: SortOrder
    numberOfFloors?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    specificContactInfo?: SortOrder
    landlordId?: SortOrder
    categoryId?: SortOrder
    propertyTypeId?: SortOrder
    accountLedgerType?: SortOrder
    primaryBankAccount?: SortOrder
    alternativeTaxPin?: SortOrder
    propertyWorkingTaxPin?: SortOrder
    invoicePaymentInfo?: SortOrder
    holderPaymentTerms?: SortOrder
    mpesaPropertyPayNumber?: SortOrder
    disableMpesaStkPush?: SortOrder
    disableMpesaStkNarration?: SortOrder
    tenantReceiptAccountCodeCounter?: SortOrder
    lpgExempted?: SortOrder
    penaltyChargeMode?: SortOrder
    penaltyDay?: SortOrder
    landlordDrawerBank?: SortOrder
    landlordBankBranch?: SortOrder
    landlordAccountName?: SortOrder
    landlordAccountNumber?: SortOrder
    exemptAllSms?: SortOrder
    exemptInvoiceSms?: SortOrder
    exemptGeneralSms?: SortOrder
    exemptHagueSms?: SortOrder
    exemptBalanceSms?: SortOrder
    exemptAllEmail?: SortOrder
    exemptInvoiceEmail?: SortOrder
    exemptGeneralEmail?: SortOrder
    exemptReceiptEmail?: SortOrder
    exemptBalanceEmail?: SortOrder
    excludeInTwoSummaryReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    numberOfFloors?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    tenantReceiptAccountCodeCounter?: SortOrder
    penaltyDay?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    dateAcquired?: SortOrder
    lrNumber?: SortOrder
    country?: SortOrder
    estateArea?: SortOrder
    areaRegion?: SortOrder
    roadStreet?: SortOrder
    specification?: SortOrder
    multiStoryType?: SortOrder
    numberOfFloors?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    specificContactInfo?: SortOrder
    landlordId?: SortOrder
    categoryId?: SortOrder
    propertyTypeId?: SortOrder
    accountLedgerType?: SortOrder
    primaryBankAccount?: SortOrder
    alternativeTaxPin?: SortOrder
    propertyWorkingTaxPin?: SortOrder
    invoicePaymentInfo?: SortOrder
    holderPaymentTerms?: SortOrder
    mpesaPropertyPayNumber?: SortOrder
    disableMpesaStkPush?: SortOrder
    disableMpesaStkNarration?: SortOrder
    tenantReceiptAccountCodeCounter?: SortOrder
    lpgExempted?: SortOrder
    penaltyChargeMode?: SortOrder
    penaltyDay?: SortOrder
    landlordDrawerBank?: SortOrder
    landlordBankBranch?: SortOrder
    landlordAccountName?: SortOrder
    landlordAccountNumber?: SortOrder
    exemptAllSms?: SortOrder
    exemptInvoiceSms?: SortOrder
    exemptGeneralSms?: SortOrder
    exemptHagueSms?: SortOrder
    exemptBalanceSms?: SortOrder
    exemptAllEmail?: SortOrder
    exemptInvoiceEmail?: SortOrder
    exemptGeneralEmail?: SortOrder
    exemptReceiptEmail?: SortOrder
    exemptBalanceEmail?: SortOrder
    excludeInTwoSummaryReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    dateAcquired?: SortOrder
    lrNumber?: SortOrder
    country?: SortOrder
    estateArea?: SortOrder
    areaRegion?: SortOrder
    roadStreet?: SortOrder
    specification?: SortOrder
    multiStoryType?: SortOrder
    numberOfFloors?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    specificContactInfo?: SortOrder
    landlordId?: SortOrder
    categoryId?: SortOrder
    propertyTypeId?: SortOrder
    accountLedgerType?: SortOrder
    primaryBankAccount?: SortOrder
    alternativeTaxPin?: SortOrder
    propertyWorkingTaxPin?: SortOrder
    invoicePaymentInfo?: SortOrder
    holderPaymentTerms?: SortOrder
    mpesaPropertyPayNumber?: SortOrder
    disableMpesaStkPush?: SortOrder
    disableMpesaStkNarration?: SortOrder
    tenantReceiptAccountCodeCounter?: SortOrder
    lpgExempted?: SortOrder
    penaltyChargeMode?: SortOrder
    penaltyDay?: SortOrder
    landlordDrawerBank?: SortOrder
    landlordBankBranch?: SortOrder
    landlordAccountName?: SortOrder
    landlordAccountNumber?: SortOrder
    exemptAllSms?: SortOrder
    exemptInvoiceSms?: SortOrder
    exemptGeneralSms?: SortOrder
    exemptHagueSms?: SortOrder
    exemptBalanceSms?: SortOrder
    exemptAllEmail?: SortOrder
    exemptInvoiceEmail?: SortOrder
    exemptGeneralEmail?: SortOrder
    exemptReceiptEmail?: SortOrder
    exemptBalanceEmail?: SortOrder
    excludeInTwoSummaryReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    numberOfFloors?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    tenantReceiptAccountCodeCounter?: SortOrder
    penaltyDay?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LandlordCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    alternativePhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    bankName?: SortOrder
    bankBranch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    taxPin?: SortOrder
    vatRegistered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LandlordMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    alternativePhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    bankName?: SortOrder
    bankBranch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    taxPin?: SortOrder
    vatRegistered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LandlordMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    alternativePhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    bankName?: SortOrder
    bankBranch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    taxPin?: SortOrder
    vatRegistered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PropertyCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type UnitTypeNullableScalarRelationFilter = {
    is?: UnitTypeWhereInput | null
    isNot?: UnitTypeWhereInput | null
  }

  export type LeaseListRelationFilter = {
    every?: LeaseWhereInput
    some?: LeaseWhereInput
    none?: LeaseWhereInput
  }

  export type UnitServiceChargeListRelationFilter = {
    every?: UnitServiceChargeWhereInput
    some?: UnitServiceChargeWhereInput
    none?: UnitServiceChargeWhereInput
  }

  export type UnitMeterNumberListRelationFilter = {
    every?: UnitMeterNumberWhereInput
    some?: UnitMeterNumberWhereInput
    none?: UnitMeterNumberWhereInput
  }

  export type UnitFeatureListRelationFilter = {
    every?: UnitFeatureWhereInput
    some?: UnitFeatureWhereInput
    none?: UnitFeatureWhereInput
  }

  export type LeaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitServiceChargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitMeterNumberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    sequence?: SortOrder
    propertyId?: SortOrder
    quotedPrice?: SortOrder
    baseRent?: SortOrder
    basePerUnitArea?: SortOrder
    currency?: SortOrder
    areaSqFt?: SortOrder
    chargePlan?: SortOrder
    floor?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    furnished?: SortOrder
    outSourceParking?: SortOrder
    unitTypeId?: SortOrder
    ownerOccupied?: SortOrder
    electricityAcno?: SortOrder
    waterAcno?: SortOrder
    electricityMeethno?: SortOrder
    waterMeethno?: SortOrder
    takeOnLettingDate?: SortOrder
    tenantResidentCodeCounter?: SortOrder
    apartmentNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    sequence?: SortOrder
    quotedPrice?: SortOrder
    baseRent?: SortOrder
    basePerUnitArea?: SortOrder
    areaSqFt?: SortOrder
    floor?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    tenantResidentCodeCounter?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    sequence?: SortOrder
    propertyId?: SortOrder
    quotedPrice?: SortOrder
    baseRent?: SortOrder
    basePerUnitArea?: SortOrder
    currency?: SortOrder
    areaSqFt?: SortOrder
    chargePlan?: SortOrder
    floor?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    furnished?: SortOrder
    outSourceParking?: SortOrder
    unitTypeId?: SortOrder
    ownerOccupied?: SortOrder
    electricityAcno?: SortOrder
    waterAcno?: SortOrder
    electricityMeethno?: SortOrder
    waterMeethno?: SortOrder
    takeOnLettingDate?: SortOrder
    tenantResidentCodeCounter?: SortOrder
    apartmentNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    sequence?: SortOrder
    propertyId?: SortOrder
    quotedPrice?: SortOrder
    baseRent?: SortOrder
    basePerUnitArea?: SortOrder
    currency?: SortOrder
    areaSqFt?: SortOrder
    chargePlan?: SortOrder
    floor?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    furnished?: SortOrder
    outSourceParking?: SortOrder
    unitTypeId?: SortOrder
    ownerOccupied?: SortOrder
    electricityAcno?: SortOrder
    waterAcno?: SortOrder
    electricityMeethno?: SortOrder
    waterMeethno?: SortOrder
    takeOnLettingDate?: SortOrder
    tenantResidentCodeCounter?: SortOrder
    apartmentNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    sequence?: SortOrder
    quotedPrice?: SortOrder
    baseRent?: SortOrder
    basePerUnitArea?: SortOrder
    areaSqFt?: SortOrder
    floor?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    tenantResidentCodeCounter?: SortOrder
  }

  export type EnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type UnitTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type UnitServiceChargeCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    serviceUtilityAmenity?: SortOrder
    costPerArea?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitServiceChargeAvgOrderByAggregateInput = {
    costPerArea?: SortOrder
    totalCost?: SortOrder
  }

  export type UnitServiceChargeMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    serviceUtilityAmenity?: SortOrder
    costPerArea?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitServiceChargeMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    serviceUtilityAmenity?: SortOrder
    costPerArea?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitServiceChargeSumOrderByAggregateInput = {
    costPerArea?: SortOrder
    totalCost?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UnitMeterNumberCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    meterNo?: SortOrder
    readingSetup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMeterNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    meterNo?: SortOrder
    readingSetup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMeterNumberMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    meterNo?: SortOrder
    readingSetup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    featureType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    featureType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    featureType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyStandingChargeCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    chargeUtility?: SortOrder
    chargeMode?: SortOrder
    billingCurrency?: SortOrder
    costPerArea?: SortOrder
    chargeValue?: SortOrder
    vatRate?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyStandingChargeAvgOrderByAggregateInput = {
    costPerArea?: SortOrder
    chargeValue?: SortOrder
    vatRate?: SortOrder
  }

  export type PropertyStandingChargeMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    chargeUtility?: SortOrder
    chargeMode?: SortOrder
    billingCurrency?: SortOrder
    costPerArea?: SortOrder
    chargeValue?: SortOrder
    vatRate?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyStandingChargeMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    chargeUtility?: SortOrder
    chargeMode?: SortOrder
    billingCurrency?: SortOrder
    costPerArea?: SortOrder
    chargeValue?: SortOrder
    vatRate?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyStandingChargeSumOrderByAggregateInput = {
    costPerArea?: SortOrder
    chargeValue?: SortOrder
    vatRate?: SortOrder
  }

  export type PropertySecurityDepositCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    month?: SortOrder
    value?: SortOrder
    ofRentBillingAmount?: SortOrder
    ofInitialRent?: SortOrder
    ofLastEscalation?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySecurityDepositAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PropertySecurityDepositMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    month?: SortOrder
    value?: SortOrder
    ofRentBillingAmount?: SortOrder
    ofInitialRent?: SortOrder
    ofLastEscalation?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySecurityDepositMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    month?: SortOrder
    value?: SortOrder
    ofRentBillingAmount?: SortOrder
    ofInitialRent?: SortOrder
    ofLastEscalation?: SortOrder
    excludesWithRent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySecurityDepositSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TenantEmergencyContactListRelationFilter = {
    every?: TenantEmergencyContactWhereInput
    some?: TenantEmergencyContactWhereInput
    none?: TenantEmergencyContactWhereInput
  }

  export type TenantEmergencyContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    code?: SortOrder
    tenantType?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    town?: SortOrder
    sendMobileNumber?: SortOrder
    idNoRegNo?: SortOrder
    taxPin?: SortOrder
    postalAddress?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    code?: SortOrder
    tenantType?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    town?: SortOrder
    sendMobileNumber?: SortOrder
    idNoRegNo?: SortOrder
    taxPin?: SortOrder
    postalAddress?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    code?: SortOrder
    tenantType?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    town?: SortOrder
    sendMobileNumber?: SortOrder
    idNoRegNo?: SortOrder
    taxPin?: SortOrder
    postalAddress?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantEmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactName?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantEmergencyContactAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type TenantEmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactName?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantEmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactName?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantEmergencyContactSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaseCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    currency?: SortOrder
    paymentDay?: SortOrder
    securityDeposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaseAvgOrderByAggregateInput = {
    rentAmount?: SortOrder
    paymentDay?: SortOrder
    securityDeposit?: SortOrder
  }

  export type LeaseMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    currency?: SortOrder
    paymentDay?: SortOrder
    securityDeposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaseMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    currency?: SortOrder
    paymentDay?: SortOrder
    securityDeposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaseSumOrderByAggregateInput = {
    rentAmount?: SortOrder
    paymentDay?: SortOrder
    securityDeposit?: SortOrder
  }

  export type EnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type LeaseScalarRelationFilter = {
    is?: LeaseWhereInput
    isNot?: LeaseWhereInput
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    leaseId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    leaseId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    leaseId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrder
    mpesaReceiptNumber?: SortOrder
    mpesaPhoneNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrder
    mpesaReceiptNumber?: SortOrder
    mpesaPhoneNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentReference?: SortOrder
    mpesaReceiptNumber?: SortOrder
    mpesaPhoneNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LandlordCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<LandlordCreateWithoutPropertiesInput, LandlordUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: LandlordCreateOrConnectWithoutPropertiesInput
    connect?: LandlordWhereUniqueInput
  }

  export type PropertyCategoryCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyCategoryCreateOrConnectWithoutPropertiesInput
    connect?: PropertyCategoryWhereUniqueInput
  }

  export type PropertyTypeCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutPropertiesInput
    connect?: PropertyTypeWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type PropertyStandingChargeCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyStandingChargeCreateWithoutPropertyInput, PropertyStandingChargeUncheckedCreateWithoutPropertyInput> | PropertyStandingChargeCreateWithoutPropertyInput[] | PropertyStandingChargeUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStandingChargeCreateOrConnectWithoutPropertyInput | PropertyStandingChargeCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyStandingChargeCreateManyPropertyInputEnvelope
    connect?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
  }

  export type PropertySecurityDepositCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertySecurityDepositCreateWithoutPropertyInput, PropertySecurityDepositUncheckedCreateWithoutPropertyInput> | PropertySecurityDepositCreateWithoutPropertyInput[] | PropertySecurityDepositUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySecurityDepositCreateOrConnectWithoutPropertyInput | PropertySecurityDepositCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertySecurityDepositCreateManyPropertyInputEnvelope
    connect?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type PropertyStandingChargeUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyStandingChargeCreateWithoutPropertyInput, PropertyStandingChargeUncheckedCreateWithoutPropertyInput> | PropertyStandingChargeCreateWithoutPropertyInput[] | PropertyStandingChargeUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStandingChargeCreateOrConnectWithoutPropertyInput | PropertyStandingChargeCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyStandingChargeCreateManyPropertyInputEnvelope
    connect?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
  }

  export type PropertySecurityDepositUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertySecurityDepositCreateWithoutPropertyInput, PropertySecurityDepositUncheckedCreateWithoutPropertyInput> | PropertySecurityDepositCreateWithoutPropertyInput[] | PropertySecurityDepositUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySecurityDepositCreateOrConnectWithoutPropertyInput | PropertySecurityDepositCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertySecurityDepositCreateManyPropertyInputEnvelope
    connect?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LandlordUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<LandlordCreateWithoutPropertiesInput, LandlordUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: LandlordCreateOrConnectWithoutPropertiesInput
    upsert?: LandlordUpsertWithoutPropertiesInput
    disconnect?: LandlordWhereInput | boolean
    delete?: LandlordWhereInput | boolean
    connect?: LandlordWhereUniqueInput
    update?: XOR<XOR<LandlordUpdateToOneWithWhereWithoutPropertiesInput, LandlordUpdateWithoutPropertiesInput>, LandlordUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCategoryUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyCategoryCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyCategoryUpsertWithoutPropertiesInput
    disconnect?: PropertyCategoryWhereInput | boolean
    delete?: PropertyCategoryWhereInput | boolean
    connect?: PropertyCategoryWhereUniqueInput
    update?: XOR<XOR<PropertyCategoryUpdateToOneWithWhereWithoutPropertiesInput, PropertyCategoryUpdateWithoutPropertiesInput>, PropertyCategoryUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyTypeUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyTypeUpsertWithoutPropertiesInput
    disconnect?: PropertyTypeWhereInput | boolean
    delete?: PropertyTypeWhereInput | boolean
    connect?: PropertyTypeWhereUniqueInput
    update?: XOR<XOR<PropertyTypeUpdateToOneWithWhereWithoutPropertiesInput, PropertyTypeUpdateWithoutPropertiesInput>, PropertyTypeUncheckedUpdateWithoutPropertiesInput>
  }

  export type UnitUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type PropertyStandingChargeUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyStandingChargeCreateWithoutPropertyInput, PropertyStandingChargeUncheckedCreateWithoutPropertyInput> | PropertyStandingChargeCreateWithoutPropertyInput[] | PropertyStandingChargeUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStandingChargeCreateOrConnectWithoutPropertyInput | PropertyStandingChargeCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyStandingChargeUpsertWithWhereUniqueWithoutPropertyInput | PropertyStandingChargeUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyStandingChargeCreateManyPropertyInputEnvelope
    set?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    disconnect?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    delete?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    connect?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    update?: PropertyStandingChargeUpdateWithWhereUniqueWithoutPropertyInput | PropertyStandingChargeUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyStandingChargeUpdateManyWithWhereWithoutPropertyInput | PropertyStandingChargeUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyStandingChargeScalarWhereInput | PropertyStandingChargeScalarWhereInput[]
  }

  export type PropertySecurityDepositUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertySecurityDepositCreateWithoutPropertyInput, PropertySecurityDepositUncheckedCreateWithoutPropertyInput> | PropertySecurityDepositCreateWithoutPropertyInput[] | PropertySecurityDepositUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySecurityDepositCreateOrConnectWithoutPropertyInput | PropertySecurityDepositCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertySecurityDepositUpsertWithWhereUniqueWithoutPropertyInput | PropertySecurityDepositUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertySecurityDepositCreateManyPropertyInputEnvelope
    set?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    disconnect?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    delete?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    connect?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    update?: PropertySecurityDepositUpdateWithWhereUniqueWithoutPropertyInput | PropertySecurityDepositUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertySecurityDepositUpdateManyWithWhereWithoutPropertyInput | PropertySecurityDepositUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertySecurityDepositScalarWhereInput | PropertySecurityDepositScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type PropertyStandingChargeUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyStandingChargeCreateWithoutPropertyInput, PropertyStandingChargeUncheckedCreateWithoutPropertyInput> | PropertyStandingChargeCreateWithoutPropertyInput[] | PropertyStandingChargeUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStandingChargeCreateOrConnectWithoutPropertyInput | PropertyStandingChargeCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyStandingChargeUpsertWithWhereUniqueWithoutPropertyInput | PropertyStandingChargeUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyStandingChargeCreateManyPropertyInputEnvelope
    set?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    disconnect?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    delete?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    connect?: PropertyStandingChargeWhereUniqueInput | PropertyStandingChargeWhereUniqueInput[]
    update?: PropertyStandingChargeUpdateWithWhereUniqueWithoutPropertyInput | PropertyStandingChargeUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyStandingChargeUpdateManyWithWhereWithoutPropertyInput | PropertyStandingChargeUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyStandingChargeScalarWhereInput | PropertyStandingChargeScalarWhereInput[]
  }

  export type PropertySecurityDepositUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertySecurityDepositCreateWithoutPropertyInput, PropertySecurityDepositUncheckedCreateWithoutPropertyInput> | PropertySecurityDepositCreateWithoutPropertyInput[] | PropertySecurityDepositUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertySecurityDepositCreateOrConnectWithoutPropertyInput | PropertySecurityDepositCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertySecurityDepositUpsertWithWhereUniqueWithoutPropertyInput | PropertySecurityDepositUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertySecurityDepositCreateManyPropertyInputEnvelope
    set?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    disconnect?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    delete?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    connect?: PropertySecurityDepositWhereUniqueInput | PropertySecurityDepositWhereUniqueInput[]
    update?: PropertySecurityDepositUpdateWithWhereUniqueWithoutPropertyInput | PropertySecurityDepositUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertySecurityDepositUpdateManyWithWhereWithoutPropertyInput | PropertySecurityDepositUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertySecurityDepositScalarWhereInput | PropertySecurityDepositScalarWhereInput[]
  }

  export type PropertyCreateNestedManyWithoutLandlordInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutLandlordInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutLandlordInput | PropertyUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutLandlordInput | PropertyUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutLandlordInput | PropertyUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutLandlordInput | PropertyUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutLandlordInput | PropertyUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutLandlordInput | PropertyUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCategoryInput | PropertyUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCategoryInput | PropertyUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCategoryInput | PropertyUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput> | PropertyCreateWithoutCategoryInput[] | PropertyUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCategoryInput | PropertyCreateOrConnectWithoutCategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCategoryInput | PropertyUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PropertyCreateManyCategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCategoryInput | PropertyUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCategoryInput | PropertyUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyTypeInput | PropertyUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyTypeInput | PropertyUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutUnitsInput = {
    create?: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitsInput
    connect?: PropertyWhereUniqueInput
  }

  export type UnitTypeCreateNestedOneWithoutUnitsInput = {
    create?: XOR<UnitTypeCreateWithoutUnitsInput, UnitTypeUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: UnitTypeCreateOrConnectWithoutUnitsInput
    connect?: UnitTypeWhereUniqueInput
  }

  export type LeaseCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type UnitServiceChargeCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitServiceChargeCreateWithoutUnitInput, UnitServiceChargeUncheckedCreateWithoutUnitInput> | UnitServiceChargeCreateWithoutUnitInput[] | UnitServiceChargeUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceChargeCreateOrConnectWithoutUnitInput | UnitServiceChargeCreateOrConnectWithoutUnitInput[]
    createMany?: UnitServiceChargeCreateManyUnitInputEnvelope
    connect?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
  }

  export type UnitMeterNumberCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitMeterNumberCreateWithoutUnitInput, UnitMeterNumberUncheckedCreateWithoutUnitInput> | UnitMeterNumberCreateWithoutUnitInput[] | UnitMeterNumberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMeterNumberCreateOrConnectWithoutUnitInput | UnitMeterNumberCreateOrConnectWithoutUnitInput[]
    createMany?: UnitMeterNumberCreateManyUnitInputEnvelope
    connect?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
  }

  export type UnitFeatureCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitFeatureCreateWithoutUnitInput, UnitFeatureUncheckedCreateWithoutUnitInput> | UnitFeatureCreateWithoutUnitInput[] | UnitFeatureUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitFeatureCreateOrConnectWithoutUnitInput | UnitFeatureCreateOrConnectWithoutUnitInput[]
    createMany?: UnitFeatureCreateManyUnitInputEnvelope
    connect?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
  }

  export type LeaseUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type UnitServiceChargeUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitServiceChargeCreateWithoutUnitInput, UnitServiceChargeUncheckedCreateWithoutUnitInput> | UnitServiceChargeCreateWithoutUnitInput[] | UnitServiceChargeUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceChargeCreateOrConnectWithoutUnitInput | UnitServiceChargeCreateOrConnectWithoutUnitInput[]
    createMany?: UnitServiceChargeCreateManyUnitInputEnvelope
    connect?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
  }

  export type UnitMeterNumberUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitMeterNumberCreateWithoutUnitInput, UnitMeterNumberUncheckedCreateWithoutUnitInput> | UnitMeterNumberCreateWithoutUnitInput[] | UnitMeterNumberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMeterNumberCreateOrConnectWithoutUnitInput | UnitMeterNumberCreateOrConnectWithoutUnitInput[]
    createMany?: UnitMeterNumberCreateManyUnitInputEnvelope
    connect?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
  }

  export type UnitFeatureUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitFeatureCreateWithoutUnitInput, UnitFeatureUncheckedCreateWithoutUnitInput> | UnitFeatureCreateWithoutUnitInput[] | UnitFeatureUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitFeatureCreateOrConnectWithoutUnitInput | UnitFeatureCreateOrConnectWithoutUnitInput[]
    createMany?: UnitFeatureCreateManyUnitInputEnvelope
    connect?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
  }

  export type EnumUnitStatusFieldUpdateOperationsInput = {
    set?: $Enums.UnitStatus
  }

  export type PropertyUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitsInput
    upsert?: PropertyUpsertWithoutUnitsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutUnitsInput, PropertyUpdateWithoutUnitsInput>, PropertyUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitTypeUpdateOneWithoutUnitsNestedInput = {
    create?: XOR<UnitTypeCreateWithoutUnitsInput, UnitTypeUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: UnitTypeCreateOrConnectWithoutUnitsInput
    upsert?: UnitTypeUpsertWithoutUnitsInput
    disconnect?: UnitTypeWhereInput | boolean
    delete?: UnitTypeWhereInput | boolean
    connect?: UnitTypeWhereUniqueInput
    update?: XOR<XOR<UnitTypeUpdateToOneWithWhereWithoutUnitsInput, UnitTypeUpdateWithoutUnitsInput>, UnitTypeUncheckedUpdateWithoutUnitsInput>
  }

  export type LeaseUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type UnitServiceChargeUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitServiceChargeCreateWithoutUnitInput, UnitServiceChargeUncheckedCreateWithoutUnitInput> | UnitServiceChargeCreateWithoutUnitInput[] | UnitServiceChargeUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceChargeCreateOrConnectWithoutUnitInput | UnitServiceChargeCreateOrConnectWithoutUnitInput[]
    upsert?: UnitServiceChargeUpsertWithWhereUniqueWithoutUnitInput | UnitServiceChargeUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitServiceChargeCreateManyUnitInputEnvelope
    set?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    disconnect?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    delete?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    connect?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    update?: UnitServiceChargeUpdateWithWhereUniqueWithoutUnitInput | UnitServiceChargeUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitServiceChargeUpdateManyWithWhereWithoutUnitInput | UnitServiceChargeUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitServiceChargeScalarWhereInput | UnitServiceChargeScalarWhereInput[]
  }

  export type UnitMeterNumberUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitMeterNumberCreateWithoutUnitInput, UnitMeterNumberUncheckedCreateWithoutUnitInput> | UnitMeterNumberCreateWithoutUnitInput[] | UnitMeterNumberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMeterNumberCreateOrConnectWithoutUnitInput | UnitMeterNumberCreateOrConnectWithoutUnitInput[]
    upsert?: UnitMeterNumberUpsertWithWhereUniqueWithoutUnitInput | UnitMeterNumberUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitMeterNumberCreateManyUnitInputEnvelope
    set?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    disconnect?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    delete?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    connect?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    update?: UnitMeterNumberUpdateWithWhereUniqueWithoutUnitInput | UnitMeterNumberUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitMeterNumberUpdateManyWithWhereWithoutUnitInput | UnitMeterNumberUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitMeterNumberScalarWhereInput | UnitMeterNumberScalarWhereInput[]
  }

  export type UnitFeatureUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitFeatureCreateWithoutUnitInput, UnitFeatureUncheckedCreateWithoutUnitInput> | UnitFeatureCreateWithoutUnitInput[] | UnitFeatureUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitFeatureCreateOrConnectWithoutUnitInput | UnitFeatureCreateOrConnectWithoutUnitInput[]
    upsert?: UnitFeatureUpsertWithWhereUniqueWithoutUnitInput | UnitFeatureUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitFeatureCreateManyUnitInputEnvelope
    set?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    disconnect?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    delete?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    connect?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    update?: UnitFeatureUpdateWithWhereUniqueWithoutUnitInput | UnitFeatureUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitFeatureUpdateManyWithWhereWithoutUnitInput | UnitFeatureUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitFeatureScalarWhereInput | UnitFeatureScalarWhereInput[]
  }

  export type LeaseUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type UnitServiceChargeUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitServiceChargeCreateWithoutUnitInput, UnitServiceChargeUncheckedCreateWithoutUnitInput> | UnitServiceChargeCreateWithoutUnitInput[] | UnitServiceChargeUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceChargeCreateOrConnectWithoutUnitInput | UnitServiceChargeCreateOrConnectWithoutUnitInput[]
    upsert?: UnitServiceChargeUpsertWithWhereUniqueWithoutUnitInput | UnitServiceChargeUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitServiceChargeCreateManyUnitInputEnvelope
    set?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    disconnect?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    delete?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    connect?: UnitServiceChargeWhereUniqueInput | UnitServiceChargeWhereUniqueInput[]
    update?: UnitServiceChargeUpdateWithWhereUniqueWithoutUnitInput | UnitServiceChargeUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitServiceChargeUpdateManyWithWhereWithoutUnitInput | UnitServiceChargeUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitServiceChargeScalarWhereInput | UnitServiceChargeScalarWhereInput[]
  }

  export type UnitMeterNumberUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitMeterNumberCreateWithoutUnitInput, UnitMeterNumberUncheckedCreateWithoutUnitInput> | UnitMeterNumberCreateWithoutUnitInput[] | UnitMeterNumberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMeterNumberCreateOrConnectWithoutUnitInput | UnitMeterNumberCreateOrConnectWithoutUnitInput[]
    upsert?: UnitMeterNumberUpsertWithWhereUniqueWithoutUnitInput | UnitMeterNumberUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitMeterNumberCreateManyUnitInputEnvelope
    set?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    disconnect?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    delete?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    connect?: UnitMeterNumberWhereUniqueInput | UnitMeterNumberWhereUniqueInput[]
    update?: UnitMeterNumberUpdateWithWhereUniqueWithoutUnitInput | UnitMeterNumberUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitMeterNumberUpdateManyWithWhereWithoutUnitInput | UnitMeterNumberUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitMeterNumberScalarWhereInput | UnitMeterNumberScalarWhereInput[]
  }

  export type UnitFeatureUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitFeatureCreateWithoutUnitInput, UnitFeatureUncheckedCreateWithoutUnitInput> | UnitFeatureCreateWithoutUnitInput[] | UnitFeatureUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitFeatureCreateOrConnectWithoutUnitInput | UnitFeatureCreateOrConnectWithoutUnitInput[]
    upsert?: UnitFeatureUpsertWithWhereUniqueWithoutUnitInput | UnitFeatureUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitFeatureCreateManyUnitInputEnvelope
    set?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    disconnect?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    delete?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    connect?: UnitFeatureWhereUniqueInput | UnitFeatureWhereUniqueInput[]
    update?: UnitFeatureUpdateWithWhereUniqueWithoutUnitInput | UnitFeatureUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitFeatureUpdateManyWithWhereWithoutUnitInput | UnitFeatureUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitFeatureScalarWhereInput | UnitFeatureScalarWhereInput[]
  }

  export type UnitCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutUnitTypeInput | UnitUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutUnitTypeInput | UnitUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutUnitTypeInput | UnitUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutUnitTypeInput | UnitUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutUnitTypeInput | UnitUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutUnitTypeInput | UnitUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutServiceChargesInput = {
    create?: XOR<UnitCreateWithoutServiceChargesInput, UnitUncheckedCreateWithoutServiceChargesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutServiceChargesInput
    connect?: UnitWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UnitUpdateOneRequiredWithoutServiceChargesNestedInput = {
    create?: XOR<UnitCreateWithoutServiceChargesInput, UnitUncheckedCreateWithoutServiceChargesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutServiceChargesInput
    upsert?: UnitUpsertWithoutServiceChargesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutServiceChargesInput, UnitUpdateWithoutServiceChargesInput>, UnitUncheckedUpdateWithoutServiceChargesInput>
  }

  export type UnitCreateNestedOneWithoutMeterNumbersInput = {
    create?: XOR<UnitCreateWithoutMeterNumbersInput, UnitUncheckedCreateWithoutMeterNumbersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMeterNumbersInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutMeterNumbersNestedInput = {
    create?: XOR<UnitCreateWithoutMeterNumbersInput, UnitUncheckedCreateWithoutMeterNumbersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMeterNumbersInput
    upsert?: UnitUpsertWithoutMeterNumbersInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutMeterNumbersInput, UnitUpdateWithoutMeterNumbersInput>, UnitUncheckedUpdateWithoutMeterNumbersInput>
  }

  export type UnitCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<UnitCreateWithoutFeaturesInput, UnitUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutFeaturesInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<UnitCreateWithoutFeaturesInput, UnitUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutFeaturesInput
    upsert?: UnitUpsertWithoutFeaturesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutFeaturesInput, UnitUpdateWithoutFeaturesInput>, UnitUncheckedUpdateWithoutFeaturesInput>
  }

  export type PropertyCreateNestedOneWithoutStandingChargesInput = {
    create?: XOR<PropertyCreateWithoutStandingChargesInput, PropertyUncheckedCreateWithoutStandingChargesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutStandingChargesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutStandingChargesNestedInput = {
    create?: XOR<PropertyCreateWithoutStandingChargesInput, PropertyUncheckedCreateWithoutStandingChargesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutStandingChargesInput
    upsert?: PropertyUpsertWithoutStandingChargesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutStandingChargesInput, PropertyUpdateWithoutStandingChargesInput>, PropertyUncheckedUpdateWithoutStandingChargesInput>
  }

  export type PropertyCreateNestedOneWithoutSecurityDepositsInput = {
    create?: XOR<PropertyCreateWithoutSecurityDepositsInput, PropertyUncheckedCreateWithoutSecurityDepositsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSecurityDepositsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutSecurityDepositsNestedInput = {
    create?: XOR<PropertyCreateWithoutSecurityDepositsInput, PropertyUncheckedCreateWithoutSecurityDepositsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSecurityDepositsInput
    upsert?: PropertyUpsertWithoutSecurityDepositsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutSecurityDepositsInput, PropertyUpdateWithoutSecurityDepositsInput>, PropertyUncheckedUpdateWithoutSecurityDepositsInput>
  }

  export type LeaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type TenantEmergencyContactCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
  }

  export type LeaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
  }

  export type LeaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutTenantInput | LeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutTenantInput | LeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutTenantInput | LeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type TenantEmergencyContactUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    upsert?: TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    set?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    disconnect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    delete?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    update?: TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput | TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
  }

  export type LeaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutTenantInput | LeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutTenantInput | LeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutTenantInput | LeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    upsert?: TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    set?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    disconnect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    delete?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    update?: TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput | TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutEmergencyContactsInput = {
    create?: XOR<TenantCreateWithoutEmergencyContactsInput, TenantUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmergencyContactsInput
    connect?: TenantWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutEmergencyContactsNestedInput = {
    create?: XOR<TenantCreateWithoutEmergencyContactsInput, TenantUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmergencyContactsInput
    upsert?: TenantUpsertWithoutEmergencyContactsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmergencyContactsInput, TenantUpdateWithoutEmergencyContactsInput>, TenantUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type UnitCreateNestedOneWithoutLeasesInput = {
    create?: XOR<UnitCreateWithoutLeasesInput, UnitUncheckedCreateWithoutLeasesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeasesInput
    connect?: UnitWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutLeasesInput = {
    create?: XOR<TenantCreateWithoutLeasesInput, TenantUncheckedCreateWithoutLeasesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeasesInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutLeaseInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutLeaseInput = {
    create?: XOR<PaymentCreateWithoutLeaseInput, PaymentUncheckedCreateWithoutLeaseInput> | PaymentCreateWithoutLeaseInput[] | PaymentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLeaseInput | PaymentCreateOrConnectWithoutLeaseInput[]
    createMany?: PaymentCreateManyLeaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<PaymentCreateWithoutLeaseInput, PaymentUncheckedCreateWithoutLeaseInput> | PaymentCreateWithoutLeaseInput[] | PaymentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLeaseInput | PaymentCreateOrConnectWithoutLeaseInput[]
    createMany?: PaymentCreateManyLeaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumLeaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaseStatus
  }

  export type UnitUpdateOneRequiredWithoutLeasesNestedInput = {
    create?: XOR<UnitCreateWithoutLeasesInput, UnitUncheckedCreateWithoutLeasesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeasesInput
    upsert?: UnitUpsertWithoutLeasesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutLeasesInput, UnitUpdateWithoutLeasesInput>, UnitUncheckedUpdateWithoutLeasesInput>
  }

  export type TenantUpdateOneRequiredWithoutLeasesNestedInput = {
    create?: XOR<TenantCreateWithoutLeasesInput, TenantUncheckedCreateWithoutLeasesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeasesInput
    upsert?: TenantUpsertWithoutLeasesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeasesInput, TenantUpdateWithoutLeasesInput>, TenantUncheckedUpdateWithoutLeasesInput>
  }

  export type InvoiceUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLeaseInput | InvoiceUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLeaseInput | InvoiceUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLeaseInput | InvoiceUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<PaymentCreateWithoutLeaseInput, PaymentUncheckedCreateWithoutLeaseInput> | PaymentCreateWithoutLeaseInput[] | PaymentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLeaseInput | PaymentCreateOrConnectWithoutLeaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLeaseInput | PaymentUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: PaymentCreateManyLeaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLeaseInput | PaymentUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLeaseInput | PaymentUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLeaseInput | InvoiceUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLeaseInput | InvoiceUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLeaseInput | InvoiceUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<PaymentCreateWithoutLeaseInput, PaymentUncheckedCreateWithoutLeaseInput> | PaymentCreateWithoutLeaseInput[] | PaymentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLeaseInput | PaymentCreateOrConnectWithoutLeaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLeaseInput | PaymentUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: PaymentCreateManyLeaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLeaseInput | PaymentUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLeaseInput | PaymentUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LeaseCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<LeaseCreateWithoutInvoicesInput, LeaseUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutInvoicesInput
    connect?: LeaseWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type LeaseUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<LeaseCreateWithoutInvoicesInput, LeaseUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutInvoicesInput
    upsert?: LeaseUpsertWithoutInvoicesInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutInvoicesInput, LeaseUpdateWithoutInvoicesInput>, LeaseUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: InvoiceUpsertWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutInvoiceItemsInput, InvoiceUpdateWithoutInvoiceItemsInput>, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type LeaseCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<LeaseCreateWithoutPaymentsInput, LeaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutPaymentsInput
    connect?: LeaseWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type LeaseUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<LeaseCreateWithoutPaymentsInput, LeaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutPaymentsInput
    upsert?: LeaseUpsertWithoutPaymentsInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutPaymentsInput, LeaseUpdateWithoutPaymentsInput>, LeaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type LandlordCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    email?: string | null
    phone?: string | null
    alternativePhone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    bankName?: string | null
    bankBranch?: string | null
    accountName?: string | null
    accountNumber?: string | null
    taxPin?: string | null
    vatRegistered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LandlordUncheckedCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    email?: string | null
    phone?: string | null
    alternativePhone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    bankName?: string | null
    bankBranch?: string | null
    accountName?: string | null
    accountNumber?: string | null
    taxPin?: string | null
    vatRegistered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LandlordCreateOrConnectWithoutPropertiesInput = {
    where: LandlordWhereUniqueInput
    create: XOR<LandlordCreateWithoutPropertiesInput, LandlordUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyCategoryCreateWithoutPropertiesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCategoryUncheckedCreateWithoutPropertiesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCategoryCreateOrConnectWithoutPropertiesInput = {
    where: PropertyCategoryWhereUniqueInput
    create: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyTypeCreateWithoutPropertiesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyTypeUncheckedCreateWithoutPropertiesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyTypeCreateOrConnectWithoutPropertiesInput = {
    where: PropertyTypeWhereUniqueInput
    create: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
  }

  export type UnitCreateWithoutPropertyInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unitType?: UnitTypeCreateNestedOneWithoutUnitsInput
    leases?: LeaseCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberCreateNestedManyWithoutUnitInput
    features?: UnitFeatureCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPropertyInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeUncheckedCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberUncheckedCreateNestedManyWithoutUnitInput
    features?: UnitFeatureUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitCreateManyPropertyInputEnvelope = {
    data: UnitCreateManyPropertyInput | UnitCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyStandingChargeCreateWithoutPropertyInput = {
    id?: string
    chargeUtility: string
    chargeMode: string
    billingCurrency?: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    chargeValue: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyStandingChargeUncheckedCreateWithoutPropertyInput = {
    id?: string
    chargeUtility: string
    chargeMode: string
    billingCurrency?: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    chargeValue: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyStandingChargeCreateOrConnectWithoutPropertyInput = {
    where: PropertyStandingChargeWhereUniqueInput
    create: XOR<PropertyStandingChargeCreateWithoutPropertyInput, PropertyStandingChargeUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyStandingChargeCreateManyPropertyInputEnvelope = {
    data: PropertyStandingChargeCreateManyPropertyInput | PropertyStandingChargeCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertySecurityDepositCreateWithoutPropertyInput = {
    id?: string
    month: string
    value: Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySecurityDepositUncheckedCreateWithoutPropertyInput = {
    id?: string
    month: string
    value: Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySecurityDepositCreateOrConnectWithoutPropertyInput = {
    where: PropertySecurityDepositWhereUniqueInput
    create: XOR<PropertySecurityDepositCreateWithoutPropertyInput, PropertySecurityDepositUncheckedCreateWithoutPropertyInput>
  }

  export type PropertySecurityDepositCreateManyPropertyInputEnvelope = {
    data: PropertySecurityDepositCreateManyPropertyInput | PropertySecurityDepositCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type LandlordUpsertWithoutPropertiesInput = {
    update: XOR<LandlordUpdateWithoutPropertiesInput, LandlordUncheckedUpdateWithoutPropertiesInput>
    create: XOR<LandlordCreateWithoutPropertiesInput, LandlordUncheckedCreateWithoutPropertiesInput>
    where?: LandlordWhereInput
  }

  export type LandlordUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: LandlordWhereInput
    data: XOR<LandlordUpdateWithoutPropertiesInput, LandlordUncheckedUpdateWithoutPropertiesInput>
  }

  export type LandlordUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LandlordUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCategoryUpsertWithoutPropertiesInput = {
    update: XOR<PropertyCategoryUpdateWithoutPropertiesInput, PropertyCategoryUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyCategoryCreateWithoutPropertiesInput, PropertyCategoryUncheckedCreateWithoutPropertiesInput>
    where?: PropertyCategoryWhereInput
  }

  export type PropertyCategoryUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyCategoryWhereInput
    data: XOR<PropertyCategoryUpdateWithoutPropertiesInput, PropertyCategoryUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCategoryUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCategoryUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTypeUpsertWithoutPropertiesInput = {
    update: XOR<PropertyTypeUpdateWithoutPropertiesInput, PropertyTypeUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
    where?: PropertyTypeWhereInput
  }

  export type PropertyTypeUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyTypeWhereInput
    data: XOR<PropertyTypeUpdateWithoutPropertiesInput, PropertyTypeUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyTypeUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTypeUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
  }

  export type UnitUpdateManyWithWhereWithoutPropertyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutPropertyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    code?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    sequence?: IntNullableFilter<"Unit"> | number | null
    propertyId?: StringFilter<"Unit"> | string
    quotedPrice?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    baseRent?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Unit"> | string
    areaSqFt?: DecimalNullableFilter<"Unit"> | Decimal | DecimalJsLike | number | string | null
    chargePlan?: StringNullableFilter<"Unit"> | string | null
    floor?: IntNullableFilter<"Unit"> | number | null
    bedrooms?: IntNullableFilter<"Unit"> | number | null
    bathrooms?: IntNullableFilter<"Unit"> | number | null
    furnished?: BoolFilter<"Unit"> | boolean
    outSourceParking?: StringNullableFilter<"Unit"> | string | null
    unitTypeId?: StringNullableFilter<"Unit"> | string | null
    ownerOccupied?: BoolFilter<"Unit"> | boolean
    electricityAcno?: StringNullableFilter<"Unit"> | string | null
    waterAcno?: StringNullableFilter<"Unit"> | string | null
    electricityMeethno?: StringNullableFilter<"Unit"> | string | null
    waterMeethno?: StringNullableFilter<"Unit"> | string | null
    takeOnLettingDate?: DateTimeNullableFilter<"Unit"> | Date | string | null
    tenantResidentCodeCounter?: IntNullableFilter<"Unit"> | number | null
    apartmentNotes?: StringNullableFilter<"Unit"> | string | null
    status?: EnumUnitStatusFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
  }

  export type PropertyStandingChargeUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyStandingChargeWhereUniqueInput
    update: XOR<PropertyStandingChargeUpdateWithoutPropertyInput, PropertyStandingChargeUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyStandingChargeCreateWithoutPropertyInput, PropertyStandingChargeUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyStandingChargeUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyStandingChargeWhereUniqueInput
    data: XOR<PropertyStandingChargeUpdateWithoutPropertyInput, PropertyStandingChargeUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyStandingChargeUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyStandingChargeScalarWhereInput
    data: XOR<PropertyStandingChargeUpdateManyMutationInput, PropertyStandingChargeUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyStandingChargeScalarWhereInput = {
    AND?: PropertyStandingChargeScalarWhereInput | PropertyStandingChargeScalarWhereInput[]
    OR?: PropertyStandingChargeScalarWhereInput[]
    NOT?: PropertyStandingChargeScalarWhereInput | PropertyStandingChargeScalarWhereInput[]
    id?: StringFilter<"PropertyStandingCharge"> | string
    propertyId?: StringFilter<"PropertyStandingCharge"> | string
    chargeUtility?: StringFilter<"PropertyStandingCharge"> | string
    chargeMode?: StringFilter<"PropertyStandingCharge"> | string
    billingCurrency?: StringFilter<"PropertyStandingCharge"> | string
    costPerArea?: DecimalNullableFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableFilter<"PropertyStandingCharge"> | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFilter<"PropertyStandingCharge"> | boolean
    createdAt?: DateTimeFilter<"PropertyStandingCharge"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyStandingCharge"> | Date | string
  }

  export type PropertySecurityDepositUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertySecurityDepositWhereUniqueInput
    update: XOR<PropertySecurityDepositUpdateWithoutPropertyInput, PropertySecurityDepositUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertySecurityDepositCreateWithoutPropertyInput, PropertySecurityDepositUncheckedCreateWithoutPropertyInput>
  }

  export type PropertySecurityDepositUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertySecurityDepositWhereUniqueInput
    data: XOR<PropertySecurityDepositUpdateWithoutPropertyInput, PropertySecurityDepositUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertySecurityDepositUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertySecurityDepositScalarWhereInput
    data: XOR<PropertySecurityDepositUpdateManyMutationInput, PropertySecurityDepositUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertySecurityDepositScalarWhereInput = {
    AND?: PropertySecurityDepositScalarWhereInput | PropertySecurityDepositScalarWhereInput[]
    OR?: PropertySecurityDepositScalarWhereInput[]
    NOT?: PropertySecurityDepositScalarWhereInput | PropertySecurityDepositScalarWhereInput[]
    id?: StringFilter<"PropertySecurityDeposit"> | string
    propertyId?: StringFilter<"PropertySecurityDeposit"> | string
    month?: StringFilter<"PropertySecurityDeposit"> | string
    value?: DecimalFilter<"PropertySecurityDeposit"> | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFilter<"PropertySecurityDeposit"> | boolean
    ofInitialRent?: BoolFilter<"PropertySecurityDeposit"> | boolean
    ofLastEscalation?: BoolFilter<"PropertySecurityDeposit"> | boolean
    excludesWithRent?: BoolFilter<"PropertySecurityDeposit"> | boolean
    createdAt?: DateTimeFilter<"PropertySecurityDeposit"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySecurityDeposit"> | Date | string
  }

  export type PropertyCreateWithoutLandlordInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
    units?: UnitCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutLandlordInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    categoryId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeUncheckedCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutLandlordInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput>
  }

  export type PropertyCreateManyLandlordInputEnvelope = {
    data: PropertyCreateManyLandlordInput | PropertyCreateManyLandlordInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutLandlordInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutLandlordInput, PropertyUncheckedUpdateWithoutLandlordInput>
    create: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutLandlordInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutLandlordInput, PropertyUncheckedUpdateWithoutLandlordInput>
  }

  export type PropertyUpdateManyWithWhereWithoutLandlordInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutLandlordInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    code?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    dateAcquired?: DateTimeNullableFilter<"Property"> | Date | string | null
    lrNumber?: StringNullableFilter<"Property"> | string | null
    country?: StringNullableFilter<"Property"> | string | null
    estateArea?: StringNullableFilter<"Property"> | string | null
    areaRegion?: StringNullableFilter<"Property"> | string | null
    roadStreet?: StringNullableFilter<"Property"> | string | null
    specification?: StringNullableFilter<"Property"> | string | null
    multiStoryType?: StringNullableFilter<"Property"> | string | null
    numberOfFloors?: IntNullableFilter<"Property"> | number | null
    latitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Property"> | string | null
    specificContactInfo?: StringNullableFilter<"Property"> | string | null
    landlordId?: StringNullableFilter<"Property"> | string | null
    categoryId?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: StringNullableFilter<"Property"> | string | null
    accountLedgerType?: StringNullableFilter<"Property"> | string | null
    primaryBankAccount?: StringNullableFilter<"Property"> | string | null
    alternativeTaxPin?: StringNullableFilter<"Property"> | string | null
    propertyWorkingTaxPin?: StringNullableFilter<"Property"> | string | null
    invoicePaymentInfo?: StringNullableFilter<"Property"> | string | null
    holderPaymentTerms?: StringNullableFilter<"Property"> | string | null
    mpesaPropertyPayNumber?: StringNullableFilter<"Property"> | string | null
    disableMpesaStkPush?: BoolFilter<"Property"> | boolean
    disableMpesaStkNarration?: BoolFilter<"Property"> | boolean
    tenantReceiptAccountCodeCounter?: IntNullableFilter<"Property"> | number | null
    lpgExempted?: BoolFilter<"Property"> | boolean
    penaltyChargeMode?: StringNullableFilter<"Property"> | string | null
    penaltyDay?: IntNullableFilter<"Property"> | number | null
    landlordDrawerBank?: StringNullableFilter<"Property"> | string | null
    landlordBankBranch?: StringNullableFilter<"Property"> | string | null
    landlordAccountName?: StringNullableFilter<"Property"> | string | null
    landlordAccountNumber?: StringNullableFilter<"Property"> | string | null
    exemptAllSms?: BoolFilter<"Property"> | boolean
    exemptInvoiceSms?: BoolFilter<"Property"> | boolean
    exemptGeneralSms?: BoolFilter<"Property"> | boolean
    exemptHagueSms?: BoolFilter<"Property"> | boolean
    exemptBalanceSms?: BoolFilter<"Property"> | boolean
    exemptAllEmail?: BoolFilter<"Property"> | boolean
    exemptInvoiceEmail?: BoolFilter<"Property"> | boolean
    exemptGeneralEmail?: BoolFilter<"Property"> | boolean
    exemptReceiptEmail?: BoolFilter<"Property"> | boolean
    exemptBalanceEmail?: BoolFilter<"Property"> | boolean
    excludeInTwoSummaryReport?: BoolFilter<"Property"> | boolean
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
  }

  export type PropertyCreateWithoutCategoryInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    landlord?: LandlordCreateNestedOneWithoutPropertiesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
    units?: UnitCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutCategoryInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeUncheckedCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyCreateManyCategoryInputEnvelope = {
    data: PropertyCreateManyCategoryInput | PropertyCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutCategoryInput, PropertyUncheckedUpdateWithoutCategoryInput>
    create: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutCategoryInput, PropertyUncheckedUpdateWithoutCategoryInput>
  }

  export type PropertyUpdateManyWithWhereWithoutCategoryInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PropertyCreateWithoutPropertyTypeInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    landlord?: LandlordCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    units?: UnitCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyTypeInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    categoryId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeUncheckedCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyCreateManyPropertyTypeInputEnvelope = {
    data: PropertyCreateManyPropertyTypeInput | PropertyCreateManyPropertyTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPropertyTypeInput, PropertyUncheckedUpdateWithoutPropertyTypeInput>
    create: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPropertyTypeInput, PropertyUncheckedUpdateWithoutPropertyTypeInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPropertyTypeInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyTypeInput>
  }

  export type PropertyCreateWithoutUnitsInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    landlord?: LandlordCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
    standingCharges?: PropertyStandingChargeCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUnitsInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    categoryId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    standingCharges?: PropertyStandingChargeUncheckedCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUnitsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
  }

  export type UnitTypeCreateWithoutUnitsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitTypeUncheckedCreateWithoutUnitsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitTypeCreateOrConnectWithoutUnitsInput = {
    where: UnitTypeWhereUniqueInput
    create: XOR<UnitTypeCreateWithoutUnitsInput, UnitTypeUncheckedCreateWithoutUnitsInput>
  }

  export type LeaseCreateWithoutUnitInput = {
    id?: string
    code: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutLeasesInput
    invoices?: InvoiceCreateNestedManyWithoutLeaseInput
    payments?: PaymentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutUnitInput = {
    id?: string
    code: string
    tenantId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseCreateManyUnitInputEnvelope = {
    data: LeaseCreateManyUnitInput | LeaseCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitServiceChargeCreateWithoutUnitInput = {
    id?: string
    serviceUtilityAmenity: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    totalCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitServiceChargeUncheckedCreateWithoutUnitInput = {
    id?: string
    serviceUtilityAmenity: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    totalCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitServiceChargeCreateOrConnectWithoutUnitInput = {
    where: UnitServiceChargeWhereUniqueInput
    create: XOR<UnitServiceChargeCreateWithoutUnitInput, UnitServiceChargeUncheckedCreateWithoutUnitInput>
  }

  export type UnitServiceChargeCreateManyUnitInputEnvelope = {
    data: UnitServiceChargeCreateManyUnitInput | UnitServiceChargeCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitMeterNumberCreateWithoutUnitInput = {
    id?: string
    meterNo: string
    readingSetup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitMeterNumberUncheckedCreateWithoutUnitInput = {
    id?: string
    meterNo: string
    readingSetup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitMeterNumberCreateOrConnectWithoutUnitInput = {
    where: UnitMeterNumberWhereUniqueInput
    create: XOR<UnitMeterNumberCreateWithoutUnitInput, UnitMeterNumberUncheckedCreateWithoutUnitInput>
  }

  export type UnitMeterNumberCreateManyUnitInputEnvelope = {
    data: UnitMeterNumberCreateManyUnitInput | UnitMeterNumberCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitFeatureCreateWithoutUnitInput = {
    id?: string
    name: string
    featureType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitFeatureUncheckedCreateWithoutUnitInput = {
    id?: string
    name: string
    featureType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitFeatureCreateOrConnectWithoutUnitInput = {
    where: UnitFeatureWhereUniqueInput
    create: XOR<UnitFeatureCreateWithoutUnitInput, UnitFeatureUncheckedCreateWithoutUnitInput>
  }

  export type UnitFeatureCreateManyUnitInputEnvelope = {
    data: UnitFeatureCreateManyUnitInput | UnitFeatureCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutUnitsInput = {
    update: XOR<PropertyUpdateWithoutUnitsInput, PropertyUncheckedUpdateWithoutUnitsInput>
    create: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutUnitsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutUnitsInput, PropertyUncheckedUpdateWithoutUnitsInput>
  }

  export type PropertyUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landlord?: LandlordUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
    standingCharges?: PropertyStandingChargeUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    standingCharges?: PropertyStandingChargeUncheckedUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UnitTypeUpsertWithoutUnitsInput = {
    update: XOR<UnitTypeUpdateWithoutUnitsInput, UnitTypeUncheckedUpdateWithoutUnitsInput>
    create: XOR<UnitTypeCreateWithoutUnitsInput, UnitTypeUncheckedCreateWithoutUnitsInput>
    where?: UnitTypeWhereInput
  }

  export type UnitTypeUpdateToOneWithWhereWithoutUnitsInput = {
    where?: UnitTypeWhereInput
    data: XOR<UnitTypeUpdateWithoutUnitsInput, UnitTypeUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitTypeUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitTypeUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseUpsertWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
  }

  export type LeaseUpdateManyWithWhereWithoutUnitInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutUnitInput>
  }

  export type LeaseScalarWhereInput = {
    AND?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    OR?: LeaseScalarWhereInput[]
    NOT?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    id?: StringFilter<"Lease"> | string
    code?: StringFilter<"Lease"> | string
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableFilter<"Lease"> | Date | string | null
    rentAmount?: DecimalFilter<"Lease"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Lease"> | string
    paymentDay?: IntFilter<"Lease"> | number
    securityDeposit?: DecimalNullableFilter<"Lease"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Lease"> | Date | string | null
  }

  export type UnitServiceChargeUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitServiceChargeWhereUniqueInput
    update: XOR<UnitServiceChargeUpdateWithoutUnitInput, UnitServiceChargeUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitServiceChargeCreateWithoutUnitInput, UnitServiceChargeUncheckedCreateWithoutUnitInput>
  }

  export type UnitServiceChargeUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitServiceChargeWhereUniqueInput
    data: XOR<UnitServiceChargeUpdateWithoutUnitInput, UnitServiceChargeUncheckedUpdateWithoutUnitInput>
  }

  export type UnitServiceChargeUpdateManyWithWhereWithoutUnitInput = {
    where: UnitServiceChargeScalarWhereInput
    data: XOR<UnitServiceChargeUpdateManyMutationInput, UnitServiceChargeUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitServiceChargeScalarWhereInput = {
    AND?: UnitServiceChargeScalarWhereInput | UnitServiceChargeScalarWhereInput[]
    OR?: UnitServiceChargeScalarWhereInput[]
    NOT?: UnitServiceChargeScalarWhereInput | UnitServiceChargeScalarWhereInput[]
    id?: StringFilter<"UnitServiceCharge"> | string
    unitId?: StringFilter<"UnitServiceCharge"> | string
    serviceUtilityAmenity?: StringFilter<"UnitServiceCharge"> | string
    costPerArea?: DecimalNullableFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFilter<"UnitServiceCharge"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"UnitServiceCharge"> | Date | string
    updatedAt?: DateTimeFilter<"UnitServiceCharge"> | Date | string
  }

  export type UnitMeterNumberUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitMeterNumberWhereUniqueInput
    update: XOR<UnitMeterNumberUpdateWithoutUnitInput, UnitMeterNumberUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitMeterNumberCreateWithoutUnitInput, UnitMeterNumberUncheckedCreateWithoutUnitInput>
  }

  export type UnitMeterNumberUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitMeterNumberWhereUniqueInput
    data: XOR<UnitMeterNumberUpdateWithoutUnitInput, UnitMeterNumberUncheckedUpdateWithoutUnitInput>
  }

  export type UnitMeterNumberUpdateManyWithWhereWithoutUnitInput = {
    where: UnitMeterNumberScalarWhereInput
    data: XOR<UnitMeterNumberUpdateManyMutationInput, UnitMeterNumberUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitMeterNumberScalarWhereInput = {
    AND?: UnitMeterNumberScalarWhereInput | UnitMeterNumberScalarWhereInput[]
    OR?: UnitMeterNumberScalarWhereInput[]
    NOT?: UnitMeterNumberScalarWhereInput | UnitMeterNumberScalarWhereInput[]
    id?: StringFilter<"UnitMeterNumber"> | string
    unitId?: StringFilter<"UnitMeterNumber"> | string
    meterNo?: StringFilter<"UnitMeterNumber"> | string
    readingSetup?: StringNullableFilter<"UnitMeterNumber"> | string | null
    createdAt?: DateTimeFilter<"UnitMeterNumber"> | Date | string
    updatedAt?: DateTimeFilter<"UnitMeterNumber"> | Date | string
  }

  export type UnitFeatureUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitFeatureWhereUniqueInput
    update: XOR<UnitFeatureUpdateWithoutUnitInput, UnitFeatureUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitFeatureCreateWithoutUnitInput, UnitFeatureUncheckedCreateWithoutUnitInput>
  }

  export type UnitFeatureUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitFeatureWhereUniqueInput
    data: XOR<UnitFeatureUpdateWithoutUnitInput, UnitFeatureUncheckedUpdateWithoutUnitInput>
  }

  export type UnitFeatureUpdateManyWithWhereWithoutUnitInput = {
    where: UnitFeatureScalarWhereInput
    data: XOR<UnitFeatureUpdateManyMutationInput, UnitFeatureUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitFeatureScalarWhereInput = {
    AND?: UnitFeatureScalarWhereInput | UnitFeatureScalarWhereInput[]
    OR?: UnitFeatureScalarWhereInput[]
    NOT?: UnitFeatureScalarWhereInput | UnitFeatureScalarWhereInput[]
    id?: StringFilter<"UnitFeature"> | string
    unitId?: StringFilter<"UnitFeature"> | string
    name?: StringFilter<"UnitFeature"> | string
    featureType?: StringNullableFilter<"UnitFeature"> | string | null
    createdAt?: DateTimeFilter<"UnitFeature"> | Date | string
    updatedAt?: DateTimeFilter<"UnitFeature"> | Date | string
  }

  export type UnitCreateWithoutUnitTypeInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutUnitsInput
    leases?: LeaseCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberCreateNestedManyWithoutUnitInput
    features?: UnitFeatureCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnitTypeInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeUncheckedCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberUncheckedCreateNestedManyWithoutUnitInput
    features?: UnitFeatureUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnitTypeInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput>
  }

  export type UnitCreateManyUnitTypeInputEnvelope = {
    data: UnitCreateManyUnitTypeInput | UnitCreateManyUnitTypeInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithWhereUniqueWithoutUnitTypeInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutUnitTypeInput, UnitUncheckedUpdateWithoutUnitTypeInput>
    create: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutUnitTypeInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutUnitTypeInput, UnitUncheckedUpdateWithoutUnitTypeInput>
  }

  export type UnitUpdateManyWithWhereWithoutUnitTypeInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutUnitTypeInput>
  }

  export type UnitCreateWithoutServiceChargesInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutUnitsInput
    unitType?: UnitTypeCreateNestedOneWithoutUnitsInput
    leases?: LeaseCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberCreateNestedManyWithoutUnitInput
    features?: UnitFeatureCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutServiceChargesInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberUncheckedCreateNestedManyWithoutUnitInput
    features?: UnitFeatureUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutServiceChargesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutServiceChargesInput, UnitUncheckedCreateWithoutServiceChargesInput>
  }

  export type UnitUpsertWithoutServiceChargesInput = {
    update: XOR<UnitUpdateWithoutServiceChargesInput, UnitUncheckedUpdateWithoutServiceChargesInput>
    create: XOR<UnitCreateWithoutServiceChargesInput, UnitUncheckedCreateWithoutServiceChargesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutServiceChargesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutServiceChargesInput, UnitUncheckedUpdateWithoutServiceChargesInput>
  }

  export type UnitUpdateWithoutServiceChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeUpdateOneWithoutUnitsNestedInput
    leases?: LeaseUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutServiceChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUncheckedUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateWithoutMeterNumbersInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutUnitsInput
    unitType?: UnitTypeCreateNestedOneWithoutUnitsInput
    leases?: LeaseCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeCreateNestedManyWithoutUnitInput
    features?: UnitFeatureCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutMeterNumbersInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeUncheckedCreateNestedManyWithoutUnitInput
    features?: UnitFeatureUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutMeterNumbersInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutMeterNumbersInput, UnitUncheckedCreateWithoutMeterNumbersInput>
  }

  export type UnitUpsertWithoutMeterNumbersInput = {
    update: XOR<UnitUpdateWithoutMeterNumbersInput, UnitUncheckedUpdateWithoutMeterNumbersInput>
    create: XOR<UnitCreateWithoutMeterNumbersInput, UnitUncheckedCreateWithoutMeterNumbersInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutMeterNumbersInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutMeterNumbersInput, UnitUncheckedUpdateWithoutMeterNumbersInput>
  }

  export type UnitUpdateWithoutMeterNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeUpdateOneWithoutUnitsNestedInput
    leases?: LeaseUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutMeterNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUncheckedUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateWithoutFeaturesInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutUnitsInput
    unitType?: UnitTypeCreateNestedOneWithoutUnitsInput
    leases?: LeaseCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutFeaturesInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    serviceCharges?: UnitServiceChargeUncheckedCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutFeaturesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutFeaturesInput, UnitUncheckedCreateWithoutFeaturesInput>
  }

  export type UnitUpsertWithoutFeaturesInput = {
    update: XOR<UnitUpdateWithoutFeaturesInput, UnitUncheckedUpdateWithoutFeaturesInput>
    create: XOR<UnitCreateWithoutFeaturesInput, UnitUncheckedCreateWithoutFeaturesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutFeaturesInput, UnitUncheckedUpdateWithoutFeaturesInput>
  }

  export type UnitUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeUpdateOneWithoutUnitsNestedInput
    leases?: LeaseUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUncheckedUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PropertyCreateWithoutStandingChargesInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    landlord?: LandlordCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
    units?: UnitCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutStandingChargesInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    categoryId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    securityDeposits?: PropertySecurityDepositUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutStandingChargesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutStandingChargesInput, PropertyUncheckedCreateWithoutStandingChargesInput>
  }

  export type PropertyUpsertWithoutStandingChargesInput = {
    update: XOR<PropertyUpdateWithoutStandingChargesInput, PropertyUncheckedUpdateWithoutStandingChargesInput>
    create: XOR<PropertyCreateWithoutStandingChargesInput, PropertyUncheckedCreateWithoutStandingChargesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutStandingChargesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutStandingChargesInput, PropertyUncheckedUpdateWithoutStandingChargesInput>
  }

  export type PropertyUpdateWithoutStandingChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landlord?: LandlordUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
    units?: UnitUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutStandingChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutSecurityDepositsInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    landlord?: LandlordCreateNestedOneWithoutPropertiesInput
    category?: PropertyCategoryCreateNestedOneWithoutPropertiesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
    units?: UnitCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutSecurityDepositsInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    categoryId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    standingCharges?: PropertyStandingChargeUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutSecurityDepositsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutSecurityDepositsInput, PropertyUncheckedCreateWithoutSecurityDepositsInput>
  }

  export type PropertyUpsertWithoutSecurityDepositsInput = {
    update: XOR<PropertyUpdateWithoutSecurityDepositsInput, PropertyUncheckedUpdateWithoutSecurityDepositsInput>
    create: XOR<PropertyCreateWithoutSecurityDepositsInput, PropertyUncheckedCreateWithoutSecurityDepositsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutSecurityDepositsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutSecurityDepositsInput, PropertyUncheckedUpdateWithoutSecurityDepositsInput>
  }

  export type PropertyUpdateWithoutSecurityDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landlord?: LandlordUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
    units?: UnitUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutSecurityDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type LeaseCreateWithoutTenantInput = {
    id?: string
    code: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutLeasesInput
    invoices?: InvoiceCreateNestedManyWithoutLeaseInput
    payments?: PaymentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutTenantInput = {
    id?: string
    code: string
    unitId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput>
  }

  export type LeaseCreateManyTenantInputEnvelope = {
    data: LeaseCreateManyTenantInput | LeaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantEmergencyContactCreateWithoutTenantInput = {
    id?: string
    contactName: string
    relationship?: string | null
    phone?: string | null
    email?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactUncheckedCreateWithoutTenantInput = {
    id?: string
    contactName: string
    relationship?: string | null
    phone?: string | null
    email?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactCreateOrConnectWithoutTenantInput = {
    where: TenantEmergencyContactWhereUniqueInput
    create: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput>
  }

  export type TenantEmergencyContactCreateManyTenantInputEnvelope = {
    data: TenantEmergencyContactCreateManyTenantInput | TenantEmergencyContactCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LeaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutTenantInput, LeaseUncheckedUpdateWithoutTenantInput>
    create: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutTenantInput, LeaseUncheckedUpdateWithoutTenantInput>
  }

  export type LeaseUpdateManyWithWhereWithoutTenantInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantEmergencyContactWhereUniqueInput
    update: XOR<TenantEmergencyContactUpdateWithoutTenantInput, TenantEmergencyContactUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput>
  }

  export type TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantEmergencyContactWhereUniqueInput
    data: XOR<TenantEmergencyContactUpdateWithoutTenantInput, TenantEmergencyContactUncheckedUpdateWithoutTenantInput>
  }

  export type TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput = {
    where: TenantEmergencyContactScalarWhereInput
    data: XOR<TenantEmergencyContactUpdateManyMutationInput, TenantEmergencyContactUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantEmergencyContactScalarWhereInput = {
    AND?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
    OR?: TenantEmergencyContactScalarWhereInput[]
    NOT?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
    id?: StringFilter<"TenantEmergencyContact"> | string
    tenantId?: StringFilter<"TenantEmergencyContact"> | string
    contactName?: StringFilter<"TenantEmergencyContact"> | string
    relationship?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    phone?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    email?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    priority?: IntFilter<"TenantEmergencyContact"> | number
    createdAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
  }

  export type TenantCreateWithoutEmergencyContactsInput = {
    id?: string
    accountNumber: string
    code: string
    tenantType?: string | null
    surname: string
    otherNames?: string | null
    gender?: string | null
    email?: string | null
    phone: string
    town?: string | null
    sendMobileNumber?: boolean
    idNoRegNo?: string | null
    taxPin?: string | null
    postalAddress?: string | null
    postalCode?: string | null
    country?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmergencyContactsInput = {
    id?: string
    accountNumber: string
    code: string
    tenantType?: string | null
    surname: string
    otherNames?: string | null
    gender?: string | null
    email?: string | null
    phone: string
    town?: string | null
    sendMobileNumber?: boolean
    idNoRegNo?: string | null
    taxPin?: string | null
    postalAddress?: string | null
    postalCode?: string | null
    country?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leases?: LeaseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmergencyContactsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmergencyContactsInput, TenantUncheckedCreateWithoutEmergencyContactsInput>
  }

  export type TenantUpsertWithoutEmergencyContactsInput = {
    update: XOR<TenantUpdateWithoutEmergencyContactsInput, TenantUncheckedUpdateWithoutEmergencyContactsInput>
    create: XOR<TenantCreateWithoutEmergencyContactsInput, TenantUncheckedCreateWithoutEmergencyContactsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmergencyContactsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmergencyContactsInput, TenantUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type TenantUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UnitCreateWithoutLeasesInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutUnitsInput
    unitType?: UnitTypeCreateNestedOneWithoutUnitsInput
    serviceCharges?: UnitServiceChargeCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberCreateNestedManyWithoutUnitInput
    features?: UnitFeatureCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutLeasesInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceCharges?: UnitServiceChargeUncheckedCreateNestedManyWithoutUnitInput
    meterNumbers?: UnitMeterNumberUncheckedCreateNestedManyWithoutUnitInput
    features?: UnitFeatureUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutLeasesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutLeasesInput, UnitUncheckedCreateWithoutLeasesInput>
  }

  export type TenantCreateWithoutLeasesInput = {
    id?: string
    accountNumber: string
    code: string
    tenantType?: string | null
    surname: string
    otherNames?: string | null
    gender?: string | null
    email?: string | null
    phone: string
    town?: string | null
    sendMobileNumber?: boolean
    idNoRegNo?: string | null
    taxPin?: string | null
    postalAddress?: string | null
    postalCode?: string | null
    country?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    emergencyContacts?: TenantEmergencyContactCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeasesInput = {
    id?: string
    accountNumber: string
    code: string
    tenantType?: string | null
    surname: string
    otherNames?: string | null
    gender?: string | null
    email?: string | null
    phone: string
    town?: string | null
    sendMobileNumber?: boolean
    idNoRegNo?: string | null
    taxPin?: string | null
    postalAddress?: string | null
    postalCode?: string | null
    country?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    emergencyContacts?: TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLeasesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeasesInput, TenantUncheckedCreateWithoutLeasesInput>
  }

  export type InvoiceCreateWithoutLeaseInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLeaseInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput>
  }

  export type InvoiceCreateManyLeaseInputEnvelope = {
    data: InvoiceCreateManyLeaseInput | InvoiceCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutLeaseInput = {
    id?: string
    receiptNumber: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutLeaseInput = {
    id?: string
    receiptNumber: string
    invoiceId?: string | null
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutLeaseInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutLeaseInput, PaymentUncheckedCreateWithoutLeaseInput>
  }

  export type PaymentCreateManyLeaseInputEnvelope = {
    data: PaymentCreateManyLeaseInput | PaymentCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutLeasesInput = {
    update: XOR<UnitUpdateWithoutLeasesInput, UnitUncheckedUpdateWithoutLeasesInput>
    create: XOR<UnitCreateWithoutLeasesInput, UnitUncheckedCreateWithoutLeasesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutLeasesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutLeasesInput, UnitUncheckedUpdateWithoutLeasesInput>
  }

  export type UnitUpdateWithoutLeasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeUpdateOneWithoutUnitsNestedInput
    serviceCharges?: UnitServiceChargeUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutLeasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCharges?: UnitServiceChargeUncheckedUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUncheckedUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type TenantUpsertWithoutLeasesInput = {
    update: XOR<TenantUpdateWithoutLeasesInput, TenantUncheckedUpdateWithoutLeasesInput>
    create: XOR<TenantCreateWithoutLeasesInput, TenantUncheckedCreateWithoutLeasesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeasesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeasesInput, TenantUncheckedUpdateWithoutLeasesInput>
  }

  export type TenantUpdateWithoutLeasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContacts?: TenantEmergencyContactUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantType?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    town?: NullableStringFieldUpdateOperationsInput | string | null
    sendMobileNumber?: BoolFieldUpdateOperationsInput | boolean
    idNoRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    taxPin?: NullableStringFieldUpdateOperationsInput | string | null
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContacts?: TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutLeaseInput, InvoiceUncheckedUpdateWithoutLeaseInput>
    create: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutLeaseInput, InvoiceUncheckedUpdateWithoutLeaseInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutLeaseInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutLeaseInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    leaseId?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    vatAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutLeaseInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutLeaseInput, PaymentUncheckedUpdateWithoutLeaseInput>
    create: XOR<PaymentCreateWithoutLeaseInput, PaymentUncheckedCreateWithoutLeaseInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutLeaseInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutLeaseInput, PaymentUncheckedUpdateWithoutLeaseInput>
  }

  export type PaymentUpdateManyWithWhereWithoutLeaseInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutLeaseInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    receiptNumber?: StringFilter<"Payment"> | string
    leaseId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    paymentReference?: StringNullableFilter<"Payment"> | string | null
    mpesaReceiptNumber?: StringNullableFilter<"Payment"> | string | null
    mpesaPhoneNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type LeaseCreateWithoutInvoicesInput = {
    id?: string
    code: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutLeasesInput
    tenant: TenantCreateNestedOneWithoutLeasesInput
    payments?: PaymentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutInvoicesInput = {
    id?: string
    code: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutInvoicesInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutInvoicesInput, LeaseUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    receiptNumber: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    receiptNumber: string
    leaseId: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type LeaseUpsertWithoutInvoicesInput = {
    update: XOR<LeaseUpdateWithoutInvoicesInput, LeaseUncheckedUpdateWithoutInvoicesInput>
    create: XOR<LeaseCreateWithoutInvoicesInput, LeaseUncheckedCreateWithoutInvoicesInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutInvoicesInput, LeaseUncheckedUpdateWithoutInvoicesInput>
  }

  export type LeaseUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutLeasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeasesNestedInput
    payments?: PaymentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalNullableFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    vatAmount?: DecimalNullableFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceNumber: string
    leaseId: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type LeaseCreateWithoutPaymentsInput = {
    id?: string
    code: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutLeasesInput
    tenant: TenantCreateNestedOneWithoutLeasesInput
    invoices?: InvoiceCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutPaymentsInput = {
    id?: string
    code: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutPaymentsInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutPaymentsInput, LeaseUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    leaseId: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type LeaseUpsertWithoutPaymentsInput = {
    update: XOR<LeaseUpdateWithoutPaymentsInput, LeaseUncheckedUpdateWithoutPaymentsInput>
    create: XOR<LeaseCreateWithoutPaymentsInput, LeaseUncheckedCreateWithoutPaymentsInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutPaymentsInput, LeaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type LeaseUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutLeasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeasesNestedInput
    invoices?: InvoiceUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitCreateManyPropertyInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    unitTypeId?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PropertyStandingChargeCreateManyPropertyInput = {
    id?: string
    chargeUtility: string
    chargeMode: string
    billingCurrency?: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    chargeValue: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySecurityDepositCreateManyPropertyInput = {
    id?: string
    month: string
    value: Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: boolean
    ofInitialRent?: boolean
    ofLastEscalation?: boolean
    excludesWithRent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitType?: UnitTypeUpdateOneWithoutUnitsNestedInput
    leases?: LeaseUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUncheckedUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUncheckedUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyStandingChargeUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeUtility?: StringFieldUpdateOperationsInput | string
    chargeMode?: StringFieldUpdateOperationsInput | string
    billingCurrency?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStandingChargeUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeUtility?: StringFieldUpdateOperationsInput | string
    chargeMode?: StringFieldUpdateOperationsInput | string
    billingCurrency?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStandingChargeUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeUtility?: StringFieldUpdateOperationsInput | string
    chargeMode?: StringFieldUpdateOperationsInput | string
    billingCurrency?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySecurityDepositUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFieldUpdateOperationsInput | boolean
    ofInitialRent?: BoolFieldUpdateOperationsInput | boolean
    ofLastEscalation?: BoolFieldUpdateOperationsInput | boolean
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySecurityDepositUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFieldUpdateOperationsInput | boolean
    ofInitialRent?: BoolFieldUpdateOperationsInput | boolean
    ofLastEscalation?: BoolFieldUpdateOperationsInput | boolean
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySecurityDepositUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ofRentBillingAmount?: BoolFieldUpdateOperationsInput | boolean
    ofInitialRent?: BoolFieldUpdateOperationsInput | boolean
    ofLastEscalation?: BoolFieldUpdateOperationsInput | boolean
    excludesWithRent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyLandlordInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    categoryId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PropertyUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
    units?: UnitUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUncheckedUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateManyCategoryInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    propertyTypeId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PropertyUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landlord?: LandlordUpdateOneWithoutPropertiesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
    units?: UnitUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUncheckedUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateManyPropertyTypeInput = {
    id?: string
    code: string
    name: string
    dateAcquired?: Date | string | null
    lrNumber?: string | null
    country?: string | null
    estateArea?: string | null
    areaRegion?: string | null
    roadStreet?: string | null
    specification?: string | null
    multiStoryType?: string | null
    numberOfFloors?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    specificContactInfo?: string | null
    landlordId?: string | null
    categoryId?: string | null
    accountLedgerType?: string | null
    primaryBankAccount?: string | null
    alternativeTaxPin?: string | null
    propertyWorkingTaxPin?: string | null
    invoicePaymentInfo?: string | null
    holderPaymentTerms?: string | null
    mpesaPropertyPayNumber?: string | null
    disableMpesaStkPush?: boolean
    disableMpesaStkNarration?: boolean
    tenantReceiptAccountCodeCounter?: number | null
    lpgExempted?: boolean
    penaltyChargeMode?: string | null
    penaltyDay?: number | null
    landlordDrawerBank?: string | null
    landlordBankBranch?: string | null
    landlordAccountName?: string | null
    landlordAccountNumber?: string | null
    exemptAllSms?: boolean
    exemptInvoiceSms?: boolean
    exemptGeneralSms?: boolean
    exemptHagueSms?: boolean
    exemptBalanceSms?: boolean
    exemptAllEmail?: boolean
    exemptInvoiceEmail?: boolean
    exemptGeneralEmail?: boolean
    exemptReceiptEmail?: boolean
    exemptBalanceEmail?: boolean
    excludeInTwoSummaryReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PropertyUpdateWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landlord?: LandlordUpdateOneWithoutPropertiesNestedInput
    category?: PropertyCategoryUpdateOneWithoutPropertiesNestedInput
    units?: UnitUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    standingCharges?: PropertyStandingChargeUncheckedUpdateManyWithoutPropertyNestedInput
    securityDeposits?: PropertySecurityDepositUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dateAcquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lrNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    estateArea?: NullableStringFieldUpdateOperationsInput | string | null
    areaRegion?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    multiStoryType?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfFloors?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specificContactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    landlordId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountLedgerType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    propertyWorkingTaxPin?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePaymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    holderPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPropertyPayNumber?: NullableStringFieldUpdateOperationsInput | string | null
    disableMpesaStkPush?: BoolFieldUpdateOperationsInput | boolean
    disableMpesaStkNarration?: BoolFieldUpdateOperationsInput | boolean
    tenantReceiptAccountCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    lpgExempted?: BoolFieldUpdateOperationsInput | boolean
    penaltyChargeMode?: NullableStringFieldUpdateOperationsInput | string | null
    penaltyDay?: NullableIntFieldUpdateOperationsInput | number | null
    landlordDrawerBank?: NullableStringFieldUpdateOperationsInput | string | null
    landlordBankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    landlordAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    exemptAllSms?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralSms?: BoolFieldUpdateOperationsInput | boolean
    exemptHagueSms?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceSms?: BoolFieldUpdateOperationsInput | boolean
    exemptAllEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptInvoiceEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptGeneralEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptReceiptEmail?: BoolFieldUpdateOperationsInput | boolean
    exemptBalanceEmail?: BoolFieldUpdateOperationsInput | boolean
    excludeInTwoSummaryReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaseCreateManyUnitInput = {
    id?: string
    code: string
    tenantId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitServiceChargeCreateManyUnitInput = {
    id?: string
    serviceUtilityAmenity: string
    costPerArea?: Decimal | DecimalJsLike | number | string | null
    totalCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitMeterNumberCreateManyUnitInput = {
    id?: string
    meterNo: string
    readingSetup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitFeatureCreateManyUnitInput = {
    id?: string
    name: string
    featureType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeasesNestedInput
    invoices?: InvoiceUpdateManyWithoutLeaseNestedInput
    payments?: PaymentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitServiceChargeUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceUtilityAmenity?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceChargeUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceUtilityAmenity?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceChargeUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceUtilityAmenity?: StringFieldUpdateOperationsInput | string
    costPerArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMeterNumberUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    meterNo?: StringFieldUpdateOperationsInput | string
    readingSetup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMeterNumberUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    meterNo?: StringFieldUpdateOperationsInput | string
    readingSetup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMeterNumberUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    meterNo?: StringFieldUpdateOperationsInput | string
    readingSetup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitFeatureUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitFeatureUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitFeatureUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateManyUnitTypeInput = {
    id?: string
    code: string
    name: string
    sequence?: number | null
    propertyId: string
    quotedPrice?: Decimal | DecimalJsLike | number | string | null
    baseRent?: Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    areaSqFt?: Decimal | DecimalJsLike | number | string | null
    chargePlan?: string | null
    floor?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    furnished?: boolean
    outSourceParking?: string | null
    ownerOccupied?: boolean
    electricityAcno?: string | null
    waterAcno?: string | null
    electricityMeethno?: string | null
    waterMeethno?: string | null
    takeOnLettingDate?: Date | string | null
    tenantResidentCodeCounter?: number | null
    apartmentNotes?: string | null
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitUpdateWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutUnitsNestedInput
    leases?: LeaseUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leases?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    serviceCharges?: UnitServiceChargeUncheckedUpdateManyWithoutUnitNestedInput
    meterNumbers?: UnitMeterNumberUncheckedUpdateManyWithoutUnitNestedInput
    features?: UnitFeatureUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sequence?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: StringFieldUpdateOperationsInput | string
    quotedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseRent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basePerUnitArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    areaSqFt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chargePlan?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    furnished?: BoolFieldUpdateOperationsInput | boolean
    outSourceParking?: NullableStringFieldUpdateOperationsInput | string | null
    ownerOccupied?: BoolFieldUpdateOperationsInput | boolean
    electricityAcno?: NullableStringFieldUpdateOperationsInput | string | null
    waterAcno?: NullableStringFieldUpdateOperationsInput | string | null
    electricityMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    waterMeethno?: NullableStringFieldUpdateOperationsInput | string | null
    takeOnLettingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantResidentCodeCounter?: NullableIntFieldUpdateOperationsInput | number | null
    apartmentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaseCreateManyTenantInput = {
    id?: string
    code: string
    unitId: string
    startDate: Date | string
    endDate?: Date | string | null
    rentAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentDay?: number
    securityDeposit?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TenantEmergencyContactCreateManyTenantInput = {
    id?: string
    contactName: string
    relationship?: string | null
    phone?: string | null
    email?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutLeasesNestedInput
    invoices?: InvoiceUpdateManyWithoutLeaseNestedInput
    payments?: PaymentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentDay?: IntFieldUpdateOperationsInput | number
    securityDeposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantEmergencyContactUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyLeaseInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyLeaseInput = {
    id?: string
    receiptNumber: string
    invoiceId?: string | null
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity?: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string | null
    vatAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    receiptNumber: string
    leaseId: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentMethod: $Enums.PaymentMethod
    paymentReference?: string | null
    mpesaReceiptNumber?: string | null
    mpesaPhoneNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vatAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaReceiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mpesaPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}